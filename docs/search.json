[
  {
    "objectID": "03_figure_03.html",
    "href": "03_figure_03.html",
    "title": "Place New Strains in Spectral Tree",
    "section": "",
    "text": "julia-setup\nusing DrWatson\n@quickactivate projectdir()\n\nusing HypothesisTests\nusing MultipleTesting: adjust, BenjaminiHochberg, Bonferroni\nusing SpectralInference\nusing NeighborJoining\nusing NewickTree\nusing StatsBase\nusing CSV, DataFrames, Muon\ninclude(srcdir(\"helpers.jl\"))\n\nbbtreedir = datadir(\"exp_pro\", \"BB669\") |&gt; mkpath\npdir_csbtree = plotsdir(\"CSB669_trees\") |&gt; mkpath\npdir_csb_micurve = plotsdir(\"CSB669_micurve\") |&gt; mkpath\n\n\nusing StatsPlots\ntheme(:default, grid=false, label=false, tickdir=:out)\n\nusing RCall\nR\"\"\"\nlibrary(ape)\nlibrary(treeio)\nlibrary(ggtree)\nlibrary(ggplot2)\nlibrary(tidyverse)\n\nsetwd($(projectdir()))\n\"\"\";"
  },
  {
    "objectID": "03_figure_03.html#projecting-in-strains-from-the-commensal-strain-bank",
    "href": "03_figure_03.html#projecting-in-strains-from-the-commensal-strain-bank",
    "title": "Place New Strains in Spectral Tree",
    "section": "Projecting in strains from the commensal strain bank",
    "text": "Projecting in strains from the commensal strain bank\nKnow that we have a latent space of bacterial evolutionary diversity, see previous notebook. We want to know if it informs us about the relatedness of our newly sequenced gut commensal strains. Have we learned something general about biology or just the idiosyncrasies of the UniProt dataset?\nTo do this we leverage the fact that the UniProt latest spaces is built using SVD/PCA, which means that we can linearly project new data into that latest space.\n\n# read in data\nuniprot = readh5ad(datadir(\"exp_raw\", \"UP7047\", \"2020_02_UP7047.h5ad\"))\nbiobank = readh5mu(datadir(\"exp_raw\", \"BB669\", \"BB669.h5mu\"))\n\n┌ Warning: Cannot join columns with the same name because var_names are intersecting.\n└ @ Muon /Users/bend/.julia/packages/Muon/eLqpV/src/mudata.jl:351\n\n\nMuData object 669 ✕ 21475\n└ metabolites_foldchange\n  AnnData object 669 ✕ 50\n└ UPorder_oggs\n  AnnData object 669 ✕ 10177\n└ oggs\n  AnnData object 669 ✕ 11248\n\n\n\n# remake UniProt latent space\nupmtx = uniprot.X[:, :]\nupusv = svd(upmtx)\n# get strain bank strains annotated in same way as UniProt\nbbmtx = biobank[\"UPorder_oggs\"].X[:,:]\nsize(bbmtx)\n\n(669, 10177)\n\n\n\n# project into uniprot spectral latent space\n# uses ̂u = newdata * V * S_inverse\nbbuhat = projectinLSV(bbmtx, upusv)\n\n669×7047 Matrix{Float64}:\n -0.00710957  -0.016346   0.0109378   …   0.0620108   -0.195298\n -0.0101422   -0.0235557  0.0183793       0.290321    -0.216655\n -0.00988477  -0.0228117  0.0172847       0.197863    -0.268172\n -0.00911707  -0.0213556  0.0163378      -0.201534    -0.00658134\n -0.0100938   -0.0234382  0.0181515      -0.245223    -0.123784\n -0.0100751   -0.0234404  0.018099    …  -0.247896    -0.121264\n -0.0126152   -0.0291861  0.0252202      -0.204816    -0.265976\n -0.00982738  -0.0232259  0.0177415      -0.25874     -0.253145\n -0.0130485   -0.0308516  0.0269812      -0.270194     0.0506157\n -0.00927287  -0.0215109  0.0162395      -0.171792    -0.0400535\n  ⋮                                   ⋱   ⋮           \n -0.00895884  -0.0207339  0.0178657   …   0.106219    -0.317428\n -0.00903688  -0.0208161  0.0180687       0.118437    -0.345223\n -0.0129656   -0.0307315  0.027649       -0.133769    -0.110028\n -0.00931925  -0.0204614  0.0181975      -0.00752627  -0.526419\n -0.00569943  -0.0126175  0.00958138     -0.0114675    0.0068527\n -0.0131057   -0.0291628  0.02421     …   0.11391     -0.220464\n -0.0105281   -0.0236117  0.0181563       0.209295    -0.213963\n -0.00931614  -0.0204485  0.0181861      -0.0130234   -0.506454\n -0.00562719  -0.0121077  0.0097389      -0.200105    -0.0085347\n\n\n\n# calcuated distance between gut commensal strains contextualized by UniProt strain diversity\ndij = spectraldistances(bbuhat, upusv.S; alpha=1.5, q=.75);\ntreestr = NeighborJoining.newickstring(regNJ(dij), biobank.obs_names)\nbbtree = readnw(treestr)\nladderize!(bbtree)\n\n669\n\n\n\n# write out CSB biobank tree\nopen(joinpath(bbtreedir, \"BB669-tree.nw\"), \"w\") do io\n    writenw(io, bbtree)\nend\n\n18586\n\n\n\n# plot tree\nR\"\"\"\nbb669obs = read.table($(datadir(\"exp_raw\", \"BB669\", \"BB669_rowmeta.tsv\")), sep=\"\\t\", header=1)\nbb669obs$NCBI.Family[bb669obs$NCBI.Family == \"&lt;unclassified&gt;\"] = \"&lt;unknown family&gt;\"\nbb669obs$ID = bb669obs$Strain.ID\nbb669tree = read.newick($(joinpath(bbtreedir, \"BB669-tree.nw\")))\nbb669tree = as.treedata(left_join(as_tibble(bb669tree), bb669obs, by = c(\"label\" = \"Strain.ID\")))\nbb669tree_tbl = as_tibble(bb669tree)\n\nmode_family = offspring(bb669tree_tbl, bb669tree_tbl$node, tiponly = FALSE, self_include = TRUE)\nmode_family = unlist(lapply(mode_family, function(x) modeest::mfv1(x$NCBI.Family, na_rm=TRUE)))\n\nbb669tree_tbl$mode_family = mode_family\nbb669tree_tbl$label = paste(str_pad(bb669tree_tbl$ID, 10, side=\"right\"), bb669tree_tbl$NCBI.Species, sep=\" \")\nbb669tree = as.treedata(bb669tree_tbl)\nfamilynames = names(sort(table(bb669obs$NCBI.Family), decreasing = TRUE))\n\ncolorvalues = RColorBrewer::brewer.pal(12, name=\"Set3\")\np = ggtree(bb669tree, \n    aes(color=mode_family), \n    size=.5,\n    layout=\"fan\", open.angle=10,\n    branch.length=\"none\",\n    )  %&gt;% rotate_tree(-90) +\n    ggtitle(\"CSB Spectral Tree (N=669, UP context)\") + \n    scale_color_manual(values=colorvalues, breaks=familynames)\nggsave(file.path($pdir_csbtree, \"CSB669_SPItree.svg\"), \n    p,\n    height=10,\n    width=10,\n)\n\"\"\"\nshow_svg(joinpath(pdir_csbtree, \"CSB669_SPItree.svg\"))\n\n┌ Warning: RCall.jl: Scale for y is already present.\n│ Adding another scale for y, which will replace the existing scale.\n│ Coordinate system already present. Adding new coordinate system, which will\n│ replace the existing one.\n└ @ RCall /Users/bend/.julia/packages/RCall/YrsKg/src/io.jl:172\n\n\n\n\n\nAdd labels to the tips\n\nR\"\"\"\np = ggtree(bb669tree, \n    aes(color=mode_family), \n    size=.5,\n    layout=\"fan\", open.angle=10,\n    branch.length=\"none\",\n    )  %&gt;% rotate_tree(-90) +\n    geom_tiplab2(aes(text=label), size=1, family=\"mono\") +\n    ggtitle(\"CSB Spectral Tree (N=669, UP context)\") +\n    scale_color_manual(values=colorvalues, breaks=familynames)\nggsave(file.path($pdir_csbtree, \"CSB669_SPItree_withtiplabels.svg\"), \n    p,\n    height=10,\n    width=10,\n)\n\"\"\"\nshow_svg(joinpath(pdir_csbtree, \"CSB669_SPItree_withtiplabels.svg\"))\n\n┌ Warning: RCall.jl: Scale for y is already present.\n│ Adding another scale for y, which will replace the existing scale.\n│ Coordinate system already present. Adding new coordinate system, which will\n│ replace the existing one.\n└ @ RCall /Users/bend/.julia/packages/RCall/YrsKg/src/io.jl:172"
  },
  {
    "objectID": "03_figure_03.html#sub-trees",
    "href": "03_figure_03.html#sub-trees",
    "title": "Place New Strains in Spectral Tree",
    "section": "Sub-trees",
    "text": "Sub-trees\nLet’s check some local neighbors around certain taxa. Expanding out from individual taxa shows the other strain replicates of that species. And, we see sub-species groupings!\n\nnthparent(n, i) = i &lt; 1 ? n : nthparent(parent(n), i-1)\nrename_treeleaves!(tree, idmapping) = begin\n    for node in getleaves(tree)\n        NewickTree.setname!(node, idmapping[name(node)])\n    end\n    tree\nend\n\nrename_treeleaves! (generic function with 1 method)\n\n\n\nbbtree_leaves = getleaves(bbtree);\n\n\ntargetid = \"DFI.1.13\"\nbasenode = bbtree_leaves[findfirst(n-&gt;name(n) == targetid, bbtree_leaves)]\nsubtree = readnw(nwstr(nthparent(basenode, 3)))\ntiplabels = join.(eachrow(biobank.obs[indexin(getleafnames(subtree), biobank.obs.Strain_ID), [:Strain_ID, :NCBI_Species]]), \" \")\nidmapping = Dict(k=&gt;v for (k,v) in zip(getleafnames(subtree), tiplabels))\nrename_treeleaves!(subtree, idmapping)\nplot(subtree,\n    c=:turquoise3, alpha=.5,\n    lw=2, fs=7,\n    size=(600,600),\n    rightmargin=5Plots.cm,\n    yflip=true\n)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ntargetid = \"MSK.17.12\"\nbasenode = bbtree_leaves[findfirst(n-&gt;name(n) == targetid, bbtree_leaves)]\nsubtree = readnw(nwstr(nthparent(basenode, 3)))\ntiplabels = join.(eachrow(biobank.obs[indexin(getleafnames(subtree), biobank.obs.Strain_ID), [:Strain_ID, :NCBI_Species]]), \" \")\nidmapping = Dict(k=&gt;v for (k,v) in zip(getleafnames(subtree), tiplabels))\nrename_treeleaves!(subtree, idmapping)\nplot(subtree,\n    c=:goldenrod, alpha=.5,\n    lw=2, fs=7,\n    size=(600,600),\n    rightmargin=5Plots.cm,\n)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ntargetid = \"MSK.17.12\"\nbasenode = bbtree_leaves[findfirst(n-&gt;name(n) == targetid, bbtree_leaves)]\nsubtree = readnw(nwstr(nthparent(basenode, 3)))\ntiplabels = join.(eachrow(biobank.obs[indexin(getleafnames(subtree), biobank.obs.Strain_ID), [:Strain_ID, :NCBI_Species]]), \" \")\nidmapping = Dict(k=&gt;v for (k,v) in zip(getleafnames(subtree), tiplabels))\nrename_treeleaves!(subtree, idmapping)\nplot(subtree,\n    c=:goldenrod, alpha=.5,\n    lw=2, fs=7,\n    size=(600,600),\n    rightmargin=5Plots.cm,\n)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nOne thing to notice as we view these sub trees is that they are grouping by NCBI species, but there are further sub-groupings within each species. The ID convention for our strains is “&lt;sampling hospital&gt;.&lt;donor&gt;.&lt;strain&gt;”. Knowing this naming convention we realized that the sub-groups were corresponding to the donor these strains were sampled from\nThis becomes more obvious as we color by donor id\n\ndonorcolormap = Dict(k=&gt;v for (k,v) in zip(unique(biobank.obs.Donor), palette(:glasbey_bw_n256, length(unique(biobank.obs.Donor)))));\n\n\n# sub-setting to B. uniformis strains\ntargetid = \"MSK.17.15\"\nbasenode = bbtree_leaves[findfirst(n-&gt;name(n) == targetid, bbtree_leaves)]\nsubtree = readnw(nwstr(nthparent(basenode, 1)))\nsubtree_ids = getleafnames(subtree)\n\nlinecolors = map(prewalk(subtree)) do node\n    leafids = getleafnames(node)\n    donorids = biobank.obs.Donor[indexin(leafids, biobank.obs.Strain_ID)]\n    length(unique(donorids)) == 1 ? donorcolormap[mode(donorids)] : :grey\nend |&gt; x-&gt;x[2:end] |&gt; permutedims\n\ntiplabels = join.(eachrow(biobank.obs[indexin(getleafnames(subtree), biobank.obs.Strain_ID), [:Strain_ID, :NCBI_Species]]), \" \")\nidmapping = Dict(k=&gt;v for (k,v) in zip(getleafnames(subtree), tiplabels))\nrename_treeleaves!(subtree, idmapping)\nplot(subtree,\n    c=linecolors,\n    lw=2, fs=7,\n    size=(600,600),\n    rightmargin=5Plots.cm,\n)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWhat components were needed to resolve these clusters? If we plot the projections of the taxa onto each of the components, we see that differences between these sub-species clusters only really shows up after PC 10.\n\nsubtree_idx = indexin(subtree_ids, biobank.obs.Strain_ID)\npltmtx = sign.(bbuhat[subtree_idx, :]) # sign of projection\n# pltmtx = sign.(bbuhat[subtree_idx, :]) .* log10.(abs.(bbuhat[subtree_idx, :])) # pseudo-logscale \n# pltmtx = bbuhat[subtree_idx, :] # actual projection\nxmarks = [1:9..., 10:10:90..., 100:100:900..., 1000:1000:7000...]\nheatmap(pltmtx, \n    xscale=:log10, \n    c=:bwr, \n    clims=getlims(pltmtx),\n    framestyle=:grid, \n    xticks=(xmarks, map(x-&gt; (log10(x) % 1 == 0) || x==7000 ? x : \"\", xmarks)),\n    xrotation=45,\n    xmirror=true,\n    xtickfontsize=7,\n    yticks=(1:length(subtree_idx), subtree_ids),\n    size=(1200, 500),\n    margin=5Plots.mm,\n    topmargin=10Plots.mm,\n    gridalpha=1,\n    xlabel=\"Principal component\",\n)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n# sub-setting to M. gnavus strains\ntargetid = \"MSK.22.24\"\nbasenode = bbtree_leaves[findfirst(n-&gt;name(n) == targetid, bbtree_leaves)]\nsubtree = readnw(nwstr(nthparent(basenode, 9)))\nsubtree_ids = getleafnames(subtree)\n\nlinecolors = map(prewalk(subtree)) do node\n    leafids = getleafnames(node)\n    donorids = biobank.obs.Donor[indexin(leafids, biobank.obs.Strain_ID)]\n    length(unique(donorids)) == 1 ? donorcolormap[mode(donorids)] : :grey\nend |&gt; x-&gt;x[2:end] |&gt; permutedims\n\ntiplabels = join.(eachrow(biobank.obs[indexin(getleafnames(subtree), biobank.obs.Strain_ID), [:Strain_ID, :NCBI_Species]]), \" \")\nidmapping = Dict(k=&gt;v for (k,v) in zip(getleafnames(subtree), tiplabels))\nrename_treeleaves!(subtree, idmapping)\nplot(subtree,\n    c=linecolors,\n    lw=2, fs=7,\n    size=(600,600),\n    rightmargin=5Plots.cm,\n)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nsubtree_idx = indexin(subtree_ids, biobank.obs.Strain_ID)\npltmtx = sign.(bbuhat[subtree_idx, :]) # sign of projection\n# pltmtx = sign.(bbuhat[subtree_idx, :]) .* log10.(abs.(bbuhat[subtree_idx, :])) # pseudo-logscale \n# pltmtx = bbuhat[subtree_idx, :] # actual projection\nxmarks = [1:9..., 10:10:90..., 100:100:900..., 1000:1000:7000...]\nheatmap(pltmtx, \n    xscale=:log10, \n    c=:bwr, \n    clims=getlims(pltmtx),\n    framestyle=:grid, \n    xticks=(xmarks, map(x-&gt; (log10(x) % 1 == 0) || x==7000 ? x : \"\", xmarks)),\n    xrotation=45,\n    xmirror=true,\n    xtickfontsize=7,\n    yticks=(1:length(subtree_idx), subtree_ids),\n    size=(1200, 500),\n    margin=5Plots.mm,\n    topmargin=10Plots.mm,\n    gridalpha=1,\n    xlabel=\"Principal component\",\n)"
  },
  {
    "objectID": "03_figure_03.html#mutual-information-across-tree",
    "href": "03_figure_03.html#mutual-information-across-tree",
    "title": "Place New Strains in Spectral Tree",
    "section": "Mutual information across tree",
    "text": "Mutual information across tree\nAgain we wan’t to look systematically over our tree, to verify that the patterns we saw in the above two examples are consistent with the general patterns in the tree.\nThus we compare grouping in our tree to both NCBI taxonomy and GTDB taxonomy.\n\nNCBI taxonomy\n\nNBOOTS = 50;\ncolnames = [:NCBI_Phylum, :NCBI_Class, :NCBI_Order, :NCBI_Family, :NCBI_Genus, :NCBI_Species, :Donor];\n\n\nBB_NCBI_taxonomy = biobank.obs[:, colnames]\nobs_names = biobank.obs_names.vals;\nrowmask = map(eachrow(BB_NCBI_taxonomy)) do row\n    !any(==(\"&lt;unclassified&gt;\"), row)\nend;\nmi_results = map(1:NBOOTS) do i\n    pairedMI_across_treedepth(eachcol(BB_NCBI_taxonomy), obs_names, bbtree; mask=rowmask, bootstrap=true, ncuts=100, treecut_distancefun=network_distance)\nend;\n\n\nmi_results_df = DataFrame()\nfor (i, res) in enumerate(mi_results)\n    mi_results_df = vcat(\n        mi_results_df, \n        hcat(\n            DataFrame(bootstrap=i, treedepth=last(res)),\n            DataFrame(first(res), colnames),\n            DataFrame(scaledcumsum.(first(res)), string.(colnames) .* \"_scaledcumsum\"),\n        )\n    )\nend\n\nCSV.write(joinpath(bbtreedir, \"NCBI_raw_MI_values.csv\"), mi_results_df)\nfirst(mi_results_df, 5)\n\n5×16 DataFrame\n\n\n\nRow\nbootstrap\ntreedepth\nNCBI_Phylum\nNCBI_Class\nNCBI_Order\nNCBI_Family\nNCBI_Genus\nNCBI_Species\nDonor\nNCBI_Phylum_scaledcumsum\nNCBI_Class_scaledcumsum\nNCBI_Order_scaledcumsum\nNCBI_Family_scaledcumsum\nNCBI_Genus_scaledcumsum\nNCBI_Species_scaledcumsum\nDonor_scaledcumsum\n\n\n\nInt64\nFloat64\nFloat64\nFloat64\nFloat64\nFloat64\nFloat64\nFloat64\nFloat64\nFloat64\nFloat64\nFloat64\nFloat64\nFloat64\nFloat64\nFloat64\n\n\n\n\n1\n1\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n\n\n2\n1\n0.414141\n0.00882844\n0.00833942\n0.00821489\n0.0064997\n0.000679639\n8.13609e-5\n0.000191702\n0.00116559\n0.00113131\n0.00111393\n0.000987271\n0.00020887\n3.67448e-5\n0.00100972\n\n\n3\n1\n0.828283\n0.00889856\n0.00864961\n0.00814509\n0.0064801\n0.000668887\n5.38116e-5\n0.000253596\n0.00234043\n0.0023047\n0.0022184\n0.00197156\n0.000414437\n6.10477e-5\n0.00234543\n\n\n4\n1\n1.24242\n0.0102742\n0.0100259\n0.00949992\n0.00760295\n0.000680136\n6.71667e-5\n0.000193861\n0.00369689\n0.00366479\n0.00350659\n0.00312641\n0.00062346\n9.1382e-5\n0.00336652\n\n\n5\n1\n1.65657\n0.0104848\n0.0101054\n0.0100504\n0.00739362\n0.00073783\n4.06672e-5\n0.000155719\n0.00508116\n0.00503567\n0.00486942\n0.00424947\n0.000850214\n0.000109748\n0.00418671\n\n\n\n\n\n\n\npltdf = mi_results_df |&gt;\n    df -&gt; stack(df, 10:16, [:bootstrap, :treedepth]) |&gt; \n    df -&gt; transform(df, :variable =&gt; ByRow(x-&gt;replace(x, \"_scaledcumsum\"=&gt;\"\")) =&gt; identity) |&gt;\n    df -&gt; groupby(df, [:variable, :treedepth]) |&gt;\n    df -&gt; combine(df,\n        :value =&gt; mean =&gt; :MI_mean,\n        :value =&gt; std =&gt; :MI_std,\n    ) |&gt; \n    df -&gt; sort(df, [])\n\ntaxonomylevels = permutedims(string.(colnames))\ntaxarankcolors = [:red :pink :orange :lightblue :green :aqua :lightgreen];\n\nplot(title=\"CSB spectral tree (NCBI)\", ylabel=\"Cumulative MI\\n (density)\", xlabel=\"Spectral Tree depth\",\n    legend=:outerright,\n    size=(700,250),\n    margin=5Plots.mm,  \n)\nfor (tlab, tcol) in reverse(collect(zip(taxonomylevels, taxarankcolors)))\n    df = filter(:variable =&gt; ==(tlab), pltdf)\n    @df df plot!(:treedepth, :MI_mean, ribbon=2 .* :MI_std, label=tlab, c=tcol, lw=1)\nend\nplot!()\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGTDB Taxonomy\n\nNBOOTS = 50;\ncolnames = [:GTDB_Phylum, :GTDB_Class, :GTDB_Order, :GTDB_Family, :GTDB_Genus, :GTDB_Species, :Donor];\n\n\nBB_NCBI_taxonomy = biobank.obs[:, colnames]\nobs_names = biobank.obs_names.vals;\nrowmask = map(eachrow(BB_NCBI_taxonomy)) do row\n    !any(==(\"&lt;unclassified&gt;\"), row)\nend;\nmi_results = map(1:NBOOTS) do i\n    pairedMI_across_treedepth(eachcol(BB_NCBI_taxonomy), obs_names, bbtree; mask=rowmask, bootstrap=true, ncuts=100, treecut_distancefun=network_distance)\nend;\n\n\nmi_results_df = DataFrame()\nfor (i, res) in enumerate(mi_results)\n    mi_results_df = vcat(\n        mi_results_df, \n        hcat(\n            DataFrame(bootstrap=i, treedepth=last(res)),\n            DataFrame(first(res), colnames),\n            DataFrame(scaledcumsum.(first(res)), string.(colnames) .* \"_scaledcumsum\"),\n        )\n    )\nend\n\nCSV.write(joinpath(bbtreedir, \"GTDB_raw_MI_values.csv\"), mi_results_df)\nfirst(mi_results_df, 5)\n\n5×16 DataFrame\n\n\n\nRow\nbootstrap\ntreedepth\nGTDB_Phylum\nGTDB_Class\nGTDB_Order\nGTDB_Family\nGTDB_Genus\nGTDB_Species\nDonor\nGTDB_Phylum_scaledcumsum\nGTDB_Class_scaledcumsum\nGTDB_Order_scaledcumsum\nGTDB_Family_scaledcumsum\nGTDB_Genus_scaledcumsum\nGTDB_Species_scaledcumsum\nDonor_scaledcumsum\n\n\n\nInt64\nFloat64\nFloat64\nFloat64\nFloat64\nFloat64\nFloat64\nFloat64\nFloat64\nFloat64\nFloat64\nFloat64\nFloat64\nFloat64\nFloat64\nFloat64\n\n\n\n\n1\n1\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n\n\n2\n1\n0.414141\n0.00806298\n0.0080814\n0.00806191\n0.00706748\n0.000585956\n3.46039e-5\n0.000222156\n0.00111949\n0.00112265\n0.00111685\n0.00112466\n0.000199069\n1.64617e-5\n0.00127043\n\n\n3\n1\n0.828283\n0.00843922\n0.00836679\n0.00845619\n0.00706503\n0.000376265\n4.28295e-5\n0.000152165\n0.00229121\n0.00228494\n0.00228833\n0.00224892\n0.000326899\n3.68365e-5\n0.00214061\n\n\n4\n1\n1.24242\n0.00986423\n0.00980809\n0.00969203\n0.00765562\n0.000552507\n2.39054e-5\n0.000169705\n0.00366078\n0.00364746\n0.00363101\n0.00346717\n0.000514604\n4.82087e-5\n0.00311109\n\n\n5\n1\n1.65657\n0.0102265\n0.00953659\n0.00919257\n0.0084261\n0.000462298\n4.03876e-5\n0.00024715\n0.00508066\n0.00497226\n0.0049045\n0.00480802\n0.000671662\n6.74218e-5\n0.00452445\n\n\n\n\n\n\n\npltdf = mi_results_df |&gt;\n    df -&gt; stack(df, 10:16, [:bootstrap, :treedepth]) |&gt; \n    df -&gt; transform(df, :variable =&gt; ByRow(x-&gt;replace(x, \"_scaledcumsum\"=&gt;\"\")) =&gt; identity) |&gt;\n    df -&gt; groupby(df, [:variable, :treedepth]) |&gt;\n    df -&gt; combine(df,\n        :value =&gt; mean =&gt; :MI_mean,\n        :value =&gt; std =&gt; :MI_std,\n    ) |&gt; \n    df -&gt; sort(df, [])\n\ntaxonomylevels = permutedims(string.(colnames))\ntaxarankcolors = [:red :pink :orange :lightblue :green :aqua :lightgreen];\n\nplot(title=\"CSB spectral tree (GTDB)\",  ylabel=\"Cumulative MI\\n (density)\", xlabel=\"Spectral Tree depth\",\n    legend=:outerright,\n    size=(700,250),\n    margin=5Plots.mm,  \n)\nfor (tlab, tcol) in reverse(collect(zip(taxonomylevels, taxarankcolors)))\n    df = filter(:variable =&gt; ==(tlab), pltdf)\n    @df df plot!(:treedepth, :MI_mean, ribbon=2 .* :MI_std, label=tlab, c=tcol, lw=1)\nend\nplot!()"
  },
  {
    "objectID": "03_figure_03.html#relative-distances",
    "href": "03_figure_03.html#relative-distances",
    "title": "Place New Strains in Spectral Tree",
    "section": "Relative Distances",
    "text": "Relative Distances\nComparing the Spectral tree to the 16S or bac120 trees. We find that we are able to represent genomic strain level variation where neither 16S nor Bac120 annotations can.\n\n# strain ids for 669 samples in CSB\nobs_names = biobank.obs.Strain_ID;\n\n# re-read in biobank tree (same as what is plotted above)\nbbtree = readnw(readline(joinpath(bbtreedir, \"BB669-tree.nw\")))\nas_polytomy!(n-&gt;NewickTree.support(n)&lt;0.5, bbtree)\nladderize!(bbtree)\nleafnames_spitree = getleafnames(bbtree); # same order as returned by patristic_distances\norder_treespitree = indexin(leafnames_spitree, obs_names);\n\n# read in tree built from bac120 annotations\ntreebac120 = readnw(readline(projectdir(\"_research\",\"BB669_bac120_phyml\",\"BB669_bac120.phy-supporttree.txt\")))\nas_polytomy!(n-&gt;NewickTree.support(n)&lt;0.5, treebac120)\nladderize!(treebac120)\nleafnames_bac120 = getleafnames(treebac120); # same order as returned by patristic_distances\norder_treebac120 = indexin(leafnames_bac120, obs_names);\n\n# read in tree built from 16S sequence\ntree16s = readnw(readline(projectdir(\"_research\",\"BB669_16S_phyml\",\"BB669_16S.phy-supporttree.txt\")))\nas_polytomy!(n-&gt;NewickTree.support(n)&lt;0.5, tree16s)\nladderize!(tree16s)\nleafnames_16S = getleafnames(tree16s); # same order as returned by patristic_distances\norder_tree16S = indexin(leafnames_16S, obs_names);\n\n# 1 taxa from the CSB got dropped because we couldn't get a good annotated 16S read\n# so I am collecting the sample mapping here between the taxa in the tree and\n# the taxa in CSB\norder_spi_tree16s = indexin(leafnames_16S, leafnames_spitree);\n# likewise 5 taxa from CSB got dropped when annotating with bac120\norder_spi_treebac120 = indexin(leafnames_bac120, leafnames_spitree);\n\n\nbbtaxa = biobank.obs[:,[:NCBI_Phylum, :NCBI_Class, :NCBI_Order, :NCBI_Family, :NCBI_Genus, :NCBI_Species]];\ntaxanomicdistance = pairwise(eachrow(Matrix(bbtaxa)[:,6:-1:1])) do a, b\n    x = findfirst(a .== replace(b, \"&lt;unclassified&gt;\"=&gt;\"missing\"))\n    x === nothing ? 6 : x-1\nend;\n\n\n# get patristic distances between each leaf of the spectral tree\nsixPij = patristic_distances(tree16s);\nbacPij = patristic_distances(treebac120);\nspiPij = patristic_distances(bbtree);\n\n# mask to collect just upper triangle of distance matrix for each dataset\nuppertriangle_six = triu(trues(size(sixPij)), 1);\nuppertriangle_bac = triu(trues(size(bacPij)), 1);\nuppertriangle_spi = triu(trues(size(spiPij)), 1);\n\n# get upper triangle\nsixPij = sixPij[uppertriangle_six];\nbacPij = bacPij[uppertriangle_bac];\nspiPij = spiPij[uppertriangle_spi];\n\n# reorder distance matrix to same order as metadata file\nsixTij = taxanomicdistance[order_tree16S, order_tree16S][uppertriangle_six];\nbacTij = taxanomicdistance[order_treebac120, order_treebac120][uppertriangle_bac];\nspiTij = taxanomicdistance[order_treespitree, order_treespitree][uppertriangle_spi];\n\n# scaled distances to between 0 and 1\nspiPij_rel = (spiPij ./ maximum(spiPij));\nbacPij_rel = (bacPij ./ maximum(bacPij));\nsixPij_rel = (sixPij ./ maximum(sixPij));\n\n\n\nplot relative density distributions\np1 = plot(\n    xlims=(0,1), \n    widen=1, \n    xticks=(0:.25:1, [\"0.0\", \"\", \"0.5\", \"\", \"1.0\"]),\n    # ylabel=\"same species\",\n    # size=(400, 250),\n)\n# patristic distance of pairs that are the same genus\nviolin!([\"same\\n genus\"], spiPij_rel[spiTij .== 1], # normed dist\n    trim=true, side=:right,\n    c=:blue, fill=0, linecolor=:black, lw=1,\n    label=\"Spectral tree\",\n    permute=(:x, :y),\n)\nviolin!([\"same\\n genus\"], bacPij_rel[bacTij .== 1], # normed dist\n    trim=true, side=:right,\n    c=:yellow, fill=0, linecolor=:black, lw=1,\n    label=\"Bac120 tree\",\n    permute=(:x, :y),\n)\n# patristic distance of pairs that are the same species\nviolin!([\"same\\n species\"], spiPij_rel[spiTij .== 0], # normed dist\n    trim=true, side=:right,\n    c=:blue, fill=0, linecolor=:black, lw=1,\n    # label=\"Spectral Tree\",\n    permute=(:x, :y),\n)\nviolin!([\"same\\n species\"], bacPij_rel[bacTij .== 0], # normed dist\n    trim=true, side=:right,\n    c=:yellow, fill=0, linecolor=:black, lw=1,\n    # label=\"16S\",\n    permute=(:x, :y),\n)\n\np2 = plot(\n    xlims=(0,1), \n    widen=1, \n    xticks=(0:.25:1, [\"0.0\", \"\", \"0.5\", \"\", \"1.0\"]),\n    # ylabel=\"same species\",\n    # size=(400, 250),\n)\n# patristic distance of pairs that are the same genus\nviolin!([\"same\\n genus\"], spiPij_rel[spiTij .== 1], # normed dist\n    trim=true, side=:right,\n    c=:blue, fill=0, linecolor=:black, lw=1,\n    label=\"Spectral tree\",\n    permute=(:x, :y),\n)\nviolin!([\"same\\n genus\"], sixPij_rel[sixTij .== 1], # normed dist\n    trim=true, side=:right,\n    c=:orange, fill=0, linecolor=:black, lw=1,\n    label=\"16S tree\",\n    permute=(:x, :y),\n)\n# patristic distance of pairs that are the same species\nviolin!([\"same\\n species\"], spiPij_rel[spiTij .== 0], # normed dist\n    trim=true, side=:right,\n    c=:blue, fill=0, linecolor=:black, lw=1,\n    # label=\"Spectral Tree\",\n    permute=(:x, :y),\n)\nviolin!([\"same\\n species\"], sixPij_rel[sixTij .== 0], # normed dist\n    trim=true, side=:right,\n    c=:orange, fill=0, linecolor=:black, lw=1,\n    # label=\"16S\",\n    permute=(:x, :y),\n)\nplot(p1, p2, layout=grid(1,2), size=(800, 250), margin=3Plots.mm)\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# difference in distributions is significant to below floating point precision\n# same species distributions\n@show pval = pvalue(MannWhitneyUTest(spiPij_rel[spiTij.==0], bacPij_rel[bacTij.==0]); tail=:both);\n@show pval = pvalue(MannWhitneyUTest(spiPij_rel[spiTij.==0], sixPij_rel[sixTij.==0]); tail=:both);\n# same genus but different species distributions\n@show pval = pvalue(MannWhitneyUTest(spiPij_rel[spiTij.==1], bacPij_rel[bacTij.==0]); tail=:both);\n@show pval = pvalue(MannWhitneyUTest(spiPij_rel[spiTij.==1], sixPij_rel[sixTij.==0]); tail=:both);\n\npval = pvalue(MannWhitneyUTest(spiPij_rel[spiTij .== 0], bacPij_rel[bacTij .== 0]); tail = :both) = 0.0\npval = pvalue(MannWhitneyUTest(spiPij_rel[spiTij .== 0], sixPij_rel[sixTij .== 0]); tail = :both) = 0.0\npval = pvalue(MannWhitneyUTest(spiPij_rel[spiTij .== 1], bacPij_rel[bacTij .== 0]); tail = :both) = 0.0\npval = pvalue(MannWhitneyUTest(spiPij_rel[spiTij .== 1], sixPij_rel[sixTij .== 0]); tail = :both) = 0.0\n\n\n\nplot(xlims=(0,.3), size=(600,200), tickdir=:out)\nhistogram!(spiPij_rel[spiTij.==0], nbins=50, c=:blue, alpha=.5, label=\"Spectral tree\")\nhistogram!(bacPij_rel[bacTij.==0], nbins=15, c=:yellow, alpha=.5, label=\"Bac120 tree\")\nhistogram!(sixPij_rel[sixTij.==0], nbins=50, c=:orange, alpha=.5, label=\"16S tree\")"
  },
  {
    "objectID": "02_figure_02main.html",
    "href": "02_figure_02main.html",
    "title": "Calculate Spectral Tree",
    "section": "",
    "text": "julia setup\nusing DrWatson\n@quickactivate projectdir()\n\nusing SpectralInference\nusing NeighborJoining\nusing NewickTree\nusing Muon, CSV, DataFrames\nusing StatsBase\nusing Random: seed!\nusing StatsPlots\nusing Gotree_jll\ntheme(:default, grid=false, label=false, tickdir=:out)\ninclude(srcdir(\"helpers.jl\"))\nusing RCall\nR\"\"\"\nlibrary(ape)\nlibrary(treeio)\nlibrary(ggtree)\nlibrary(ggplot2)\nlibrary(tidyverse)\n\nsetwd($(projectdir()))\n\"\"\";\nddir = datadir(\"exp_raw\", \"UP7047\")\nmicurvedir = datadir(\"exp_pro\", \"UP7047\") |&gt; mkpath\npdir_tree = plotsdir(\"UP7047_treeplots\") |&gt; mkpath\npdir_micurve = plotsdir(\"UP7047_curve\") |&gt; mkpath;"
  },
  {
    "objectID": "02_figure_02main.html#spectral-tree-of-7047-strains-from-uniprot",
    "href": "02_figure_02main.html#spectral-tree-of-7047-strains-from-uniprot",
    "title": "Calculate Spectral Tree",
    "section": "Spectral Tree of 7047 strains from UniProt",
    "text": "Spectral Tree of 7047 strains from UniProt\nWe had the hypothesis that by leveraging the vast diversity of sequenced strains procured from many different environments, we could ‘fill in’ evolutionary distance within our strain bank in a more complete way.\nTo test this hypothesis, we used the 7047 bacterial proteomes within UniProt’s ‘2020_02’ release as our reference, as it contained strains collected across ocean, soil, human and mouse microbiomes, amongst other environments.\n\n# read data\nuniprot = readh5ad(datadir(\"exp_raw\", \"UP7047\", \"2020_02_UP7047.h5ad\"))\n\nAnnData object 7047 ✕ 10177\n\n\n\n# what's the matrix look like\n# 7047 bacterial strains x 10177 orthologs \n# each element is the number of sequences in the strain that map to that ortholog (emapper v2)\nupmtx = uniprot.X[:, :]\n\n7047×10177 adjoint(::Matrix{Float64}) with eltype Float64:\n 1.0  0.0  1.0  2.0  1.0  3.0  2.0  1.0  …  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 1.0  0.0  1.0  2.0  0.0  2.0  2.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 1.0  0.0  1.0  3.0  1.0  2.0  1.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  1.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 1.0  0.0  1.0  2.0  0.0  1.0  2.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 1.0  0.0  1.0  2.0  1.0  2.0  2.0  1.0  …  0.0  0.0  0.0  0.0  1.0  0.0  0.0\n 6.0  2.0  1.0  3.0  1.0  1.0  1.0  1.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  2.0  2.0  0.0  0.0  2.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 2.0  3.0  1.0  2.0  1.0  2.0  1.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  1.0  1.0  1.0  1.0  1.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n ⋮                        ⋮              ⋱  ⋮                        ⋮    \n 1.0  0.0  1.0  5.0  0.0  3.0  2.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 3.0  0.0  1.0  2.0  1.0  1.0  2.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 2.0  0.0  2.0  2.0  1.0  2.0  0.0  1.0  …  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 1.0  3.0  1.0  1.0  1.0  2.0  1.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 2.0  0.0  1.0  1.0  0.0  1.0  2.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 1.0  0.0  1.0  2.0  0.0  2.0  1.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 1.0  0.0  1.0  2.0  0.0  1.0  1.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 1.0  0.0  1.0  1.0  1.0  0.0  1.0  0.0  …  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 2.0  0.0  1.0  2.0  2.0  2.0  1.0  2.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n\n\n\n# spectrally decompose matrix with SVD\n@time usv = svd(upmtx);\n\n 57.060797 seconds (13 allocations: 2.550 GiB, 0.46% gc time)"
  },
  {
    "objectID": "02_figure_02main.html#calculating-the-spi-distance-matrix",
    "href": "02_figure_02main.html#calculating-the-spi-distance-matrix",
    "title": "Calculate Spectral Tree",
    "section": "Calculating the SPI distance matrix",
    "text": "Calculating the SPI distance matrix\nThe next step is to compute the spectral distance matrices. There are a few ways of calling this function.\nSpectralInference relies on two conceptual parts, how we partition the spectrum and how we compute the distance within that partition.\nThus, there are two main functions in SpectralInferences\ngetintervals(singularvalues)\nand\nspectraldistances()\nThis is the entirety of spectraldistances()\nfunction spectraldistances(vecs::AbstractMatrix{&lt;:T}, vals::AbstractVector{&lt;:T}, intervals::AbstractVector) where {T&lt;:Number}\n    spimtx = zeros(size(vecs, 1), size(vecs, 1))\n    for grp in intervals\n        spimtx += Distances.pairwise(WeightedEuclidean(vals[grp]), vecs'[grp, :]; dims=2)\n    end\n    return spimtx .^ 2\nend\nThere are a few different ways to call the spectraldistances() function.\nWe could just provide the full SVD object dij = spectraldistances(usv) by default this will compute the row-wise distances.\nWe could specify that we want the column-wise distances by providing the full SVD object and an option to dispatch on the V matrix\ndij = spectraldistances(usv, onrows=false) # will compute the colwise distances\nAlternatively we can explicitly provide the vectors and values to the function. Along with a vector of Ranges that specify how to split the spectrum.\nFirst we compute and plot our partitions\n\npartitions = getintervals(usv.S, alpha=1.5, q=.75);\nsize(partitions)\n\n(880,)\n\n\n\nrectangle(x, y, w, h) = Shape(x .+ [0,w,w,0], y .+ [0,0,h,h])\nplot(\n    xlabel=\"spectral depth\",\n    ylabel=\"singular value\",\n    ticks=[exp10(i) for i in 0:4],\n    scale=:log10, \n)\nplot!(usv.S, label=\"singular values\")\n\npltpars = @. rectangle(\n    first(partitions[1:end-1]), # x\n    usv.S[first(partitions[1:end-1])], # y\n    length(partitions[1:end-1]), # width\n    usv.S[first(partitions[2:end])] - usv.S[first(partitions[1:end-1])] # height\n)\nplot!(pltpars, c=:blue, alpha=.2)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThen we compute the spectral distances using these partitions\n\n@time dij = spectraldistances(usv.U, usv.S, partitions);\n\n243.653901 seconds (639.25 k allocations: 652.763 GiB, 46.67% gc time, 0.05% compilation time: 100% of which was recompilation)"
  },
  {
    "objectID": "02_figure_02main.html#calculate-a-tree-from-the-spi-distance-matrix.",
    "href": "02_figure_02main.html#calculate-a-tree-from-the-spi-distance-matrix.",
    "title": "Calculate Spectral Tree",
    "section": "calculate a tree from the SPI distance matrix.",
    "text": "calculate a tree from the SPI distance matrix.\nSo far I have been using basic hierarchical clustering functions; however, basic hierarchical clustering assumes a constant rate of evolution and because this is a dataset of natural systems (i.e. bacteria across natural evolution), this core assumption is likely broken. Thus we will use neighbor joining to compute our Spectral Tree.\nWe can calculate the tree as so…\n\n@time basetreestring = NeighborJoining.newickstring(fastNJ(dij), uniprot.obs_names)\n\n  7.771650 seconds (80.46 k allocations: 4.352 GiB, 2.59% gc time)\n\n\n\n\"((((((((((UP000196862:3.792218e+03,UP000196784:2.725449e+03):1.317085e+02,((((((((UP000000495:7.179702e+03,UP000031552:4.580198e+03):8.581783e+02,UP000220251:3.746455e+03):7.454054e+02,UP000001505:5.245389e+03):5.237153e+02,(UP000000529:8.451443e+03,UP000069902:4.70780\" ⋯ 281327 bytes ⋯ \"2.996011e+03,UP000003178:5.527377e+03):2.793630e+03):1.583835e+03):9.098764e+02,((UP000264006:2.827825e+04,UP000291469:1.076784e+04):4.983053e+03,UP000268521:1.497309e+04):1.851582e+03):8.505975e+02):2.649550e+02):9.907906e+01):3.808693e+01):1.322603e+01):0.000000e+00;\"\n\n\n\n\n# write out tree\nUP7047_treedir = projectdir(\"_research\", \"UP7047_neighborjoined_spitree\") |&gt; mkpath\nopen(joinpath(UP7047_treedir, \"2020_02_UP7047-tree.nw\"), \"w\") do io\n    println(io, basetreestring)\nend\n\nSo far we have compute the reference SPI tree, we may also want some measure of how statistically confident we are on each of the branches and merges we have predicted in the tree. That is best performed through a boot strap analysis. Where we sample with replacement the features and recompute the SPI distance matrix and tree.\n\nusing Distributed\nrmprocs(workers()) # remove any current workers\naddprocs() # startup default number (8) workers \n@everywhere using DrWatson\n@everywhere @quickactivate projectdir()\n@everywhere using SpectralInference\n@everywhere using NeighborJoining\n@everywhere using Muon\n@everywhere uniprot = readh5ad(datadir(\"exp_raw\", \"UP7047\", \"2020_02_UP7047.h5ad\"))\n@everywhere upmtx = uniprot.X[:,:]\n@everywhere upids = uniprot.obs_names\n@everywhere function runbootstrap(feature_ids, mtx=upmtx, ids=upids)\n    M = mtx[:, feature_ids] #  matrix bootstrapped on columns\n    vals, vecs = eigen(Matrix(M * M')) # more efficient than SVD as it only computes the row-wise factorization\n    # floating point impercision gives some -1e-16 vals so set them to zero\n    # and take the square root to get singular values rather than eigen values\n    S = sqrt.(max.(vals, zero(eltype(vals)))) \n    dij = spectraldistances(vecs, S; alpha=1.5, q=.75) # use same params as reference tree\n    treestring = NeighborJoining.newickstring(fastNJ(dij), ids) # get tree string\nend\n\n\nnworkers()\n\n8\n\n\n\n# generate 100 bootstraps\nnboot = 100\nNfeatures = size(upmtx, 2)\nseed!(123456)\nfeature_bootstraps = map(1:nboot) do _\n    sample(1:Nfeatures, Nfeatures, replace=true) \nend;\n\n\n# takes about 90 min\n# runs bootstrap\n@time boottreestrings = pmap(runbootstrap, feature_bootstraps);\n\n5559.022621 seconds (118.23 k allocations: 33.946 MiB)\n\n\n\nboottreestrings\n\n\n100-element Vector{String}:\n \"((((((((((((((((((((UP0000952\" ⋯ 281807 bytes ⋯ \"):4.704598e+00):0.000000e+00;\"\n \"(((((((((((((((UP000249596:2.\" ⋯ 281807 bytes ⋯ \"):6.561459e+00):0.000000e+00;\"\n \"(((((((((((((UP000266328:1.68\" ⋯ 281807 bytes ⋯ \"):1.261691e+01):0.000000e+00;\"\n \"(((((((((UP000316124:5.299888\" ⋯ 281807 bytes ⋯ \"):8.761738e-01):0.000000e+00;\"\n \"(((((((((((((((((((((((UP0000\" ⋯ 281807 bytes ⋯ \"):1.281320e+01):0.000000e+00;\"\n \"(((((((((((((((((UP000275394:\" ⋯ 281807 bytes ⋯ \"):2.550188e+01):0.000000e+00;\"\n \"((((((((((((((UP000018766:3.8\" ⋯ 281807 bytes ⋯ \"):6.590331e+00):0.000000e+00;\"\n \"((((((((((((((((((((((UP00025\" ⋯ 281807 bytes ⋯ \"):6.534613e+00):0.000000e+00;\"\n \"((((((((((((UP000191049:4.271\" ⋯ 281807 bytes ⋯ \"):5.556637e+00):0.000000e+00;\"\n \"((((((((((((((((((((((UP00031\" ⋯ 281807 bytes ⋯ \"):3.365659e+00):0.000000e+00;\"\n ⋮\n \"(((((((((((((((((((UP00007684\" ⋯ 281807 bytes ⋯ \"):4.705287e+00):0.000000e+00;\"\n \"((((((((((((UP000236317:4.054\" ⋯ 281807 bytes ⋯ \"):2.269391e+01):0.000000e+00;\"\n \"(((((((((((((((((UP000252357:\" ⋯ 281807 bytes ⋯ \"):9.154203e+00):0.000000e+00;\"\n \"(((((((((((((((((((((((((UP00\" ⋯ 281807 bytes ⋯ \"):5.750832e+00):0.000000e+00;\"\n \"(((((((((((((((((((UP00000080\" ⋯ 281807 bytes ⋯ \"):7.867615e+00):0.000000e+00;\"\n \"(((((((((((((((UP000054075:1.\" ⋯ 281807 bytes ⋯ \"):2.954590e+00):0.000000e+00;\"\n \"((((((((((((((((((UP000295443\" ⋯ 281807 bytes ⋯ \"):1.126083e+01):0.000000e+00;\"\n \"((((((((((((((((((((((UP00031\" ⋯ 281807 bytes ⋯ \"):1.115432e+00):0.000000e+00;\"\n \"(((((((((((((((((((UP00000094\" ⋯ 281807 bytes ⋯ \"):2.634929e+01):0.000000e+00;\"\n\n\n\n\nrmprocs(workers())\n\nTask (done) @0x00000002bce7b3a0\n\n\n\nopen(joinpath(UP7047_treedir, \"2020_02_UP7047-boottrees.nw\"), \"w\") do io\n    for bt in boottreestrings\n        println(io, bt)\n    end\nend\n\n\n## calculate support\nrun(pipeline(`$(gotree()) compute support tbe --silent \\\n    -i $(joinpath(UP7047_treedir, \"2020_02_UP7047-tree.nw\")) \\\n    -b $(joinpath(UP7047_treedir, \"2020_02_UP7047-boottrees.nw\")) \\\n    -o $(joinpath(UP7047_treedir, \"2020_02_UP7047-supporttree.nw\"))`,\n    stderr=joinpath(UP7047_treedir, \"booster.log\")))\n\n\nProcess(setenv(`/Users/bend/.julia/artifacts/eb6a28aa115909e9dbf2104f3bf288c51b34f308/bin/gotree compute support tbe --silent -i /Users/bend/projects/Doran_etal_2023/_research/UP7047_neighborjoined_spitree/2020_02_UP7047-tree.nw -b /Users/bend/projects/Doran_etal_2023/_research/UP7047_neighborjoined_spitree/2020_02_UP7047-boottrees.nw -o /Users/bend/projects/Doran_etal_2023/_research/UP7047_neighborjoined_spitree/2020_02_UP7047-supporttree.nw`,[\"XPC_FLAGS=0x0\", \"PATH=/Users/bend/.julia/artifacts/eb6a28aa115909e9dbf2104f3bf288c51b34f308/bin:/Users/bend/.sdkman/candidates/java/current/bin:/Users/bend/micromamba/condabin:/Users/bend/.juliaup/bin:/Users/bend/bin:/opt/homebrew/bin:/opt/homebrew/sbin:/usr/local/bin:/System/Cryptexes/App/usr/bin:/usr/bin:/bin:/usr/sbin:/sbin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/local/bin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/bin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/appleinternal/bin:/Applications/quarto/bin\", \"ELECTRON_RUN_AS_NODE=1\", \"VSCODE_CODE_CACHE_PATH=/Users/bend/Library/Application Support/Code/CachedData/0ee08df0cf4527e40edc9aa28f4b5bd38bbff2b2\", \"ZES_ENABLE_SYSMAN=1\", \"R_GZIPCMD=/usr/bin/gzip\", \"XPC_SERVICE_NAME=application.com.microsoft.VSCode.15470733.15470739\", \"HOMEBREW_PREFIX=/opt/homebrew\", \"EDITOR=vi\", \"R_LIBS_USER=/Users/bend/Library/R/arm64/4.3/library\"  …  \"R_PRINTCMD=lpr\", \"R_SHARE_DIR=/Library/Frameworks/R.framework/Resources/share\", \"CONDA_SHLVL=0\", \"SDKMAN_DIR=/Users/bend/.sdkman\", \"MAMBA_ROOT_PREFIX=/Users/bend/micromamba\", \"HOME=/Users/bend\", \"R_DOC_DIR=/Library/Frameworks/R.framework/Resources/doc\", \"R_STRIP_STATIC_LIB=strip -S\", \"OPENBLAS_MAIN_FREE=1\", \"LN_S=ln -s\"]), ProcessExited(0))\n\n\n\n\ntree = readnw(open(readline, joinpath(UP7047_treedir, \"2020_02_UP7047-supporttree.nw\")));\n\n\n# 50% majority tree\ntree_50pct = as_polytomy(n-&gt;NewickTree.support(n)&lt;.5, tree);\n\n\nopen(joinpath(UP7047_treedir, \"2020_02_UP7047-supporttree_50pct.nw\"), \"w\") do io\n    writenw(io, tree_50pct)\nend\n\n266996"
  },
  {
    "objectID": "02_figure_02main.html#plot-uniprot-tree",
    "href": "02_figure_02main.html#plot-uniprot-tree",
    "title": "Calculate Spectral Tree",
    "section": "Plot UniProt tree",
    "text": "Plot UniProt tree\n\nR\"\"\"\nupdir = file.path(getwd(), \"data\", \"exp_raw\", \"UP7047\")\nuptreedir = file.path(getwd(), \"_research\", \"UP7047_neighborjoined_spitree\")\nuniprot_spitree = read.newick(file.path(uptreedir, \"2020_02_UP7047-supporttree_50pct.nw\"), node.label='support')\nuplineage = read.csv(file.path(updir, \"UProwmeta.csv\"))\nuplineage$label = uplineage$Proteome_ID\n\nbiggerphyla  = sort(table(uplineage$Phylum), decreasing = TRUE)[sort(table(uplineage$Phylum), decreasing = TRUE) &gt; 100]\nbigPhylum = uplineage$Phylum\nbigPhylum[!(bigPhylum %in% names(biggerphyla))] = \"Misc. (# &lt; 100)\"\nuplineage$bigPhylum = bigPhylum\n\nuniprot_spitree_withdata = as.treedata(left_join(as_tibble(uniprot_spitree), uplineage, by='label'))\nutree_tbl = as_tibble(uniprot_spitree_withdata)\n\nmode_phylum = offspring(utree_tbl, utree_tbl$node, tiponly = FALSE, self_include = TRUE)\nmode_phylum = unlist(lapply(mode_phylum, function(x) modeest::mfv1(x$bigPhylum, na_rm=TRUE)))\n\nutree_tbl$mode_phylum = mode_phylum\nuniprot_spitree_withdata = as.treedata(utree_tbl)\noptions(repr.plot.width=15, repr.plot.height=15, ignore.negative.edge=TRUE)\ncolorvalues = c(\"grey\", RColorBrewer::brewer.pal(6, name=\"Accent\"), \"grey\")\nggtree(uniprot_spitree_withdata, \n    aes(color=mode_phylum), \n    layout=\"fan\", open.angle=10,\n    branch.length=\"none\",\n    )  %&gt;% rotate_tree(-240) +\n    ggtitle(\"UniProt Spectral Tree (Neighbor Joining)\") + \n    scale_color_manual(values=colorvalues, breaks=c(\"Misc. (# &lt; 100)\", names(biggerphyla), \"unknown\")) #+theme(legend.position=\"none\")\nggsave(file.path($pdir_tree, \"UniProt_SPItree_coloredbyPhylum.svg\"), \n    height=7,\n    width=7,\n)\n\"\"\"\nshow_svg(joinpath(pdir_tree, \"UniProt_SPItree_coloredbyPhylum.svg\"))\n\n┌ Warning: RCall.jl: Scale for y is already present.\n│ Adding another scale for y, which will replace the existing scale.\n│ Coordinate system already present. Adding new coordinate system, which will\n│ replace the existing one.\n└ @ RCall /Users/bend/.julia/packages/RCall/YrsKg/src/io.jl:172\n\n\n\n\n\n\nSub-clades of Spectral Tree\nLook at local surrounding of a few taxa, they are with known closely taxonomically related neighbors\n\nnthparent(n, i) = i &lt; 1 ? n : nthparent(parent(n), i-1)\n\nnthparent (generic function with 1 method)\n\n\n\nrename_treeleaves!(tree, idmapping) = begin\n    for node in getleaves(tree)\n        NewickTree.setname!(node, idmapping[name(node)])\n    end\n    tree\nend\n\nrename_treeleaves! (generic function with 1 method)\n\n\n\nuptree_leaves = getleaves(tree_50pct);\n\n\ntargetspecies = \"Bifidobacterium longum\"\ntargetid = uniprot.obs.proteomeID[uniprot.obs.Species .== targetspecies][1]\nbasenode = uptree_leaves[findfirst(n-&gt;name(n) == targetid, uptree_leaves)]\nsubtree = readnw(nwstr(nthparent(basenode, 7)))\nidmapping = Dict(k=&gt;v for (k,v) in zip(getleafnames(subtree), uniprot.obs.Species[indexin(getleafnames(subtree), uniprot.obs.proteomeID)]))\nrename_treeleaves!(subtree, idmapping)\nplot(subtree,\n    c=:mediumorchid,\n    lw=2,\n    size=(600,600),\n    rightmargin=5Plots.cm,\n)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ntargetspecies = \"Anaerostipes hadrus\"\ntargetid = uniprot.obs.proteomeID[uniprot.obs.Species .== targetspecies][1]\nbasenode = uptree_leaves[findfirst(n-&gt;name(n) == targetid, uptree_leaves)]\nsubtree = readnw(nwstr(nthparent(basenode, 5)))\nidmapping = Dict(k=&gt;v for (k,v) in zip(getleafnames(subtree), uniprot.obs.Species[indexin(getleafnames(subtree), uniprot.obs.proteomeID)]))\nrename_treeleaves!(subtree, idmapping)\nplot(subtree,\n    c=:turquoise,\n    lw=2,\n    size=(600,200),\n    rightmargin=5Plots.cm,\n)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ntargetspecies = \"Escherichia coli\"\ntargetid = uniprot.obs.proteomeID[uniprot.obs.Species .== targetspecies][1]\nbasenode = uptree_leaves[findfirst(n-&gt;name(n) == targetid, uptree_leaves)]\nsubtree = readnw(nwstr(nthparent(basenode, 8)))\nidmapping = Dict(k=&gt;v for (k,v) in zip(getleafnames(subtree), uniprot.obs.Species[indexin(getleafnames(subtree), uniprot.obs.proteomeID)]))\nrename_treeleaves!(subtree, idmapping)\nplot(subtree,\n    c=:limegreen,\n    lw=2, alpha=.5,\n    size=(600,600),\n    rightmargin=5Plots.cm,\n)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ntargetspecies = \"Bacteroides fragilis\"\ntargetid = uniprot.obs.proteomeID[uniprot.obs.Species .== targetspecies][1]\nbasenode = uptree_leaves[findfirst(n-&gt;name(n) == targetid, uptree_leaves)]\nsubtree = readnw(nwstr(nthparent(basenode, 2)))\nidmapping = Dict(k=&gt;v for (k,v) in zip(getleafnames(subtree), uniprot.obs.Species[indexin(getleafnames(subtree), uniprot.obs.proteomeID)]))\nrename_treeleaves!(subtree, idmapping)\nplot(subtree,\n    c=:lightgoldenrod3,\n    lw=2, alpha=.8,\n    size=(600,300),\n    rightmargin=5Plots.cm,\n)"
  },
  {
    "objectID": "02_figure_02main.html#mutual-information-across-tree",
    "href": "02_figure_02main.html#mutual-information-across-tree",
    "title": "Calculate Spectral Tree",
    "section": "Mutual Information across tree",
    "text": "Mutual Information across tree\nTo verify that our tree is systematically capturing known phylogeny we compare the grouping of the tree at varying distances from the ‘root’ to known NCBI taxonomic groupings and calculate the mutual information.\n\nNBOOTS = 50\ncolnames = [:Phylum, :Class, :Order, :Family, :Genus, :Species];\nUP_NCBI_taxonomy = uniprot.obs[:, colnames]\nobs_names = uniprot.obs_names.vals\nrowmask = map(eachrow(UP_NCBI_taxonomy)) do row\n    !any(==(\"\"), row)\nend;\n\n\n# took 5 hours\nmi_results = map(1:NBOOTS) do i\n    pairedMI_across_treedepth(eachcol(UP_NCBI_taxonomy), obs_names, tree_50pct; mask=rowmask, bootstrap=true, ncuts=100, treecut_distancefun=network_distance)\nend;\n\nmi_results_df = DataFrame()\nfor (i, res) in enumerate(mi_results)\n    mi_results_df = vcat(\n        mi_results_df, \n        hcat(\n            DataFrame(bootstrap=i, treedepth=last(res)),\n            DataFrame(first(res), colnames),\n            DataFrame(scaledcumsum.(first(res)), string.(colnames) .* \"_scaledcumsum\"),\n        )\n    )\nend\nCSV.write(joinpath(micurvedir, \"NCBI_raw_MI_values_.csv\"), mi_results_df);\n\n\nmi_results_df = CSV.read(joinpath(micurvedir, \"NCBI_raw_MI_values_.csv\"), DataFrame)\nmi_results_df\n\n5000×14 DataFrame4975 rows omitted\n\n\n\nRow\nbootstrap\ntreedepth\nPhylum\nClass\nOrder\nFamily\nGenus\nSpecies\nPhylum_scaledcumsum\nClass_scaledcumsum\nOrder_scaledcumsum\nFamily_scaledcumsum\nGenus_scaledcumsum\nSpecies_scaledcumsum\n\n\n\nInt64\nFloat64\nFloat64\nFloat64\nFloat64\nFloat64\nFloat64\nFloat64\nFloat64\nFloat64\nFloat64\nFloat64\nFloat64\nFloat64\n\n\n\n\n1\n1\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n\n\n2\n1\n0.282828\n0.00185327\n0.00140159\n0.000664909\n0.000378137\n0.000164175\n8.21661e-8\n0.00051277\n0.000555696\n0.000517571\n0.000403562\n0.000403996\n4.96241e-5\n\n\n3\n1\n0.565657\n0.00183853\n0.00139375\n0.000663027\n0.00038003\n0.000163842\n4.97417e-8\n0.00102146\n0.00110828\n0.00103368\n0.000809144\n0.000807171\n7.96655e-5\n\n\n4\n1\n0.848485\n0.00185611\n0.00140952\n0.000645396\n0.000391592\n0.000161681\n1.60671e-7\n0.00153502\n0.00166712\n0.00153606\n0.00122707\n0.00120503\n0.000176703\n\n\n5\n1\n1.13131\n0.0945947\n0.04664\n0.0161751\n0.00785406\n0.00260774\n4.82814e-6\n0.0277079\n0.0201587\n0.0141269\n0.00960922\n0.00762206\n0.00309265\n\n\n6\n1\n1.41414\n0.0944801\n0.0465577\n0.0161665\n0.00785363\n0.00260356\n4.50557e-6\n0.0538491\n0.0386177\n0.026711\n0.0179909\n0.0140288\n0.00581379\n\n\n7\n1\n1.69697\n0.0944517\n0.0465807\n0.0161591\n0.00785219\n0.00261483\n3.48844e-6\n0.0799824\n0.0570858\n0.0392894\n0.0263711\n0.0204633\n0.00792062\n\n\n8\n1\n1.9798\n0.0945355\n0.0465879\n0.0161638\n0.00785501\n0.0026114\n4.11217e-6\n0.106139\n0.0755567\n0.0518714\n0.0347542\n0.0268893\n0.0104042\n\n\n9\n1\n2.26263\n0.24901\n0.127841\n0.0399273\n0.0182349\n0.00585245\n8.49059e-6\n0.175036\n0.126242\n0.0829511\n0.0542152\n0.0412907\n0.015532\n\n\n10\n1\n2.54545\n0.248812\n0.127803\n0.0397957\n0.0183007\n0.00585734\n7.72044e-6\n0.243878\n0.176913\n0.113928\n0.0737464\n0.0557042\n0.0201948\n\n\n11\n1\n2.82828\n0.248913\n0.127735\n0.039991\n0.018253\n0.00580946\n8.89131e-6\n0.312749\n0.227557\n0.145058\n0.0932268\n0.0699999\n0.0255647\n\n\n12\n1\n3.11111\n0.226629\n0.122779\n0.0415016\n0.0217262\n0.00709295\n1.23391e-5\n0.375454\n0.276236\n0.177363\n0.116414\n0.0874539\n0.0330169\n\n\n13\n1\n3.39394\n0.226926\n0.122969\n0.0414903\n0.0217421\n0.00711496\n1.06419e-5\n0.43824\n0.32499\n0.209659\n0.139618\n0.104962\n0.039444\n\n\n⋮\n⋮\n⋮\n⋮\n⋮\n⋮\n⋮\n⋮\n⋮\n⋮\n⋮\n⋮\n⋮\n⋮\n⋮\n\n\n4989\n50\n24.8889\n3.1453e-6\n5.74763e-6\n9.59028e-6\n9.27278e-6\n1.30322e-5\n1.78353e-11\n0.999998\n0.999994\n0.999982\n0.999973\n0.999912\n1.0\n\n\n4990\n50\n25.1717\n1.5374e-6\n2.69882e-6\n3.80017e-6\n4.07291e-6\n8.38488e-6\n8.03694e-12\n0.999998\n0.999995\n0.999985\n0.999978\n0.999933\n1.0\n\n\n4991\n50\n25.4545\n1.83012e-6\n1.64319e-6\n3.075e-6\n3.84678e-6\n5.49638e-6\n5.01246e-12\n0.999999\n0.999996\n0.999988\n0.999982\n0.999947\n1.0\n\n\n4992\n50\n25.7374\n1.24433e-6\n2.23104e-6\n3.07658e-6\n4.52742e-6\n4.63205e-6\n6.25284e-12\n0.999999\n0.999997\n0.99999\n0.999987\n0.999958\n1.0\n\n\n4993\n50\n26.0202\n4.39006e-7\n1.29025e-6\n2.35203e-6\n1.58389e-6\n3.47111e-6\n4.07794e-12\n0.999999\n0.999997\n0.999992\n0.999988\n0.999967\n1.0\n\n\n4994\n50\n26.303\n9.51392e-7\n1.52466e-6\n2.35143e-6\n2.71494e-6\n4.33923e-6\n6.49921e-12\n0.999999\n0.999998\n0.999994\n0.999991\n0.999977\n1.0\n\n\n4995\n50\n26.5859\n8.04667e-7\n1.29055e-6\n2.71392e-6\n3.62337e-6\n2.60711e-6\n1.50657e-12\n0.999999\n0.999998\n0.999996\n0.999995\n0.999984\n1.0\n\n\n4996\n50\n26.8687\n8.78081e-7\n1.40809e-6\n2.35273e-6\n2.26313e-6\n2.31278e-6\n2.29961e-12\n1.0\n0.999999\n0.999998\n0.999998\n0.999989\n1.0\n\n\n4997\n50\n27.1515\n5.1237e-7\n5.86399e-7\n7.23816e-7\n4.52456e-7\n1.44813e-6\n1.68781e-12\n1.0\n0.999999\n0.999998\n0.999998\n0.999993\n1.0\n\n\n4998\n50\n27.4343\n2.19636e-7\n9.38617e-7\n1.44694e-6\n1.13083e-6\n1.44651e-6\n2.1749e-12\n1.0\n1.0\n0.999999\n0.999999\n0.999996\n1.0\n\n\n4999\n50\n27.7172\n2.92639e-7\n1.17321e-6\n7.23742e-7\n6.79435e-7\n1.4471e-6\n4.21953e-12\n1.0\n1.0\n1.0\n1.0\n1.0\n1.0\n\n\n5000\n50\n28.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n1.0\n1.0\n1.0\n1.0\n1.0\n1.0\n\n\n\n\n\n\n\npltdf = mi_results_df |&gt;\n    df -&gt; stack(df, 9:14, [:bootstrap, :treedepth]) |&gt; \n    df -&gt; transform(df, :variable =&gt; ByRow(x-&gt;replace(x, \"_scaledcumsum\"=&gt;\"\")) =&gt; identity) |&gt;\n    df -&gt; groupby(df, [:variable, :treedepth]) |&gt;\n    df -&gt; combine(df,\n        :value =&gt; mean =&gt; :MI_mean,\n        :value =&gt; std =&gt; :MI_std,\n    ) |&gt; \n    df -&gt; sort(df, [])\ntaxonomylevels = permutedims(string.(colnames))\ntaxarankcolors = [:red :pink :orange :lightblue :green :aqua];\nplot(title=\"UniProt spectral tree (NCBI)\", ylabel=\"MI\", xlabel=\"Tree depth\",\n    legend=:outerright,\n    size=(700,250),\n    margin=5Plots.mm,  \n)\nfor (tlab, tcol) in collect(zip(taxonomylevels, taxarankcolors))\n    df = filter(:variable =&gt; ==(tlab), pltdf)\n    @df df plot!(:treedepth, :MI_mean, ribbon=2 .* :MI_std, label=tlab, c=tcol, lw=1)\nend\nplot!()\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nwe see that as we move from the root to the leaves we get spiking information related Phylum, Class, Order, Family, Genus, and Species in discrete layers and in that order."
  },
  {
    "objectID": "00_setup_data.html",
    "href": "00_setup_data.html",
    "title": "Setting up data",
    "section": "",
    "text": "# setup for local file handling\nusing DrWatson\n@quickactivate projectdir()\n\n# load extra libraries\nusing CSV, DataFrames, Muon, MAT\nusing StatsBase\ninclude(srcdir(\"helpers.jl\"))\n\nshow_svg (generic function with 1 method)\nbbdir = datadir(\"exp_raw\", \"BB669\")\nupdir = datadir(\"exp_raw\", \"UP7047\")\n\n\"/Users/bend/projects/Doran_etal_2023/data/exp_raw/UP7047\""
  },
  {
    "objectID": "00_setup_data.html#read-in-the-uniprot-data-and-associated-metadata.",
    "href": "00_setup_data.html#read-in-the-uniprot-data-and-associated-metadata.",
    "title": "Setting up data",
    "section": "Read in the UniProt data and associated metadata.",
    "text": "Read in the UniProt data and associated metadata.\nThe main data is a count matrix of 7047 bacterial strains described by 10,177 Orthologous Gene Groups (OGGs). Each element of the matrix shows the number (count) of sequences in the strain that belong to that OGG. Along with this are associated metadata for each strain and each orthologous gene group.\n\nuniprot = readh5ad(joinpath(updir, \"2020_02_UP7047.h5ad\"))\n\nAnnData object 7047 ✕ 10177\n\n\n\n# count matrix\nuniprot.X[1:5, 1:5]\n\n5×5 adjoint(::Matrix{Float64}) with eltype Float64:\n 1.0  0.0  1.0  2.0  1.0\n 1.0  0.0  1.0  2.0  0.0\n 1.0  0.0  1.0  3.0  1.0\n 0.0  0.0  0.0  0.0  0.0\n 1.0  0.0  1.0  2.0  0.0\n\n\n\nfirst(uniprot.obs, 5)\n\n5×18 DataFrame\n\n\n\nRow\nproteomeID\nTaxID\nProteome_ID\nTax_ID\nOSCODE\nSUPERREGNUM\nx__1_\nx__2_\nx__3_\nSpeciesName\nKingdom\nPhylum\nClass\nOrder\nFamily\nGenus\nSpecies\norder\n\n\n\nString\nInt64\nString\nInt64\nString\nString\nInt64\nInt64\nInt64\nString\nString\nString\nString\nString\nString\nString\nString\nInt64\n\n\n\n\n1\nUP000283387\n1261403\nUP000283387\n1261403\n\nbacteria\n4641\n0\n4643\nMangrovibacterium diazotrophicum\nBacteria\nBacteroidetes\nBacteroidia\nMarinilabiliales\nProlixibacteraceae\nMangrovibacterium\nMangrovibacterium diazotrophicum\n3264\n\n\n2\nUP000181985\n1897729\nUP000181985\n1897729\n\nbacteria\n3147\n0\n3150\nHalomonas aestuarii\nBacteria\nProteobacteria\nGammaproteobacteria\nOceanospirillales\nHalomonadaceae\nHalomonas\nHalomonas aestuarii\n2026\n\n\n3\nUP000220675\n1962403\nUP000220675\n1962403\n\nbacteria\n4593\n0\n4595\nNovosphingobium sp. PC22D\nBacteria\nProteobacteria\nAlphaproteobacteria\nSphingomonadales\nSphingomonadaceae\nNovosphingobium\nNovosphingobium sp. PC22D\n519\n\n\n4\nUP000013137\n1188234\nUP000013137\n1188234\n\nbacteria\n601\n0\n601\nMycoplasma alkalescens 14918\nBacteria\nTenericutes\nMollicutes\nMycoplasmatales\nMycoplasmataceae\nMycoplasma\nMycoplasma alkalescens\n4272\n\n\n5\nUP000067399\n1303921\nUP000067399\n1303921\n\nbacteria\n1467\n0\n1471\nendosymbiont of Bathymodiolus septemdierum str. Myojin knoll\nBacteria\nProteobacteria\nGammaproteobacteria\n\n\n\nBathymodiolus septemdierum thioautotrophic gill symbiont\n1170\n\n\n\n\n\n\n\nfirst(uniprot.var, 5)\n\n5×6 DataFrame\n\n\n\nRow\nog\nlevel\nnm\ndescription\nCOG_categories\nOG_ID\n\n\n\nString\nInt64\nInt64\nString\nString\nString\n\n\n\n\n1\nCOG0001\n2\n4694\nglutamate-1-semialdehyde 2,1-aminomutase activity\nH\nCOG0001@2\n\n\n2\nCOG0003\n2\n2423\nPfam Anion-transporting ATPase\nP\nCOG0003@2\n\n\n3\nCOG0002\n2\n3957\nN-acetyl-gamma-glutamyl-phosphate reductase activity\nE\nCOG0002@2\n\n\n4\nCOG0004\n2\n5256\nammonium transporteR\nP\nCOG0004@2\n\n\n5\nCOG0005\n2\n3783\npurine-nucleoside phosphorylase activity\nF\nCOG0005@2"
  },
  {
    "objectID": "00_setup_data.html#read-in-biobank-data-make-unified-dataset",
    "href": "00_setup_data.html#read-in-biobank-data-make-unified-dataset",
    "title": "Setting up data",
    "section": "Read in Biobank data & make unified dataset",
    "text": "Read in Biobank data & make unified dataset\nThe BioBank (aka: Commensal Strain Bank, aka: CSB) is the strain bank we collected. It comprises 669 strains that have at least 1% distinct sequence identity to any other strain in the BioBank (i.e. we removed clonal duplicates).\nAll these strains were whole genome sequenced. And from that sequencing we annotated each strain by orthologous gene groups (OGG). This annotation was done for each strain by counting the number of coding regions that matched to each orthologous gene groups in the eggNOG database (v5.0) database and filtering out gene-groups that had no matches. This created the matrix in BB669_oggs.mat where strains correspond to each row and OGGs correspond to each column and each entry holds the number of protein sequences that matched to that OGG.\nWe also measured the metabolic phenotype of these strains across a number of short-chain fatty acids and other small molecules. The file B669_metabolites_foldchange.csv contains the measurements we use in this paper, where each row contains a strain and the columns contain metabolite compounds the strains either digest or produce. The degree of digestion or production of each metabolite is compared as the ratio between the relative concentration of the compound in media cultured with the strain versus blank media without any strain. We take the log2 transform of this ratio and report the log2-fold-change (log2FC) as our measure of metabolic activity.\n\nBB669_ogg_data = matread(joinpath(bbdir, \"BB669_oggs.mat\"))\nmetadata = CSV.read(joinpath(bbdir, \"BB669_rowmeta.tsv\"), DataFrame; delim=\"\\t\", normalizenames=true)\nmetabolite_df = CSV.read(joinpath(bbdir, \"BB669_metabolites_foldchange.csv\"), DataFrame)\nmetabolite_labels = replace.(names(metabolite_df), \"_rel\"=&gt;\"\")[3:end]\nrename!(metabolite_df, names(metabolite_df) .=&gt; CSV.normalizename.(names(metabolite_df)));\n\n\n#= \n    use function in helpers.jl to match measured orthologs in our strain bank \n    to those measured in UniProt bacteria.\n=#\nBBoggs_UPorder = match_column_order(\n    BB669_ogg_data[\"data\"], \n    BB669_ogg_data[\"var_names\"], \n    uniprot.var_names\n);\n\n\n# this finds all species with at least 20 strain replicates in the dataset\n# this subset of species are those we statistically test for strain level differences later on\nkeptspecies = string.(keys(sort(filter(x-&gt; last(x) &gt;= 20, countmap(metadata.Species)), byvalue=true, rev=true)))\nfilter!(!=(\"unclassified\"), keptspecies)\nkeptspecies_mask = in.(metadata.Species, Ref(keptspecies));\nkeptspecies # species with at least 20 replicates in the dataset\n\n11-element Vector{String}:\n \"Phocaeicola vulgatus\"\n \"[Ruminococcus] gnavus\"\n \"Bacteroides thetaiotaomicron\"\n \"Anaerostipes hadrus\"\n \"Bacteroides uniformis\"\n \"Blautia luti\"\n \"Bifidobacterium breve\"\n \"Coprococcus comes\"\n \"Dorea formicigenerans\"\n \"Blautia wexlerae\"\n \"[Eubacterium] rectale\"\n\n\nCreate unified file for future analysis, this will be easier to load in later notebooks\n\nbiobank_ogg = AnnData(\n    X=BB669_ogg_data[\"data\"],\n    obs_names=string.(BB669_ogg_data[\"obs_names\"]),\n    var_names=string.(BB669_ogg_data[\"var_names\"])\n)\nbiobank_ogg_UP = AnnData(\n    X=BBoggs_UPorder,\n    obs_names=string.(BB669_ogg_data[\"obs_names\"]),\n    var_names=uniprot.var_names\n)\nbiobank_met = AnnData(\n    X=log2.(Matrix(coalesce.(metabolite_df[:, 3:end], NaN))),\n    obs_names=metabolite_df[:, :ID],\n    var_names=names(metabolite_df)[3:end],\n    var=DataFrame(ID=names(metabolite_df)[3:end], label=metabolite_labels)\n)\nbiobank_met.layers[\"raw\"] = Matrix(coalesce.(metabolite_df[:, 3:end], NaN))\nbiobank = MuData(mod=Dict(\n    \"oggs\" =&gt; biobank_ogg,\n    \"UPorder_oggs\" =&gt; biobank_ogg_UP,\n    \"metabolites_foldchange\" =&gt; biobank_met,\n))\nbiobank.obs = insertcols(String.(metadata), :kept_species=&gt;keptspecies_mask)\nbiobank\n\n┌ Warning: Cannot join columns with the same name because var_names are intersecting.\n└ @ Muon /Users/bend/.julia/packages/Muon/eLqpV/src/mudata.jl:351\n\n\nMuData object 669 ✕ 21475\n└ metabolites_foldchange\n  AnnData object 669 ✕ 50\n└ oggs\n  AnnData object 669 ✕ 11248\n└ UPorder_oggs\n  AnnData object 669 ✕ 10177\n\n\n\nwriteh5mu(joinpath(bbdir, \"BB669.h5mu\"), biobank)"
  },
  {
    "objectID": "06_figure_06.html",
    "href": "06_figure_06.html",
    "title": "Predict Consortia Phenotype",
    "section": "",
    "text": "julia setup\nusing DrWatson\n@quickactivate projectdir()\n\nusing SpectralInference\nusing NewickTree\nusing StatsBase\nusing Muon, CSV, DataFrames\nusing StatsPlots, GLM\ntheme(:default, grid=false, label=false, tickdir=:out)\n\nddir = datadir(\"exp_raw\", \"BBconsortia\");\npredsdir = projectdir(\"_research\", \"metabolite_SLE_Lasso_model_outofbag\");"
  },
  {
    "objectID": "06_figure_06.html#compare-3-member-consortia-measurements-to-added-strain-predictions",
    "href": "06_figure_06.html#compare-3-member-consortia-measurements-to-added-strain-predictions",
    "title": "Predict Consortia Phenotype",
    "section": "Compare 3 member consortia measurements to added strain predictions",
    "text": "Compare 3 member consortia measurements to added strain predictions\n\nbiobank = readh5mu(datadir(\"exp_raw\", \"BB669\", \"BB669.h5mu\"));\nfull_train_mask = biobank.obs.kept_species .== 1\nbbobs_trn = biobank.obs[full_train_mask, :];\n\n┌ Warning: Cannot join columns with the same name because var_names are intersecting.\n└ @ Muon /Users/bend/.julia/packages/Muon/eLqpV/src/mudata.jl:351\n\n\n\nunique_condf = CSV.read(joinpath(ddir, \"needisolate_oggs.csv\"), DataFrame);\nconsortiadf = CSV.read(joinpath(ddir, \"full_PFBBR_consortia.csv\"), DataFrame)\nfconsortiadf = filter(:compound =&gt; in([\"butyrate\", \"acetate\", \"succinate\", \"propionate\"]), consortiadf) |&gt; \n    df-&gt;select(df, [:con_id, :con_list, :msk_id, :input_condition, :media, :ph_adjust, :compound, :log2FC]);\n\noofpreds = CSV.read(joinpath(predsdir, \"oof_predictions_stacked_SPItreeLASSO_ancestralencoding_lambda=0.001.csv\"), DataFrame);\noobpreds = CSV.read(joinpath(predsdir, \"oob_predictions_stacked_SPItreeLASSO_ancestralencoding_lambda=0.001.csv\"), DataFrame);\nadded_isolate_mskids = String.(unique(fconsortiadf.msk_id))\n@show added_isolate_mskids;\n\nadded_isolate_mskids = [\"DFI.3.84\", \"DFI.6.78\", \"DFI.4.30\", \"DFI.5.64\", \"DFI.1.19\", \"DFI.5.28\", \"MSK.6.3\", \"DFI.5.40\", \"DFI.5.67\", \"MSK.11.20\", \"SL.2.19\", \"MSK.14.17\", \"DFI.5.75\", \"MSK.16.22\", \"MSK.17.84\", \"DFI.5.16\", \"DFI.7.37\"]\n\n\n\nunique_condf.species_in_strvar .= sum(unique_condf.name .== permutedims(unique(bbobs_trn.Species)), dims=2);\nunique_condf.genus_in_strvar .= sum(first.(split.(unique_condf.name, \" \")) .== permutedims(first.(split.(unique(bbobs_trn.Species), \" \"))), dims=2);\nselect(unique_condf, [:msk_id, :name, :genus_in_strvar])\n\n19×3 DataFrame\n\n\n\nRow\nmsk_id\nname\ngenus_in_strvar\n\n\n\nString15\nString31\nInt64\n\n\n\n\n1\nDFI.1.234\n[Clostridium] scindens\n0\n\n\n2\nDFI.2.45\nBifidobacterium longum\n1\n\n\n3\nDFI.3.84\nCoprococcus comes\n1\n\n\n4\nDFI.6.78\nAnaerobutyricum soehngenii\n0\n\n\n5\nDFI.4.30\nAnaerostipes hadrus\n1\n\n\n6\nDFI.1.19\nAnaerostipes caccae\n1\n\n\n7\nDFI.5.28\n[Eubacterium] rectale\n1\n\n\n8\nMSK.6.3\nRoseburia faecis\n0\n\n\n9\nDFI.5.40\nFaecalibacterium prausnitzii\n0\n\n\n10\nMSK.11.20\nAnaerostipes hadrus\n1\n\n\n11\nDFI.5.64\n[Clostridium] symbiosum\n0\n\n\n12\nMSK.14.17\nAnaerostipes hadrus\n1\n\n\n13\nDFI.5.75\nnothing\n0\n\n\n14\nMSK.16.22\n[Eubacterium] rectale\n1\n\n\n15\nMSK.17.84\nRoseburia intestinalis\n0\n\n\n16\nDFI.5.67\n[Clostridium] innocuum\n0\n\n\n17\nSL.2.19\nFlavonifractor plautii\n0\n\n\n18\nDFI.5.16\nCoprococcus eutactus\n1\n\n\n19\nDFI.7.37\nnothing\n0\n\n\n\n\n\n\n\n# out-of-fold predictions for added isolates (average and std over resamples)\noof_wide = subset(oofpreds,\n        # :msk_id =&gt; x-&gt;.∈(x, Ref(added_isolate_mskids)),\n        :msk_id =&gt; ByRow(∈(added_isolate_mskids)),\n        :metabolite_name =&gt; ByRow(∈([\"Acetate\", \"Butyrate\", \"Propionate\", \"Succinate\"])),\n    ) |&gt;\ndf -&gt; sort(df, [:msk_id, :metabolite_name]) |&gt;\ndf -&gt; unstack(df, [:msk_id, :resample], :metabolite_name, :preds) |&gt;\ndf -&gt; groupby(df, [:msk_id]) |&gt;\ndf -&gt; combine(df, \n    3:6 .=&gt; mean,\n    3:6 .=&gt; std,\n);\n\n\n# out-of-bag predictions (average and std over resamples)\noob_wide = subset(oobpreds,\n        :msk_id =&gt; ByRow(∈(added_isolate_mskids)),\n        :metabolite_name =&gt; ByRow(∈([\"Acetate\", \"Butyrate\", \"Propionate\", \"Succinate\"])),\n    ) |&gt;\ndf -&gt; sort(df, [:msk_id, :metabolite_name, :fold, :resample]) |&gt;\ndf -&gt; unstack(df, [:msk_id, :resample], :metabolite_name, :preds, combine=first) |&gt;\ndf -&gt; groupby(df, [:msk_id]) |&gt;\ndf -&gt; combine(df, \n    3:6 .=&gt; mean,\n    3:6 .=&gt; std,\n);\n\n\naddedisolate_preds = vcat(oof_wide, oob_wide)\n\n17×9 DataFrame\n\n\n\nRow\nmsk_id\nAcetate_mean\nButyrate_mean\nPropionate_mean\nSuccinate_mean\nAcetate_std\nButyrate_std\nPropionate_std\nSuccinate_std\n\n\n\nString15\nFloat64\nFloat64\nFloat64\nFloat64\nFloat64\nFloat64\nFloat64\nFloat64\n\n\n\n\n1\nDFI.3.84\n1.54362\n5.67077\n-0.233056\n-0.767597\n0.0227796\n0.023164\n0.0033514\n0.0102699\n\n\n2\nDFI.4.30\n-1.13629\n5.06859\n1.97317\n-0.951255\n0.634897\n2.18694\n1.00431\n0.356204\n\n\n3\nMSK.11.20\n-0.419323\n6.70012\n3.10775\n-0.594025\n0.22129\n0.0468537\n0.915711\n0.0653226\n\n\n4\nMSK.14.17\n-0.936271\n6.601\n2.52386\n-1.02732\n0.559588\n0.240671\n1.00271\n0.293703\n\n\n5\nMSK.16.22\n0.16895\n5.73695\n0.119979\n0.340988\n0.414207\n0.108866\n0.123442\n0.86982\n\n\n6\nDFI.1.19\n-0.34663\n2.77478\n1.22566\n-0.715933\n0.280964\n3.48805\n1.1707\n0.0861858\n\n\n7\nMSK.6.3\n0.504984\n5.73143\n0.0837137\n0.70721\n0.225006\n0.0156853\n0.0703886\n0.119016\n\n\n8\nDFI.5.64\n2.67552\n-0.212986\n-0.438936\n0.632796\n0.386428\n0.045966\n0.194182\n1.23303\n\n\n9\nMSK.17.84\n0.53399\n5.73143\n0.0832299\n0.698754\n0.169405\n0.0156853\n0.0704271\n0.210429\n\n\n10\nDFI.6.78\n4.25115\n-0.209521\n-0.0410055\n3.29575\n0.30106\n0.0408433\n0.0412459\n0.0270707\n\n\n11\nDFI.5.28\n0.501317\n5.74302\n0.0635885\n0.684642\n0.226837\n0.0300517\n0.0744186\n0.108419\n\n\n12\nDFI.5.40\n0.482896\n5.8632\n0.00316721\n0.552565\n1.00414\n0.0255139\n0.345074\n1.02279\n\n\n13\nDFI.5.75\n2.96728\n-0.205279\n0.643372\n0.609662\n0.0136715\n0.0103657\n0.214842\n0.0718333\n\n\n14\nDFI.5.67\n-0.367898\n2.80807\n0.542015\n-0.700344\n0.268153\n3.53339\n0.235725\n0.0973767\n\n\n15\nSL.2.19\n2.85734\n-0.256934\n0.905776\n1.11187\n0.261197\n0.0758152\n1.33168\n0.869069\n\n\n16\nDFI.5.16\n1.93939\n0.997991\n-0.37842\n-0.25375\n1.06367\n2.64756\n0.325293\n0.181348\n\n\n17\nDFI.7.37\n0.529184\n5.73143\n0.0837137\n0.70721\n0.220317\n0.0156853\n0.0703886\n0.119016\n\n\n\n\n\n\n\n# metabolte concentrations of 3 member consortia (averaged over media conditions)\nmerged_con_measures = fconsortiadf |&gt; \n    df-&gt;groupby(df, [:con_id, :con_list, :msk_id, :compound]) |&gt;\n    df-&gt;combine(df, \n        :log2FC =&gt; mean,\n        :log2FC =&gt; std,\n    ) #|&gt;\n    # df-&gt;subset(df, :msk_id =&gt; x-&gt;.!(x .∈ Ref(strvar_mskids)))\nmerged_con_measures_wide = leftjoin(\n    unstack(merged_con_measures, 1:3, :compound, :log2FC_mean),\n    unstack(merged_con_measures, 1, :compound, :log2FC_std), on=:con_id, makeunique=true)\nnewcolnames = [\n    :acetate =&gt; :acetate_mean,\n    :butyrate =&gt; :butyrate_mean,\n    :propionate =&gt; :propionate_mean,\n    :succinate =&gt; :succinate_mean,\n    :acetate_1 =&gt; :acetate_std,\n    :butyrate_1 =&gt; :butyrate_std,\n    :propionate_1 =&gt; :propionate_std,\n    :succinate_1 =&gt; :succinate_std,\n]\nrename!(merged_con_measures_wide, newcolnames)\n\n17×11 DataFrame\n\n\n\nRow\ncon_id\ncon_list\nmsk_id\nbutyrate_mean\nacetate_mean\npropionate_mean\nsuccinate_mean\nbutyrate_std\nacetate_std\npropionate_std\nsuccinate_std\n\n\n\nString7\nString31\nString15\nFloat64?\nFloat64?\nFloat64?\nFloat64?\nFloat64?\nFloat64?\nFloat64?\nFloat64?\n\n\n\n\n1\nCON.084\nDFI.1.234,DFI.2.45,DFI.3.84\nDFI.3.84\n4.55624\n2.79497\n-0.29222\n0.0259156\n0.876702\n0.217815\n0.433933\n0.0582666\n\n\n2\nCON.085\nDFI.1.234,DFI.2.45,DFI.6.78\nDFI.6.78\n5.62454\n2.3551\n0.278347\n0.123691\n0.443752\n0.395852\n0.0803643\n0.0760432\n\n\n3\nCON.086\nDFI.1.234,DFI.2.45,DFI.4.30\nDFI.4.30\n6.14297\n0.931719\n2.36774\n-0.0618057\n0.365015\n0.740421\n0.444337\n0.0807273\n\n\n4\nCON.092\nDFI.1.234,DFI.2.45,DFI.5.64\nDFI.5.64\n6.88241\n3.44515\n0.467723\n0.112728\n0.332509\n0.369505\n0.22223\n0.26109\n\n\n5\nCON.087\nDFI.1.19,DFI.1.234,DFI.2.45\nDFI.1.19\n6.72225\n1.59332\n0.940054\n-0.0210095\n0.0682819\n0.222954\n0.0622343\n0.080052\n\n\n6\nCON.088\nDFI.1.234,DFI.2.45,DFI.5.28\nDFI.5.28\n3.23979\n2.1665\n-0.00734626\n-0.0386782\n1.00149\n0.140506\n0.484648\n0.028282\n\n\n7\nCON.089\nDFI.1.234,DFI.2.45,MSK.6.3\nMSK.6.3\n4.79528\n1.96362\n-0.0682856\n0.00460516\n0.229041\n0.0417746\n0.808534\n0.0147493\n\n\n8\nCON.090\nDFI.1.234,DFI.2.45,DFI.5.40\nDFI.5.40\n3.20835\n2.72607\n-0.305818\n0.0441199\n1.85737\n0.552205\n0.423246\n0.10503\n\n\n9\nCON.121\nDFI.1.234,DFI.2.45,DFI.5.67\nDFI.5.67\n6.12427\n1.41821\n-0.0963225\n0.0531609\n0.337785\n0.444643\n0.0413068\n0.371393\n\n\n10\nCON.091\nDFI.1.234,DFI.2.45,MSK.11.20\nMSK.11.20\n5.22634\n2.54555\n-0.0362934\n-0.0199167\n0.00795979\n0.0779558\n0.0956845\n0.0100014\n\n\n11\nCON.122\nDFI.1.234,DFI.2.45,SL.2.19\nSL.2.19\n5.54147\n3.25928\n1.99829\n-1.31033\n0.0701764\n0.0151886\n0.0444871\n0.0581843\n\n\n12\nCON.093\nDFI.1.234,DFI.2.45,MSK.14.17\nMSK.14.17\n6.17564\n1.61819\n1.85647\n-0.0666574\n0.205937\n0.955654\n0.724804\n0.0154961\n\n\n13\nCON.094\nDFI.1.234,DFI.2.45,DFI.5.75\nDFI.5.75\n5.49415\n2.3864\n2.0781\n-1.02133\n0.258109\n0.366688\n0.145969\n0.505593\n\n\n14\nCON.095\nDFI.1.234,DFI.2.45,MSK.16.22\nMSK.16.22\n3.37092\n1.84588\n-0.0118386\n0.00430352\n1.7359\n0.266976\n0.0611002\n0.044254\n\n\n15\nCON.096\nDFI.1.234,DFI.2.45,MSK.17.84\nMSK.17.84\n4.23218\n2.1106\n0.0347161\n0.0044376\n0.157208\n0.0963807\n0.0600381\n0.0344176\n\n\n16\nCON.123\nDFI.1.234,DFI.2.45,DFI.5.16\nDFI.5.16\n1.46187\n2.82924\n-0.0307003\n0.167817\n0.0720396\n0.127204\n0.0434167\n0.182918\n\n\n17\nCON.124\nDFI.1.234,DFI.2.45,DFI.7.37\nDFI.7.37\n0.26143\n2.5722\n-0.0627654\n-0.0260267\n0.0481155\n0.069493\n0.0887637\n0.04763\n\n\n\n\n\n\n\n# merge everthing together based on added isolate\npltdf = leftjoin(merged_con_measures_wide, addedisolate_preds, on=:msk_id)\npltdf = leftjoin(pltdf, unique_condf, on=:msk_id);\n\n\nCSV.write(joinpath(ddir, \"merged_consortia-and-isolate_plotdata.csv\"), pltdf)\n\n\"/Users/bend/projects/Doran_etal_2023/data/exp_raw/BBconsortia/merged_consortia-and-isolate_plotdata.csv\"\n\n\n\nlinear models\nHere we make linear models for the consortia measurements versus predictions, factored by if the consortia’s added strain has a member of the same genus in the training set or not.\nonly the model of consortia with a member of the same genus in the training set has a significant slope\n\nmodel_notinstrvar = lm(@formula(acetate_mean ~ Acetate_mean), filter(:genus_in_strvar =&gt; ==(0), pltdf))\n\nStatsModels.TableRegressionModel{LinearModel{GLM.LmResp{Vector{Float64}}, GLM.DensePredChol{Float64, CholeskyPivoted{Float64, Matrix{Float64}, Vector{Int64}}}}, Matrix{Float64}}\n\nacetate_mean ~ 1 + Acetate_mean\n\nCoefficients:\n─────────────────────────────────────────────────────────────────────────\n                 Coef.  Std. Error     t  Pr(&gt;|t|)   Lower 95%  Upper 95%\n─────────────────────────────────────────────────────────────────────────\n(Intercept)   2.13519     0.278308  7.67    0.0001   1.4771       2.79328\nAcetate_mean  0.209217    0.126753  1.65    0.1428  -0.0905065    0.50894\n─────────────────────────────────────────────────────────────────────────\n\n\n\nmodel_instrvar = lm(@formula(acetate_mean ~ Acetate_mean), filter(:genus_in_strvar =&gt; ==(1), pltdf))\n\nStatsModels.TableRegressionModel{LinearModel{GLM.LmResp{Vector{Float64}}, GLM.DensePredChol{Float64, CholeskyPivoted{Float64, Matrix{Float64}, Vector{Int64}}}}, Matrix{Float64}}\n\nacetate_mean ~ 1 + Acetate_mean\n\nCoefficients:\n─────────────────────────────────────────────────────────────────────────\n                 Coef.  Std. Error      t  Pr(&gt;|t|)  Lower 95%  Upper 95%\n─────────────────────────────────────────────────────────────────────────\n(Intercept)   1.95874      0.14264  13.73    &lt;1e-05   1.60971    2.30777\nAcetate_mean  0.498511     0.13533   3.68    0.0103   0.167371   0.829651\n─────────────────────────────────────────────────────────────────────────\n\n\n\np1 = plot(title=\"Acetate (genus in strvar)\", \n    xlabel=\"predicted acetate concentration\",\n    ylabel=\"consortia acetate concentration (log2FC)\",\n    alpha=.5, \n    ratio=1,\n)\n@df filter(:genus_in_strvar =&gt; ==(1), pltdf) scatter!(\n    :Acetate_mean, :acetate_mean, \n    xerror=:Acetate_std, yerror=:acetate_std,\n)\nplot!(x-&gt;predict(model_instrvar, [(;Acetate_mean=x)])[1],-1.8, 3.9,\n    c=:grey, linestyle=:dash,\n    label=\"adjR²=$(round(adjr2(model_instrvar), digits=1))\",\n)  \n\np2 = plot(title=\"Acetate (genus not in strvar)\", \n    xlabel=\"predicted acetate concentration\",\n    ylabel=\"consortia acetate concentration (log2FC)\",\n    alpha=.5, \n    ratio=1,\n)\n@df filter(:genus_in_strvar =&gt; ==(0), pltdf) scatter!(\n    :Acetate_mean, :acetate_mean, \n    xerror=:Acetate_std, yerror=:acetate_std,\n)\n@df filter(:genus_in_strvar =&gt; ==(0), pltdf) plot!(\n    x-&gt;mean(:acetate_mean), -1.8, 3.9,\n    c=:grey, linestyle=:dash,\n    label=\"adjR²=0.0\",\n)\n\n\nplot(p1, p2, \n    layout=grid(1,2), \n    legend=:bottomleft, size=(800,400),\n    margin=5Plots.mm,\n    xlims=(-2, 4),\n    link=:y\n    )"
  },
  {
    "objectID": "06_figure_06.html#consortia-baseline",
    "href": "06_figure_06.html#consortia-baseline",
    "title": "Predict Consortia Phenotype",
    "section": "Consortia Baseline",
    "text": "Consortia Baseline\n\nsmpmap = CSV.read(joinpath(ddir, \"DFI_HMMF_1256_biobank-evnin_EW021622-5c6e08.tsv\"), DataFrame; delim=\"\\t\");\ndf = CSV.read(joinpath(ddir, \"removed_qcs_quant_results_20220301_PFBBr_EVIT1256_20220304.csv\"), DataFrame);\ndf = leftjoin(smpmap, df, on=:HMMF_sampleid =&gt; :sampleid);\nkeepids = [\n    \"DFI.2.45\",\n    \"DFI.1.234\",\n    \"CON.062\",\n]\nsubset(df, :msk_id =&gt; ByRow(∈([\"blank\"]))) |&gt; \n    df -&gt; sort(df, [:msk_id, \"taurocholic_acid__ug.ml\"]) |&gt;\n    df -&gt; select(df, \n        :msk_id,\n        \"taurocholic_acid__ug.ml\" =&gt; :condition,\n        :Acetate,\n        :Butyrate, \n        :Propionate,\n        :Succinate,\n    ) |&gt;\n    df -&gt; groupby(df, [:msk_id, :condition]) |&gt;\n    df -&gt; combine(df, [:Acetate, :Butyrate,:Propionate, :Succinate] .=&gt; mean)\npltdf = subset(df, :msk_id =&gt; ByRow(∈(keepids))) |&gt; \n    df -&gt; sort(df, [:msk_id, \"taurocholic_acid__ug.ml\"]) |&gt;\n    df -&gt; select(df, \n        :msk_id,\n        \"taurocholic_acid__ug.ml\" =&gt; :condition,\n        :Acetate,\n        :Butyrate, \n        :Propionate,\n        :Succinate,\n    ) |&gt;\n    df -&gt; transform(df,\n        :Acetate =&gt; ByRow(x-&gt;log2(x/4.3)) =&gt; :Acetate_log2FC\n    )\nplot(ylabel=\"Acetate (log2FC)\",)\ngroupby(pltdf, :msk_id) |&gt;\n    df -&gt; combine(df,\n        :Acetate_log2FC =&gt; mean,\n        :Acetate_log2FC =&gt; std,\n    ) |&gt;\n    x-&gt;@df x bar!(:msk_id, :Acetate_log2FC_mean, \n        yerror=:Acetate_log2FC_std,\n        # xticks=(1:3, :msk_id)\n    )\n\n\n@df pltdf scatter!(:msk_id, \n    :Acetate_log2FC, \n    c=:black, widen=true, size=(500,500),\n    \n)"
  },
  {
    "objectID": "01_figure_01.html",
    "href": "01_figure_01.html",
    "title": "Standard Analyses",
    "section": "",
    "text": "Julia library setup\nusing DrWatson\n@quickactivate projectdir()\n\nusing CSV, DataFrames, Muon\nusing Random: seed!\nusing UMAP, Distances\n\nusing LinearAlgebra, StatsBase\n\nusing StatsPlots\ntheme(:default, grid=false, tickdir=:out, label=false)\ninclude(srcdir(\"helpers.jl\"))\n\nbbdir = datadir(\"exp_raw\", \"BB669\");\ntdir_16S = projectdir(\"_research\", \"BB669_16S_phyml\")\ntdir_bac120 = projectdir(\"_research\", \"BB669_bac120_phyml\")\npdir_16S = plotsdir(\"BB669_16Strees\") |&gt; mkpath\npdir_bac120 = plotsdir(\"BB669_bac120trees\") |&gt; mkpath;\nR library setup\nusing RCall\nR\"\"\"\nlibrary(ape)\nlibrary(treeio)\nlibrary(ggtree)\nlibrary(ggplot2)\nlibrary(tidyverse)\n\nsetwd($(projectdir()))\n\"\"\";"
  },
  {
    "objectID": "01_figure_01.html#standard-analysis",
    "href": "01_figure_01.html#standard-analysis",
    "title": "Standard Analyses",
    "section": "Standard analysis",
    "text": "Standard analysis\nThis notebook gives context for what strains are in our strain bank and shows that standard analyses don’t work for capturing genomic strain variation.\n\n# read in data\nbiobank = readh5mu(joinpath(bbdir, \"BB669.h5mu\"))\nbiobank.obs[!,:kept_species] = convert.(Bool,biobank.obs[!,:kept_species]);\nbiobank\n\n┌ Warning: Cannot join columns with the same name because var_names are intersecting.\n└ @ Muon /Users/bend/.julia/packages/Muon/eLqpV/src/mudata.jl:351\n\n\nMuData object 669 ✕ 21475\n└ metabolites_foldchange\n  AnnData object 669 ✕ 50\n└ UPorder_oggs\n  AnnData object 669 ✕ 10177\n└ oggs\n  AnnData object 669 ✕ 11248\n\n\n\n# we have taxanomic information each of these strains\n# GTDB_* are the annotations from https://gtdb.ecogenomic.org/\n# NCBI_* are the annotation post-submission to NCBI\n# * annotations are pre-submission to NCBI\n# donor specifies which human microbiome each strain was sampled from\n#       &lt;hospital&gt;.&lt;donor number&gt;\nbbobs = biobank.obs;\nfirst(bbobs, 5)\n\n5×22 DataFrame\n\n\n\nRow\nStrain_ID\nAccession\nPhylum\nClass\nOrder\nFamily\nGenus\nSpecies\nDonor\nNCBI_Phylum\nNCBI_Class\nNCBI_Order\nNCBI_Family\nNCBI_Genus\nNCBI_Species\nGTDB_Phylum\nGTDB_Class\nGTDB_Order\nGTDB_Family\nGTDB_Genus\nGTDB_Species\nkept_species\n\n\n\nString\nString\nString\nString\nString\nString\nString\nString\nString\nString\nString\nString\nString\nString\nString\nString\nString\nString\nString\nString\nString\nBool\n\n\n\n\n1\nMSK.16.19\nJAHOLG000000000\nBacteroidetes\nBacteroidia\nBacteroidales\nBacteroidaceae\nBacteroides\nBacteroides eggerthii\nMSK.16\nBacteroidetes\nBacteroidia\nBacteroidales\nBacteroidaceae\nBacteroides\nBacteroides eggerthii\nBacteroidota\nBacteroidia\nBacteroidales\nBacteroidaceae\nBacteroides\nBacteroides eggerthii\nfalse\n\n\n2\nMSK.10.5\nJAHOMY000000000\nBacteroidetes\nBacteroidia\nBacteroidales\nBacteroidaceae\nBacteroides\nBacteroides fragilis\nMSK.10\nBacteroidetes\nBacteroidia\nBacteroidales\nBacteroidaceae\nBacteroides\nBacteroides fragilis\nBacteroidota\nBacteroidia\nBacteroidales\nBacteroidaceae\nBacteroides\nBacteroides fragilis_A\nfalse\n\n\n3\nMSK.13.23\nJAHOMK000000000\nBacteroidetes\nBacteroidia\nBacteroidales\nBacteroidaceae\nBacteroides\nBacteroides fragilis\nMSK.13\nBacteroidetes\nBacteroidia\nBacteroidales\nBacteroidaceae\nBacteroides\nBacteroides fragilis\nBacteroidota\nBacteroidia\nBacteroidales\nBacteroidaceae\nBacteroides\nBacteroides fragilis_A\nfalse\n\n\n4\nMSK.16.61\nJAHOKD000000000\nBacteroidetes\nBacteroidia\nBacteroidales\nBacteroidaceae\nPhocaeicola\nPhocaeicola vulgatus\nMSK.16\nBacteroidetes\nBacteroidia\nBacteroidales\nBacteroidaceae\nPhocaeicola\nPhocaeicola vulgatus\nBacteroidota\nBacteroidia\nBacteroidales\nBacteroidaceae\nPhocaeicola\nPhocaeicola vulgatus\ntrue\n\n\n5\nMSK.18.56\nJAHOHX000000000\nBacteroidetes\nBacteroidia\nBacteroidales\nBacteroidaceae\nBacteroides\nBacteroides caccae\nMSK.18\nBacteroidetes\nBacteroidia\nBacteroidales\nBacteroidaceae\nBacteroides\nBacteroides caccae\nBacteroidota\nBacteroidia\nBacteroidales\nBacteroidaceae\nBacteroides\nBacteroides caccae\nfalse\n\n\n\n\n\n\n\n# concentrated for lachno's and bacteroidaceae \n# (matches distibutions normally found in these types of strain bank)\nfamily_counts = sort(countmap(bbobs.NCBI_Family), byvalue=true, rev=true)\n\nOrderedCollections.OrderedDict{String, Int64} with 12 entries:\n  \"Lachnospiraceae\"              =&gt; 347\n  \"Bacteroidaceae\"               =&gt; 229\n  \"Bifidobacteriaceae\"           =&gt; 30\n  \"Tannerellaceae\"               =&gt; 21\n  \"Prevotellaceae\"               =&gt; 14\n  \"Rikenellaceae\"                =&gt; 9\n  \"Erysipelotrichaceae\"          =&gt; 5\n  \"&lt;unclassified&gt;\"               =&gt; 4\n  \"Oscillospiraceae\"             =&gt; 4\n  \"Odoribacteraceae\"             =&gt; 4\n  \"Enterobacteriaceae\"           =&gt; 1\n  \"Eubacteriales incertae sedis\" =&gt; 1\n\n\n\npie(family_counts, \n    c=palette(:Set3_12),\n    legend=:outerright,\n    size=(700,600),\n)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nproportion CSB strains from different NCBI families\n\n\n\nspecies_counts = collect(values(countmap(bbobs.NCBI_Species)));\nhistogram(\n    species_counts, \n    bins=100,\n    xlabel=\"# of replicates\",\n    ylabel=\"# of species\",\n    size=(500,500),\n)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\neach bar represents the number of measured species (y axis) with a certain number of replicates (x axis). Most species we classify only have 1 strain representative, 11 species have at least 20 strain representatives."
  },
  {
    "objectID": "01_figure_01.html#phyml-on-16s-alignment-of-biobank-strains",
    "href": "01_figure_01.html#phyml-on-16s-alignment-of-biobank-strains",
    "title": "Standard Analyses",
    "section": "Phyml on 16S alignment of Biobank strains",
    "text": "Phyml on 16S alignment of Biobank strains\n16S is a ribosomal protein (involved with translating RNA to Proteins) that is present across all bacteria. For that reason, it is commonly used as a gene marker for constructing ancestral trees of bacteria and taxanomic classification.\nWhat we show is that 16S annotations are only good up to species level classification. At that point all strains are completely indistinguishable from each other.\n\n# run(`sbatch $(projectdir(\"scripts\", \"run_phyml_csb16S.jl\"))`);\n\nTriggers run of scripts/run_phyml_csb16S.jl script on SLURM compute cluster. Has the effect of running\nphyml \\\n    -dnt -mHKY85 -fe -o tlr \\\n    --search SPR --r_seed 123456 --rand_start --n_rand_starts 3 \\\n    --no_memory_check \\\n    --bootstrap -4 \\\n    -i $PROJECTDIR/data/exp_raw/BB669/BB669_16S.phy\noutputting the results in _research/BB669_16S_phyml\n\nplot PhyML tree of 16S alignment\n\nR\"\"\"\n## read in tree and metadata\ntree = read.newick(file.path($tdir_16S, \"BB669_16S.phy-supporttree_multi.txt\"), node.label='support')\nlineagedf = read.csv(file.path($bbdir, \"BB669_rowmeta.tsv\"), sep=\"\\t\")\nlineagedf$label = lineagedf$Strain.ID\nsubset_lineagedf = lineagedf[match(tree@phylo$tip.label, lineagedf$label),]\nbiggerfamily_ncbi = sort(table(subset_lineagedf$NCBI.Family), decreasing = TRUE)[sort(table(subset_lineagedf$NCBI.Family), decreasing = TRUE) &gt; 0]\n# labels(biggerfamily_ncbi)[[1]]\ntree_withdata = as.treedata(left_join(as_tibble(tree), subset_lineagedf, by='label'))\nbtree_tbl = as_tibble(tree_withdata)\n\n## Calcuate most common family desendent from each internal node of the tree\nmode_family_ncbi = offspring(btree_tbl, btree_tbl$node, tiponly = FALSE, self_include = TRUE)\nmode_family_ncbi = unlist(lapply(mode_family_ncbi, function(x) modeest::mfv1(x$NCBI.Family, na_rm=TRUE)))\nbtree_tbl$mode_family_ncbi = mode_family_ncbi\ntree_withdata = as.treedata(btree_tbl)\n\n## plot tree colored with most common family at each node\noptions(repr.plot.width=15, repr.plot.height=15, ignore.negative.edge=TRUE)\ncolorvalues = RColorBrewer::brewer.pal(12, name=\"Set3\")\np = ggtree(tree_withdata, \n        aes(color=mode_family_ncbi, subset=support &gt; .5), \n        layout=\"equal_angle\", open.angle=5,\n        branch.length=\"none\", size=1.5,\n    ) +\n    ggtitle(\"CSB (PhyML) 16S\") + \n    scale_color_manual(values=colorvalues, breaks=labels(biggerfamily_ncbi)[[1]]) #+theme(legend.position=\"none\")\nggsave(file.path($pdir_16S, \"CSB669_PhyML_unrooted.svg\"), \n    p,\n    height=10,\n    width=10,\n)\n\"\"\"\nshow_svg(joinpath(pdir_16S, \"CSB669_PhyML_unrooted.svg\"))\n\n\n\n\n\nR\"\"\"\n# plot M. gnavus subtree\ncolorvalues = RColorBrewer::brewer.pal(12, name=\"Set3\")\np = ggtree(tree_subset(tree_withdata, \"MSK.5.17\", levels_back = 1), \n        aes(color=Donor), \n        layout=\"rect\", open.angle=10,\n    ) + \n    ggtitle(\"CSB (PhyML) 16S M. gnavus subtree\") + \n    theme(\n        legend.position = \"none\", \n    ) +\n    xlim(0, 4) +\n    geom_tiplab(aes(label=Donor))\nggsave(file.path($pdir_16S, \"CSB669_PhyML_rgnavus_16S.svg\"),\n    p, \n    height=7,\n    width=4.5,\n)\n\"\"\";\nshow_svg(joinpath(pdir_16S, \"CSB669_PhyML_rgnavus_16S.svg\"))\n\n\n\n\n\nR\"\"\"\n# plot M. gnavus subtree\ncolorvalues = RColorBrewer::brewer.pal(12, name=\"Set3\")\np = ggtree(tree_subset(tree_withdata, \"MSK.19.84\", levels_back = 3), \n        aes(color=Donor), \n        layout=\"rect\", open.angle=10,\n    ) + \n    ggtitle(\"CSB (PhyML) 16S B. uniformis subtree\") + \n    theme(\n        legend.position = \"none\", \n    ) +\n    xlim(0, 4) +\n    geom_tiplab(aes(label=Donor))\nggsave(file.path($pdir_16S, \"CSB669_PhyML_buniformis_16S.svg\"),\n    p, \n    height=7,\n    width=4.5,\n)\n\"\"\";\nshow_svg(joinpath(pdir_16S, \"CSB669_PhyML_buniformis_16S.svg\"))"
  },
  {
    "objectID": "01_figure_01.html#phyml-on-bac120-alignment-of-biobank-strains",
    "href": "01_figure_01.html#phyml-on-bac120-alignment-of-biobank-strains",
    "title": "Standard Analyses",
    "section": "Phyml on Bac120 alignment of Biobank strains",
    "text": "Phyml on Bac120 alignment of Biobank strains\nBac120 aimed to be an improvement over 16S annotation. It takes 120 genes that are reasonably well conserved across bacteria, and takes ~50 genomic positions from each of those genes, creating an annotation of around 6000 features.\nWe find that these annotations equally only work down to species level classification, with strain level replicates all being identically annotated.\n\n# run(`sbatch $(projectdir(\"scripts\", \"run_phyml_csbbac120.jl\"))`);\n\nTriggers run of scripts/run_phyml_csbbac120.jl script on SLURM compute cluster. Has the effect of running\nphyml -daa -mLG -fe -o tlr \\\n    --search SPR --r_seed 123456 --rand_start --n_rand_starts 3 \\\n    --no_memory_check \\\n    --bootstrap -4 \\\n    -i $PROJECTDIR/data/exp_raw/BB669/BB669_bac120.phy\noutputting the results in _research/BB669_bac120_phyml\n\nplot PhyML tree of Bac120 alignment\n\nR\"\"\"\n## read in tree and metadata\ntree = read.newick(file.path($tdir_bac120, \"BB669_bac120.phy-supporttree_multi.txt\"), node.label='support')\nlineagedf = read.csv(file.path($bbdir, \"BB669_rowmeta.tsv\"), sep=\"\\t\")\nlineagedf$label = lineagedf$Strain.ID\nsubset_lineagedf = lineagedf[match(tree@phylo$tip.label, lineagedf$label),]\nbiggerfamily_ncbi = sort(table(subset_lineagedf$NCBI.Family), decreasing = TRUE)[sort(table(subset_lineagedf$NCBI.Family), decreasing = TRUE) &gt; 0]\n# labels(biggerfamily_ncbi)[[1]]\ntree_withdata = as.treedata(left_join(as_tibble(tree), subset_lineagedf, by='label'))\nbtree_tbl = as_tibble(tree_withdata)\n\n## Calcuate most common family desendent from each internal node of the tree\nmode_family_ncbi = offspring(btree_tbl, btree_tbl$node, tiponly = FALSE, self_include = TRUE)\nmode_family_ncbi = unlist(lapply(mode_family_ncbi, function(x) modeest::mfv1(x$NCBI.Family, na_rm=TRUE)))\nbtree_tbl$mode_family_ncbi = mode_family_ncbi\ntree_withdata = as.treedata(btree_tbl)\n\n## plot tree colored with most common family at each node\noptions(repr.plot.width=15, repr.plot.height=15, ignore.negative.edge=TRUE)\ncolorvalues = RColorBrewer::brewer.pal(12, name=\"Set3\")\np = ggtree(tree_withdata, \n        aes(color=mode_family_ncbi, subset=support &gt; .5), \n        layout=\"equal_angle\", open.angle=5,\n        branch.length=\"none\", size=1.5,\n    ) +\n    ggtitle(\"CSB (PhyML) Bac120\") + \n    scale_color_manual(values=colorvalues, breaks=labels(biggerfamily_ncbi)[[1]]) #+theme(legend.position=\"none\")\nggsave(file.path($pdir_bac120, \"CSB669_PhyML_unrooted_bac120.svg\"), \n    p,\n    height=10,\n    width=10,\n)\n\"\"\"\nshow_svg(joinpath(pdir_bac120, \"CSB669_PhyML_unrooted_bac120.svg\"))\n\n\n\n\n\n# plot M. gnavus subtree\nR\"\"\"\ncolorvalues = RColorBrewer::brewer.pal(12, name=\"Set3\")\np = ggtree(tree_subset(tree_withdata, \"MSK.5.17\", levels_back = 1), \n        aes(color=Donor), \n        layout=\"rect\", open.angle=10,\n    ) + \n    ggtitle(\"CSB (PhyML) bac120 M. gnavus subtree\") + \n    theme(\n        legend.position = \"none\", \n    ) +\n    xlim(0, 4) +\n    geom_tiplab(aes(label=Donor))\nggsave(file.path($pdir_16S, \"CSB669_PhyML_rgnavus_bac120.svg\"),\n    p, \n    height=7,\n    width=4.5,\n)\n\"\"\";\nshow_svg(joinpath(pdir_16S, \"CSB669_PhyML_rgnavus_bac120.svg\"))\n\n\n\n\n\n# plot M. gnavus subtree\nR\"\"\"\ncolorvalues = RColorBrewer::brewer.pal(12, name=\"Set3\")\np = ggtree(tree_subset(tree_withdata, \"MSK.19.84\", levels_back = 5), \n        aes(color=Donor), \n        layout=\"rect\", open.angle=10,\n    ) + \n    ggtitle(\"CSB (PhyML) bac120 B. uniformis subtree\") + \n    theme(\n        legend.position = \"none\", \n    ) +\n    xlim(0, 4) +\n    geom_tiplab(aes(label=Donor))\nggsave(file.path($pdir_16S, \"CSB669_PhyML_buniformis_bac120.svg\"),\n    p, \n    height=7,\n    width=4.5,\n)\n\"\"\";\nshow_svg(joinpath(pdir_16S, \"CSB669_PhyML_buniformis_bac120.svg\"))"
  },
  {
    "objectID": "01_figure_01.html#metabolite-variablilty",
    "href": "01_figure_01.html#metabolite-variablilty",
    "title": "Standard Analyses",
    "section": "Metabolite variablilty",
    "text": "Metabolite variablilty\nHowever, these strains are not functionally identical. Strains of the same species, digest/produce different amounts of metabolite compounds. And it is not simply individual variation. In the plot below we see bi-modal distribution indicating that there are groups of strains that behave differently.\n\ntheme(:default, grid=false, tickdir=:out, label=false)\npdir_met = plotsdir(\"metabolite_strainvariation\") |&gt; mkpath\n\n\"/Users/bend/projects/Doran_etal_2023/plots/metabolite_strainvariation\"\n\n\n\n# load metabolites matrix\nmetmtx = biobank[\"metabolites_foldchange\"].X[:, :][biobank.obs.kept_species,:];\n\n# too close to zero for detectable measurment, so assume no change\nmetmtx[isinf.(metmtx)] .= 0.0; \n@show size(metmtx)\n\n# filter to metabolites that have at least 10% detectable shifts in measurement\nmetabolite_names_full = biobank[\"metabolites_foldchange\"].var_names.vals;\nkeepmetabolites_mask = mapslices(c-&gt;mean(c .== 0.0) &lt; 0.9, metmtx, dims=1) |&gt; vec;\nmetabolite_names = metabolite_names_full[keepmetabolites_mask]\nmetmtx = metmtx[:, keepmetabolites_mask];\n@show size(metmtx);\n\nsize(metmtx) = (356, 50)\nsize(metmtx) = (356, 32)\n\n\n\nspeciescolors = CSV.read(datadir(\"exp_raw\", \"BB669\", \"subsettreecolors.csv\"), DataFrame);\nmetabolitelabels = biobank[\"metabolites_foldchange\"].var.label;\n\n\nmetbbobs = bbobs[biobank.obs.kept_species, :];\n\n\nmetabolite_species = sort(countmap(metbbobs.Species), byvalue=true, rev=true)\n\nOrderedCollections.OrderedDict{String, Int64} with 11 entries:\n  \"Phocaeicola vulgatus\"         =&gt; 88\n  \"[Ruminococcus] gnavus\"        =&gt; 41\n  \"Bacteroides thetaiotaomicron\" =&gt; 35\n  \"Anaerostipes hadrus\"          =&gt; 31\n  \"Bacteroides uniformis\"        =&gt; 27\n  \"Blautia luti\"                 =&gt; 24\n  \"Bifidobacterium breve\"        =&gt; 24\n  \"Coprococcus comes\"            =&gt; 23\n  \"Dorea formicigenerans\"        =&gt; 22\n  \"Blautia wexlerae\"             =&gt; 21\n  \"[Eubacterium] rectale\"        =&gt; 20\n\n\n\n\nshow plotting code\nps = []\nfor (i, species) in enumerate(keys(metabolite_species))\n    speciesmask = occursin.(species, metbbobs.Species)\n    p = violin(permutedims(1:size(metmtx, 2)),\n        metmtx[speciesmask, :],\n        ylabel=\"$(last(split(species,\" \"))) ($(metabolite_species[species]))\",\n        c=speciescolors.color[findfirst(==(species), speciescolors.species_name)],\n        xticks= i&gt;=10 ? (1:size(metmtx, 2), metabolitelabels) : (1:size(metmtx, 2), repeat([\"\"], size(metmtx, 2))),\n        xrotation=90,\n    )\n    dotplot!(permutedims(1:size(metmtx, 2)),\n        metmtx[speciesmask, :], \n        c=:black, alpha=.2, markerstrokewidth=0, markersize=1,\n        # side=:right\n    )\n    push!(ps, p)\nend\n\nplot(ps..., \n    layout=grid(ceil(Int, length(metabolite_species)/2), 2), \n    plot_title = \"CSB metabolite strain variation\",\n    size=(800, 800),\n    tickdirection=:out,\n    labelfontsize=6,\n    tickfontsize=6,\n    lw=.5,\n    markersize=1\n)\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\nshow log-2 fold change from base media across strains from 9 species with more than 20 replicates. multi-modal distributions for some distributions indicates sub-species phylogentic variation in phenotype.\n\n\n\nsavefig(joinpath(pdir_met, \"violinplots_32metabolites_strainlevel_variation.pdf\"))\n\n\"/Users/bend/projects/Doran_etal_2023/plots/metabolite_strainvariation/violinplots_32metabolites_strainlevel_variation.pdf\""
  },
  {
    "objectID": "01_figure_01.html#proforming-pca-analysis",
    "href": "01_figure_01.html#proforming-pca-analysis",
    "title": "Standard Analyses",
    "section": "Proforming PCA analysis",
    "text": "Proforming PCA analysis\nUsing the orthologous gene-group annotations can we represent these strains in a way that captures functional diversity?\nWe find that using traditional PCA fails to create this representation. Regardless of if we subset to narrow taxanomic groups, metabolic variation is never the principle axis of variation.\n\ntheme(:default, grid=false, framestyle=:box, label=\"\", ratio=1)\n\n\nFull CSB\n\ncsb_mtx = biobank[\"oggs\"].X[:,:]\n\n# find variable OGGs\nogg_mask = vec(var(csb_mtx, dims=1) .&gt; 0)\n# mean center variable OGGs\nmeancentered_csbmtx = mapslices(x-&gt;x.-mean(x), csb_mtx[:, ogg_mask], dims=1)\n# svd of mean centered matrix\nbbusv_csb = svd(meancentered_csbmtx);\n\n@show size(meancentered_csbmtx);\n\nsize(meancentered_csbmtx) = (669, 8359)\n\n\n\n# Principal Components from SVD\npcs_csb = bbusv_csb.U * Diagonal(bbusv_csb.S);\n# percent of variance explained by each PC\npctvar = (bbusv_csb.S .^ 2 / sum(bbusv_csb.S .^ 2)) * 100;\n\n\n\nmap colors to NCBI families in correct order for plotting\nfamilyid = bbobs.NCBI_Family\norderedfamilylabels = stack(DataFrame(countmap(familyid)), 1:12) |&gt;\n    df -&gt; DataFrames.transform(df, :value =&gt; (-) =&gt; :minusvalue) |&gt;\n    df -&gt; sort(df, [:minusvalue, :variable], rev=false) |&gt;\n    df -&gt; df.variable\nfamilycolors = permutedims(palette(:Set3_12).colors.colors[indexin(sort(unique(familyid)), orderedfamilylabels)]);\n\n# collect Butyrate and Succinate values for colormap\nbutyrate_foldchange_per_strain = biobank[\"metabolites_foldchange\"].X[:, findfirst(==(\"Butyrate\"), biobank[\"metabolites_foldchange\"].var.label)];\nsuccinate_foldchange_per_strain = biobank[\"metabolites_foldchange\"].X[:, findfirst(==(\"Succinate\"), biobank[\"metabolites_foldchange\"].var.label)];\n\n# get color limits based on most extreme value\nbutyrate_lims = getlims(butyrate_foldchange_per_strain)\nsuccinate_lims = getlims(succinate_foldchange_per_strain);\n\n\nThe principal axis of variation across the strain bank is phylum, within each phyla there is no pattern to which strains produce/digest metabolites.\n\nscatter(pcs_csb[:, 1], pcs_csb[:, 2],\n    group=familyid,\n    alpha=1, markerstrokewidth=.3,\n    size=(600,600),\n    legend=:outertop,\n    legendcolumns=2,\n    c=familycolors,\n    margin=5Plots.mm,\n    ticks=:none,\n    title=\"CSB669 (2PCs)\",\n    xlabel=\"PC 1 ($(round(pctvar[1], digits=2))%)\",\n    ylabel=\"PC 2 ($(round(pctvar[2], digits=2))%)\",\n)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nscatter(pcs_csb[:, 1], pcs_csb[:, 2],\n    marker_z=butyrate_foldchange_per_strain,\n    c=:bwr, clims=butyrate_lims,\n    alpha=.5, markerstrokewidth=.3, ticks=false,\n    size=(600,600), margin=5Plots.mm,\n    title=\"colored by butyrate\",\n    xlabel=\"PC 1 ($(round(pctvar[1], digits=2))%)\",\n    ylabel=\"PC 2 ($(round(pctvar[2], digits=2))%)\",\n)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\nscatter(pcs_csb[:, 1], pcs_csb[:, 2],\n    marker_z=succinate_foldchange_per_strain,\n    c=:bwr, clims=succinate_lims,\n    alpha=.5, markerstrokewidth=.3, ticks=false,\n    size=(600,600), margin=5Plots.mm,\n    title=\"colored by succinate\",\n    xlabel=\"PC 1 ($(round(pctvar[1], digits=2))%)\",\n    ylabel=\"PC 2 ($(round(pctvar[2], digits=2))%)\",\n)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\nshow plotting code\nspecies_labelscounts = map(speciescolors.species_name[Not(5,6)]) do label\n    cnt = occursin.(biobank.obs.Species, label) |&gt; sum\n    label, cnt\nend |&gt; x-&gt;sort(x, by=last, rev=true)\n\nps = []\nfor (label, cnt) in species_labelscounts\n    mask = occursin.(biobank.obs.Species, label)\n    p = plot()\n    scatter!(pcs_csb[.!mask, 1], pcs_csb[.!mask, 2]; c=:lightgrey, alpha=.1, markersize=2, markerstrokewidth=0)\n    scatter!(pcs_csb[mask, 1], pcs_csb[mask, 2];\n        title=\"$label ($cnt)\", \n        c=:aqua,\n        alpha=1, \n        markersize=3, \n        markerstrokewidth=0, \n    )\n    push!(ps, p)\nend\nplot(ps...;\n    layout=grid(3,3),\n    size=(700,700),\n    supertitle=\"CSB669 10PCs\",\n    # xlabel=\"PC 1\",\n    # ylabel=\"PC 2\",\n    titlefontsize=8,\n    labelfontsize=6,\n    ticks=false,\n    margin=5Plots.mm,\n\n)\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nEach sub-plot shows 669 CSB strains on PC 1 (x axis) and PC 2 (y axis). Aqua dots correspond to strains belonging to the species listed in each sub-title followed by the number of strains belonging to that species. Remaining strains are shown in grey.\n\n\n\n\nSubset to Bacteroidacae\nSame story but subset to the level of Family\n\nmask = biobank.obs.NCBI_Family .== \"Bacteroidaceae\";\n\n\ncsb_mtx = biobank[\"oggs\"].X[:,:][mask, :]\n\n# find variable OGGs\nogg_mask = vec(var(csb_mtx, dims=1) .&gt; 0)\n# mean center variable OGGs\nmeancentered_csbmtx = mapslices(x-&gt;x.-mean(x), csb_mtx[:, ogg_mask], dims=1)\n# svd of mean centered matrix\nbbusv_csb = svd(meancentered_csbmtx);\n\n@show size(meancentered_csbmtx);\n\nsize(meancentered_csbmtx) = (229, 3755)\n\n\n\n# Principal Components from SVD\npcs_csb = bbusv_csb.U * Diagonal(bbusv_csb.S);\n# percent of variance explained by each PC\npctvar = (bbusv_csb.S .^ 2 / sum(bbusv_csb.S .^ 2)) * 100;\n\n\n\nmap colors to NCBI Species in correct order for plotting\ngenusid = biobank.obs.NCBI_Genus[mask]\n\n# collect Butyrate and Succinate values for colormap\nbutyrate_foldchange_per_strain = biobank[\"metabolites_foldchange\"].X[:, findfirst(==(\"Butyrate\"), biobank[\"metabolites_foldchange\"].var.label)][mask, :];\nsuccinate_foldchange_per_strain = biobank[\"metabolites_foldchange\"].X[:, findfirst(==(\"Succinate\"), biobank[\"metabolites_foldchange\"].var.label)][mask, :];\n\n\n\nscatter(pcs_csb[:, 1], pcs_csb[:, 2],\n    group=genusid,\n    alpha=1, markerstrokewidth=.3,\n    size=(600,600),\n    legend=:outertop,\n    legendcolumns=2,\n    ticks=:none,\n    title=\"Bacteroidaceae (2PCs)\",\n    xlabel=\"PC_1 ($(round(pctvar[1], digits=2))%)\",\n    ylabel=\"PC_2 ($(round(pctvar[2], digits=2))%)\",\n)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nscatter(pcs_csb[:, 1], pcs_csb[:, 2],\n    marker_z=butyrate_foldchange_per_strain,\n    c=:bwr, clims=butyrate_lims,\n    alpha=.5, markerstrokewidth=.3, ticks=false,\n    size=(600,600), margin=5Plots.mm,\n    title=\"colored by butyrate\",\n    xlabel=\"PC 1 ($(round(pctvar[1], digits=2))%)\",\n    ylabel=\"PC 2 ($(round(pctvar[2], digits=2))%)\",\n)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\nscatter(pcs_csb[:, 1], pcs_csb[:, 2],\n    marker_z=succinate_foldchange_per_strain,\n    c=:bwr, clims=succinate_lims,\n    alpha=.5, markerstrokewidth=.3, ticks=false,\n    size=(600,600), margin=5Plots.mm,\n    title=\"colored by succinate\",\n    xlabel=\"PC 1 ($(round(pctvar[1], digits=2))%)\",\n    ylabel=\"PC 2 ($(round(pctvar[2], digits=2))%)\",\n)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\nSubset to Phocaeicoli\nSame story subset to the level of Genus\n\nmask = biobank.obs.NCBI_Genus .== \"Phocaeicola\";\n\n\ncsb_mtx = biobank[\"oggs\"].X[:,:][mask, :]\n\n# find variable OGGs\nogg_mask = vec(var(csb_mtx, dims=1) .&gt; 0)\n# mean center variable OGGs\nmeancentered_csbmtx = mapslices(x-&gt;x.-mean(x), csb_mtx[:, ogg_mask], dims=1)\n# svd of mean centered matrix\nbbusv_csb = svd(meancentered_csbmtx);\n\n@show size(meancentered_csbmtx);\n\nsize(meancentered_csbmtx) = (103, 2065)\n\n\n\n# Principal Components from SVD\npcs_csb = bbusv_csb.U * Diagonal(bbusv_csb.S);\n# percent of variance explained by each PC\npctvar = (bbusv_csb.S .^ 2 / sum(bbusv_csb.S .^ 2)) * 100;\n\n\n\nmap colors to NCBI Species in correct order for plotting\nspeciesid = biobank.obs.NCBI_Species[mask]\n\n# collect Butyrate and Succinate values for colormap\nbutyrate_foldchange_per_strain = biobank[\"metabolites_foldchange\"].X[:, findfirst(==(\"Butyrate\"), biobank[\"metabolites_foldchange\"].var.label)][mask, :];\nsuccinate_foldchange_per_strain = biobank[\"metabolites_foldchange\"].X[:, findfirst(==(\"Succinate\"), biobank[\"metabolites_foldchange\"].var.label)][mask, :];\n\n\n\nscatter(pcs_csb[:, 1], pcs_csb[:, 2],\n    group=speciesid,\n    alpha=1, markerstrokewidth=.3,\n    size=(600,600),\n    legend=:outertop,\n    legendcolumns=2,\n    ticks=:none,\n    title=\"Phocaeicola (2PCs)\",\n    xlabel=\"PC_1 ($(round(pctvar[1], digits=2))%)\",\n    ylabel=\"PC_2 ($(round(pctvar[2], digits=2))%)\",\n)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nscatter(pcs_csb[:, 1], pcs_csb[:, 2],\n    marker_z=butyrate_foldchange_per_strain,\n    c=:bwr, clims=butyrate_lims,\n    alpha=.5, markerstrokewidth=.3, ticks=false,\n    size=(600,600), margin=5Plots.mm,\n    title=\"colored by butyrate\",\n    xlabel=\"PC 1 ($(round(pctvar[1], digits=2))%)\",\n    ylabel=\"PC 2 ($(round(pctvar[2], digits=2))%)\",\n)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\nscatter(pcs_csb[:, 1], pcs_csb[:, 2],\n    marker_z=succinate_foldchange_per_strain,\n    c=:bwr, clims=succinate_lims,\n    alpha=.5, markerstrokewidth=.3, ticks=false,\n    size=(600,600), margin=5Plots.mm,\n    title=\"colored by succinate\",\n    xlabel=\"PC 1 ($(round(pctvar[1], digits=2))%)\",\n    ylabel=\"PC 2 ($(round(pctvar[2], digits=2))%)\",\n)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\nSubset to P. vulgatus\nSame story subset to the level of an individual species.\nEven here where we have introduced a large amount of constraint in the type of variation in our dataset, metabolite concentrations are not what is varying by these principal axes of variation. Meaning we can find many cases where strains are overlaid on top of each other on these axes, yet still have very different behavior either eating or producing metabolites. Similarly, on either side of the plot, we can see strains that produce/consume metabolites at similar levels.\n\nmask = biobank.obs.NCBI_Species .== \"Phocaeicola vulgatus\";\n\n\ncsb_mtx = biobank[\"oggs\"].X[:,:][mask, :]\n\n# find variable OGGs\nogg_mask = vec(var(csb_mtx, dims=1) .&gt; 0)\n# mean center variable OGGs\nmeancentered_csbmtx = mapslices(x-&gt;x.-mean(x), csb_mtx[:, ogg_mask], dims=1)\n# svd of mean centered matrix\nbbusv_csb = svd(meancentered_csbmtx);\n\n@show size(meancentered_csbmtx);\n\nsize(meancentered_csbmtx) = (93, 1551)\n\n\n\n# Principal Components from SVD\npcs_csb = bbusv_csb.U * Diagonal(bbusv_csb.S);\n# percent of variance explained by each PC\npctvar = (bbusv_csb.S .^ 2 / sum(bbusv_csb.S .^ 2)) * 100;\n\n\n\nmap colors to NCBI Species in correct order for plotting\nspeciesid = biobank.obs.NCBI_Species[mask]\n\n# collect Butyrate and Succinate values for colormap\nbutyrate_foldchange_per_strain = biobank[\"metabolites_foldchange\"].X[:, findfirst(==(\"Butyrate\"), biobank[\"metabolites_foldchange\"].var.label)][mask, :];\nsuccinate_foldchange_per_strain = biobank[\"metabolites_foldchange\"].X[:, findfirst(==(\"Succinate\"), biobank[\"metabolites_foldchange\"].var.label)][mask, :];\n\n\n\nscatter(pcs_csb[:, 1], pcs_csb[:, 2],  c=4,\n    alpha=1, markerstrokewidth=.3,\n    size=(600,600),\n    ticks=:none,\n    title=\"Phocaeicola (2PCs)\",\n    margin=5Plots.mm,\n    xlabel=\"PC_1 ($(round(pctvar[1], digits=2))%)\",\n    ylabel=\"PC_2 ($(round(pctvar[2], digits=2))%)\",\n)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nscatter(pcs_csb[:, 1], pcs_csb[:, 2],\n    marker_z=butyrate_foldchange_per_strain,\n    c=:bwr, clims=butyrate_lims,\n    alpha=.5, markerstrokewidth=.3, ticks=false,\n    size=(600,600), margin=5Plots.mm,\n    title=\"colored by butyrate\",\n    xlabel=\"PC 1 ($(round(pctvar[1], digits=2))%)\",\n    ylabel=\"PC 2 ($(round(pctvar[2], digits=2))%)\",\n)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\nscatter(pcs_csb[:, 1], pcs_csb[:, 2],\n    marker_z=succinate_foldchange_per_strain,\n    c=:bwr, clims=succinate_lims,\n    alpha=.5, markerstrokewidth=.3, ticks=false,\n    size=(600,600), margin=5Plots.mm,\n    title=\"colored by succinate\",\n    xlabel=\"PC 1 ($(round(pctvar[1], digits=2))%)\",\n    ylabel=\"PC 2 ($(round(pctvar[2], digits=2))%)\",\n)"
  },
  {
    "objectID": "01_figure_01.html#umap-analysis-of-biobank-strains",
    "href": "01_figure_01.html#umap-analysis-of-biobank-strains",
    "title": "Standard Analyses",
    "section": "Umap analysis of biobank strains",
    "text": "Umap analysis of biobank strains\nUMAP doesn’t help. If we use 10 principal components, and compress with UMAP into 2 dimensions we get the same story. Species are compressed into nearly single points, and the metabolite variability contained within is lost.\n\n\nCalcuate PCs on full CSB\ntheme(:default, grid=false, framestyle=:box, label=\"\", ratio=1)\ncsb_mtx = biobank[\"oggs\"].X[:,:]\n\n# find variable OGGs\nogg_mask = vec(var(csb_mtx, dims=1) .&gt; 0)\n# mean center variable OGGs\nmeancentered_csbmtx = mapslices(x-&gt;x.-mean(x), csb_mtx[:, ogg_mask], dims=1)\n# svd of mean centered matrix\nbbusv_csb = svd(meancentered_csbmtx);\n\n@show size(meancentered_csbmtx);\n\n# Principal Components from SVD\npcs_csb = bbusv_csb.U * Diagonal(bbusv_csb.S);\n# percent of variance explained by each PC\npctvar = (bbusv_csb.S .^ 2 / sum(bbusv_csb.S .^ 2)) * 100;\n\nfamilyid = bbobs.NCBI_Family\norderedfamilylabels = stack(DataFrame(countmap(familyid)), 1:12) |&gt;\n    df -&gt; DataFrames.transform(df, :value =&gt; (-) =&gt; :minusvalue) |&gt;\n    df -&gt; sort(df, [:minusvalue, :variable], rev=false) |&gt;\n    df -&gt; df.variable\nfamilycolors = permutedims(palette(:Set3_12).colors.colors[indexin(sort(unique(familyid)), orderedfamilylabels)]);\n\n\nsize(meancentered_csbmtx) = (669, 8359)\n\n\n\nseed!(424242)\npcs_csb = bbusv_csb.U * Diagonal(bbusv_csb.S)\nn_neighbors = floor(Int,3*sqrt(669))\npcs_umap_coords = umap(pcs_csb[:, 1:10]', 2; n_neighbors, metric=Euclidean())';\n@show n_neighbors;\n\nn_neighbors = 77\n\n\n\nscatter(pcs_umap_coords[:, 1], pcs_umap_coords[:, 2],\n    group=familyid,\n    alpha=1, markerstrokewidth=.3,\n    size=(600,600),\n    legend=:outertop,\n    legendcolumns=2,\n    c=familycolors,\n    margin=5Plots.mm,\n    ticks=:none,\n    title=\"CSB669\",\n    xlabel=\"UMAP 1\",\n    ylabel=\"UMAP 2\",\n)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nshow plotting code\nspecies_labelscounts = map(speciescolors.species_name[Not(5,6)]) do label\n    cnt = occursin.(biobank.obs.Species, label) |&gt; sum\n    label, cnt\nend |&gt; x-&gt;sort(x, by=last, rev=true)\n\nps = []\nfor (label, cnt) in species_labelscounts\n    mask = occursin.(biobank.obs.Species, label)\n    p = plot()\n    scatter!(pcs_umap_coords[.!mask, 1], pcs_umap_coords[.!mask, 2]; c=:lightgrey, alpha=.1, markersize=2, markerstrokewidth=0)\n    scatter!(pcs_umap_coords[mask, 1], pcs_umap_coords[mask, 2];\n        title=\"$label ($cnt)\", \n        c=:aqua,\n        alpha=1, \n        markersize=3, \n        markerstrokewidth=0, \n    )\n    push!(ps, p)\nend\nplot(ps...;\n    layout=grid(3,3),\n    size=(700,700),\n    supertitle=\"CSB669 10PCs\",\n    # xlabel=\"PC 1\",\n    # ylabel=\"PC 2\",\n    titlefontsize=8,\n    labelfontsize=6,\n    ticks=false,\n    margin=5Plots.mm,\n\n)\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nEach sub-plot shows 669 CSB strains on UMAP 1 (x axis) and UMAP 2 (y axis) generated from euclidean distance across the leading 10 PCs and 77 shared nearest neighbors. Aqua dots correspond to strains belonging to the species listed in each sub-title followed by the number of strains belonging to that species. Remaining strains are shown in grey."
  },
  {
    "objectID": "02_figure_02supp.html",
    "href": "02_figure_02supp.html",
    "title": "Spectral Tree Theory",
    "section": "",
    "text": "Julia Setup\nusing DrWatson\n@quickactivate projectdir()\n\nusing SpectralInference # custom package from $projectdir/src\nusing NewickTree\nusing Gotree_jll, Goalign_jll\nusing StatsBase, NeighborJoining\nusing Distances, Clustering\nusing DataFrames, CSV\nusing Muon\nusing Symbolics\nusing StatsPlots\ntheme(:default, grid=false, label=false, tickdir=:out)\nusing LinearAlgebra\nusing LaTeXStrings\ninclude(srcdir(\"helpers.jl\"))\nheatmapcols = [:purple, :black, :yellow];\ngenerationcols = [\"#B3D2FC\" \"#2B689E\" \"#338591\"];"
  },
  {
    "objectID": "02_figure_02supp.html#exploration-of-toy-evolution",
    "href": "02_figure_02supp.html#exploration-of-toy-evolution",
    "title": "Spectral Tree Theory",
    "section": "Exploration of toy evolution",
    "text": "Exploration of toy evolution\nTo explore if strain-level diversity can be inferred from genomic co-variation patterns at all, we started with an in silico model of sequential diversification. An ancestral root is defined by 14-bit string of ‘1’. Diversification through three generations (G1, G2, and G3) is done by inducing “knockout mutations” by flipping a ‘1’ to ‘0’. Each split induces 2 mutations, one for each created sub-population. After three generations we have created 8 unique sub-populations existing at the current time. The alignment of these extant populations is shown below.\n\n# note how the zeros creates 3 layers of bifurcations\nM = Float64.([\n#   G1   G2       G3\n    0 1  0 1 1 1  0 1 1 1 1 1 1 1; # subpopulation a\n    0 1  0 1 1 1  1 0 1 1 1 1 1 1;\n    0 1  1 0 1 1  1 1 0 1 1 1 1 1;\n    0 1  1 0 1 1  1 1 1 0 1 1 1 1;\n    1 0  1 1 0 1  1 1 1 1 0 1 1 1;\n    1 0  1 1 0 1  1 1 1 1 1 0 1 1;\n    1 0  1 1 1 0  1 1 1 1 1 1 0 1;\n    1 0  1 1 1 0  1 1 1 1 1 1 1 0; # subpopulation h\n]);\n\n\n# spectrally decompose the alignment\nusv = svd(M);\n\n\n# show explained variance of each principal component\nplot(\n    ylabel=\"explained variance (%)\", \n    xlabel=\"spectral component\", \n    legend=:none, \n    ylims=(0,1), xlims=(.5,8.5), \n    size=(500,500)\n)\nscatter!((usv.S.^2)/sum(usv.S.^2), \n    xticks=1:14, c=:black, markersize=5,\n)\nannotate!((1:length(usv.S)) .+ .1 , (usv.S.^2)/sum(usv.S.^2).+.06, round.((usv.S.^2)/sum(usv.S.^2)*100, digits=1))\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nwe see that 81% of variation is explained by the first principal component\n\n\n\n# show projection of each taxa onto each principal component\nheatmap(usv.U, \n    c=:viridis,\n    framestyle=:box,\n    ratio=1,\n    xmirror=true,\n    yflip=true,\n    yticks=(1:8, 'a':'h'),\n    xticks=(1:8, [\"PC $i\" for i in 1:8]),\n    margin=5Plots.mm,\n    size=(500,530),\n    xlabel=\"spectral component\",\n    ylabel=\"taxa\",\n    title=\"left singular vectors\",\n)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\nyet when we look at how taxa project onto each PC, all taxa are indistiguishable on PC1, Yet we do see PCs that split our most recent evolutionary splits. They just happen to be PCs 5-8.\n\n\nSo why does PC1 both “explain 81% of variance” and also not differentiate between any of the taxa? The mathematical reason is that we didn’t mean center our data. So PC1 is telling us how far our data is from the origin collectively. Even if we did mean center our data by subtracting the mean from each column, all that happens is that the PCs get shifted left by 1. So what is now PC2 would move to PC1 etc.\nThe key point here is that information describing local differences between taxa are embedded in deep components. In this case information about the divergences at generation 3 are embedded into components 5-8. Mean centering would not move the information regarding local differences into the portion of the spectrum that we usually analyze (PCs 1-10). Additionally, given that we know this data is hierarchical (i.e. generated from a tree), it can make biological sense to not mean center and instead use PC 1 as an indicator of the common traits common to all taxa. In the case that we did have sub-populations with no traits in common (i.e. orthogonal populations), PC 1 would then show a bifurcation. So, we are not mandating hierarchy in the spectral decomposition, simply using the factorization as a readout of organization.\nWe can leverage these insights into instantiating a distance metric that incorporates the projections of taxa across all components.\n\n# calculate euclidean distance between each taxa-taxa pair on each left singular vector\nspires = spectraldistances_trace(usv.U, usv.S, [i:i for i in 1:8])\n# cumulative sum of distances for each pair along each LSV\nspires = mapslices(cumsum, spires, dims=1)\n\n# masks of pairs that diverged only at &lt;xx&gt; generation\ntrilmask = tril(trues(size(usv.U)),-1)\nG1mask = Bool.(kron([0 0; 1 0],[1 1;1 1], [1 1;1 1]))\nG2mask = Bool.(kron([1 0; 0 1], [0 0; 1 0], [1 1; 1 1]))\nG3mask = Bool.(kron([1 0; 0 1],[1 0; 0 1], [0 0; 1 0]));\n\n\nplot([0 0 0], \n    label=[\"G1\" \"G2\" \"G3\"], \n    c=generationcols,\n    linestyle=[:solid :dash :dot],\n    linewidth=3,\n    size=(650, 300),\n    legend=:topleft,\n    xticks=1:8,\n    ylabel=\"cumulative spectral distance\",\n    xlabel=\"principal components\",\n    margin=5Plots.mm,\n)\nplot!(spires[:, G1mask[trilmask]],linewidth=3, c=generationcols[1],linestyle=:solid, label=\"\")\nplot!(spires[:, G2mask[trilmask]],linewidth=3, c=generationcols[2],linestyle=:dash,  label=\"\")\nplot!(spires[:, G3mask[trilmask]],linewidth=3, c=generationcols[3],linestyle=:dot,   label=\"\")\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nnote that all pairs that diverged at G1 (e.g. ‘a’ and ‘h’) have a positive distance at component 2;\n\n\nBecause later generations have more sub-populations (exponentially so), they also need more components to describe the relative distances between all of those subpopulations. If we group components based on the amount of variance explained and sum across the euclidean distances within each group, we find that pairs diverging at the same generation also diverge in spectral distance to the same degree.\n\npartitioneddists = spectraldistances_trace(usv.U, usv.S, [1:1, 2:2, 3:4, 5:8])\ncumsumpdists = cumsum(partitioneddists, dims=1);\n\n\nplot([0 0 0], \n    label=[\"G1\" \"G2\" \"G3\"], \n    c=generationcols,\n    linestyle=[:solid :dash :dot],\n    legend=:topleft,\n    linewidth=5,\n    size=(600, 300),\n    xticks=(1:4, [\"1:1\", \"2:2\", \"3:4\", \"5:8\"]),\n    ylabel=\"cumulative partitioned\\nspectral distance\",\n    xlabel=\"principal component groups\",\n    margin=5Plots.mm,\n)\nplot!(cumsumpdists[:, G1mask[trilmask]], linewidth=4, c=generationcols[1],linestyle=:solid, label=\"\")\nplot!(cumsumpdists[:, G2mask[trilmask]], linewidth=4, c=generationcols[2],linestyle=:dash,  label=\"\")\nplot!(cumsumpdists[:, G3mask[trilmask]], linewidth=4, c=generationcols[3],linestyle=:dot,   label=\"\")\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ncolors = [:black, reverse(generationcols)...]\nplot(layout=grid(1,4), size=(900, 200), ratio=1, colorbar=:none, bottommargin=5Plots.Measures.mm, ticks=(1:8, 'a':'h'))\nheatmap!(trunc.(squareform(cumsumpdists[1,:]), digits=13), sp=1, c=colors, title=\"partition 1:1\", leftmargin=5Plots.mm,)\nheatmap!(squareform(cumsumpdists[2,:]), sp=2, c=colors, title=\"partition 1:2\")\nheatmap!(squareform(cumsumpdists[3,:]), sp=3, c=colors, title=\"partition 1:3\")\nheatmap!(trunc.(Int,squareform(cumsumpdists[4,:])), sp=4, c=colors, title=\"partition 1:4\")\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPlot partitioned distance matrix (Partitioned Weighted Euclidean) adding one additional partition left-right. Right most matrix cleanly shows all 3 generational differences\n\n\nWe can use this last distance matrix to infer the generative ancestral tree.\n\n# sum of all partitioned distances\ndij = squareform(cumsumpdists[4,:])\n\n8×8 Matrix{Float64}:\n 0.0      1.41421  2.31607  2.31607  3.08077  3.08077  3.08077  3.08077\n 1.41421  0.0      2.31607  2.31607  3.08077  3.08077  3.08077  3.08077\n 2.31607  2.31607  0.0      1.41421  3.08077  3.08077  3.08077  3.08077\n 2.31607  2.31607  1.41421  0.0      3.08077  3.08077  3.08077  3.08077\n 3.08077  3.08077  3.08077  3.08077  0.0      1.41421  2.31607  2.31607\n 3.08077  3.08077  3.08077  3.08077  1.41421  0.0      2.31607  2.31607\n 3.08077  3.08077  3.08077  3.08077  2.31607  2.31607  0.0      1.41421\n 3.08077  3.08077  3.08077  3.08077  2.31607  2.31607  1.41421  0.0\n\n\n\nntree = SpectralInference.newickstring(UPGMA_tree(dij), string.('a':'h'))\n\n\"(((d:1.414214e+00,c:1.414214e+00):9.018605e-01,(b:1.414214e+00,a:1.414214e+00):9.018605e-01):7.646942e-01,((e:1.414214e+00,f:1.414214e+00):9.018605e-01,(h:1.414214e+00,g:1.414214e+00):9.018605e-01):7.646942e-01):0.000000e+00;\"\n\n\n\nplot(readnw(ntree))\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# unrooted but same topology\nntree = NeighborJoining.newickstring(regNJ(dij), string.('a':'h'))\n\n\"(((b:7.071068e-01,a:7.071068e-01):4.509302e-01,((f:7.071068e-01,e:7.071068e-01):4.509302e-01,(h:7.071068e-01,g:7.071068e-01):4.509302e-01):7.646942e-01):2.254651e-01,(d:7.071068e-01,c:7.071068e-01):2.254651e-01):0.000000e+00;\"\n\n\n\nplot(readnw(ntree))\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nStandard phylogenetic tools\n\nusing Goalign_jll\nusing Gotree_jll\ntoyMSA_8x14_dir = datadir(\"sims\", \"toyMSA_8x14\") |&gt; mkpath\n\n# write out alignment\nwritephylip(\n    joinpath(toyMSA_8x14_dir, \"MSA.phylip\"),\n    join.(eachrow((replace(M, 0.0 =&gt; 'A', 1.0 =&gt; 'T')))),\n    collect('a':'h')\n)\n\n\n# FastME\nrun(`julia $(projectdir(\"scripts\", \"runners\", \"runFastME.jl\")) \n    -i $(datadir(\"sims\", \"toyMSA_8x14\", \"MSA.phylip\"))\n    -o $(projectdir(\"_research\", \"toyMSA_8x14\", \"FastME\"))\n    -m JC69\n`)\n# PhyML\nrun(`julia $(projectdir(\"scripts\", \"runners\", \"runPhyML.jl\")) \n    -i $(datadir(\"sims\", \"toyMSA_8x14\", \"MSA.phylip\"))\n    -o $(projectdir(\"_research\", \"toyMSA_8x14\", \"PhyML\"))\n    -m JC69\n`)\n# # RAxML (needs intel chip)\n# run(`julia $(projectdir(\"scripts\", \"runners\", \"runRAxML.jl\")) \n#     -i $(datadir(\"sims\", \"toyMSA_8x14\", \"MSA.phylip\"))\n#     -o $(projectdir(\"_research\", \"toyMSA_8x14\", \"RAxML\"))\n#     -m JC69\n# `)\n# MrBayes\nrun(`julia $(projectdir(\"scripts\", \"runners\", \"runMrBayes.jl\")) \n    -i $(datadir(\"sims\", \"toyMSA_8x14\", \"MSA.phylip\"))\n    -o $(projectdir(\"_research\", \"toyMSA_8x14\", \"MrBayes\"))\n    -m JC69\n`);\n# SpectralInference\nrun(`julia $(projectdir(\"scripts\", \"runners\", \"runSPI.jl\")) \n    -i $(datadir(\"sims\", \"toyMSA_8x14\", \"MSA.phylip\"))\n    -o $(projectdir(\"_research\", \"toyMSA_8x14\", \"SPI\"))\n    -m JC69\n`);\n\n  Activating project at `~/projects/Doran_etal_2023`\n  Activating project at `~/projects/Doran_etal_2023`\n  Activating project at `~/projects/Doran_etal_2023`\n  Activating project at `~/projects/Doran_etal_2023`\n\n\n[ Info: Starting FastME on MSA\n[ Info: using Booster to compute support values\n[ Info: stopping run\n ──────────────────────────────────────────────────────────────────────\n                              Time                    Allocations      \n                     ───────────────────────   ────────────────────────\n  Tot / % measured:       768ms /  90.5%           51.6MiB /  89.7%    \n\n Section     ncalls     time    %tot     avg     alloc    %tot      avg\n ──────────────────────────────────────────────────────────────────────\n total            1    695ms  100.0%   695ms   46.3MiB  100.0%  46.3MiB\n   booster        1    432ms   62.2%   432ms   1.16MiB    2.5%  1.16MiB\n   FastME         1    136ms   19.5%   136ms   3.29MiB    7.1%  3.29MiB\n ──────────────────────────────────────────────────────────────────────\n┌ Info: timing\n│   show(time) = nothing\n└   println(\"\") = nothing\n[ Info: Starting PhyML on MSA\n[ Info: stopping run\n ────────────────────────────────────────────────────────────────────\n                            Time                    Allocations      \n                   ───────────────────────   ────────────────────────\n Tot / % measured:      318ms /  86.5%           50.1MiB /  89.4%    \n\n Section   ncalls     time    %tot     avg     alloc    %tot      avg\n ────────────────────────────────────────────────────────────────────\n total          1    275ms  100.0%   275ms   44.8MiB  100.0%  44.8MiB\n   PhyML        1    151ms   55.1%   151ms   2.97MiB    6.6%  2.97MiB\n ────────────────────────────────────────────────────────────────────\n┌ Info: timing\n│   show(time) = nothing\n└   println(\"\") = nothing\n[ Info: Converting input to nexus format\n[ Info: changing dir to: /Users/bend/projects/Doran_etal_2023/_research/toyMSA_8x14/MrBayes\n[ Info: changing dir to: /Users/bend/projects/Doran_etal_2023/notebooks\n[ Info: stopping run\n ────────────────────────────────────────────────────────────────────────────────\n                                        Time                    Allocations      \n                               ───────────────────────   ────────────────────────\n       Tot / % measured:            12.7s /  99.6%           63.3MiB /  91.6%    \n\n Section               ncalls     time    %tot     avg     alloc    %tot      avg\n ────────────────────────────────────────────────────────────────────────────────\n total                      1    12.7s  100.0%   12.7s   58.0MiB  100.0%  58.0MiB\n   mrbayes                  1    12.3s   96.9%   12.3s   12.4MiB   21.3%  12.4MiB\n   convert input to...      1    245ms    1.9%   245ms   2.66MiB    4.6%  2.66MiB\n   convert tree file        1   24.3ms    0.2%  24.3ms   1.17MiB    2.0%  1.17MiB\n ────────────────────────────────────────────────────────────────────────────────\n┌ Info: timing\n│   show(time) = nothing\n└   println(\"\") = nothing\n[ Info: Starting SPI inference\n[ Info: Setting up workspace\n[ Info: Running SPI\n[ Info: Writing out SPI Tree\n[ Info: Starting Bootstrap with 100\n[ Info: Writing out Bootstrap trees\n[ Info: using Booster to compute support values\n[ Info: Finishing run\n ────────────────────────────────────────────────────────────────────────────────\n                                        Time                    Allocations      \n                               ───────────────────────   ────────────────────────\n       Tot / % measured:            1.61s /  96.1%            289MiB /  98.0%    \n\n Section               ncalls     time    %tot     avg     alloc    %tot      avg\n ────────────────────────────────────────────────────────────────────────────────\n total                      1    1.55s  100.0%   1.55s    283MiB  100.0%   283MiB\n   running SPI              1    889ms   57.5%   889ms    169MiB   59.5%   169MiB\n   running bootstra...      1    169ms   10.9%   169ms   60.9MiB   21.5%  60.9MiB\n ────────────────────────────────────────────────────────────────────────────────\n┌ Info: \n│ timing\n│   show(time) = nothing\n└   println(\"\") = nothing\n\n\n\npdir_toyMSA_8x14 = plotsdir(\"toyMSA_8x14\") |&gt; mkpath\n\n\"/Users/bend/projects/Doran_etal_2023/plots/toyMSA_8x14\"\n\n\nIn the tree plots below, only branches with an orange dot are statistically supported\n\nmethod = \"FastME\"\nrun(pipeline(`$(gotree()) draw svg -c -w 400 -H 400 --support-cutoff .5 --with-branch-support`,\n    stdin=projectdir(\"_research\", \"toyMSA_8x14\", method, \"MSA-supporttree.nw\"),\n    stdout=joinpath(pdir_toyMSA_8x14, method * \".svg\")\n))\nshow_svg(joinpath(pdir_toyMSA_8x14, method * \".svg\"))\n\n\n\n\n\nmethod = \"PhyML\"\nrun(pipeline(`$(gotree()) draw svg -c -w 400 -H 400 --support-cutoff .5 --with-branch-support`,\n    stdin=projectdir(\"_research\", \"toyMSA_8x14\", method, \"MSA.phylip-supporttree.txt\"),\n    stdout=joinpath(pdir_toyMSA_8x14, method * \".svg\")\n))\nshow_svg(joinpath(pdir_toyMSA_8x14, method * \".svg\"))\n\n\n\n\n\nmethod = \"RAxML\"\nrun(pipeline(`$(gotree()) draw svg -c -w 400 -H 400 --support-cutoff .5 --with-branch-support`,\n    stdin=projectdir(\"_research\", \"toyMSA_8x14\", method, \"$method-supporttree.nw\"),\n    stdout=joinpath(pdir_toyMSA_8x14, method * \".svg\")\n))\nshow_svg(joinpath(pdir_toyMSA_8x14, method * \".svg\"))\n\n\n\n\n\nmethod = \"MrBayes\"\nrun(pipeline(`$(gotree()) draw svg -c -w 400 -H 400 --support-cutoff .5 --with-branch-support`,\n    stdin=projectdir(\"_research\", \"toyMSA_8x14\", method, \"MSA-supporttree.nw\"),\n    stdout=joinpath(pdir_toyMSA_8x14, method * \".svg\")\n))\nshow_svg(joinpath(pdir_toyMSA_8x14, method * \".svg\"))\n\n\n\n\n\nmethod = \"SPI\"\nrun(pipeline(`$(gotree()) draw svg -c -w 400 -H 400 --support-cutoff .5 --with-branch-support`,\n    stdin=projectdir(\"_research\", \"toyMSA_8x14\", method, \"MSA-supporttree.nw\"),\n    stdout=joinpath(pdir_toyMSA_8x14, method * \".svg\")\n))\nshow_svg(joinpath(pdir_toyMSA_8x14, method * \".svg\"))"
  },
  {
    "objectID": "02_figure_02supp.html#understanding-svd-math",
    "href": "02_figure_02supp.html#understanding-svd-math",
    "title": "Spectral Tree Theory",
    "section": "Understanding SVD math",
    "text": "Understanding SVD math\n\nHow similarity and dissimilarity are encoded into spectral components\nWe sought to understand the mathematics of why spectral factorization reveals hierarchical scales of relatedness. In answer, we found it is because the similarity and differences between sub-populations are split across separate spectral components. Specifically, we show that (i) an ensemble of systems with two sub-populations will have exactly 2 irreducible spectral components up to the exact point at which those populations become identical; (ii) the change in magnitude for these spectral components — their eigenvalues — are equal and opposite to each other as we increase the degree of relatedness between the sub-populations; and (iii) the major eigenvector encodes the similarity of the sub-populations and the lesser eigenvector encodes the sub-population’s dissimilarity for all points between the extrema where the sub-populations are identical or completely independent.\nAs it is not guaranteed that the reader has a background in the required mathematics, we will split this section into two parts. Section §4.1 will delve into the necessary detail regarding eigenvalue decomposition, the determinant, and the characteristic polynomial for readers to understand the connections between these concepts. Section §4.2 will detail a specific case of an ensemble of 3 systems, and show how changing the degree of relatedness between these systems changes specific aspects of the eigenspectrum.\n\n\nLinear Algebra Background\n\nWhat are eigenvectors?\nFor readers unfamiliar with linear algebra, some of the early applications for eigen decomposition in the 1700s were developed to describe the linear transformations of physical systems (rotations, shifting, scaling, and shearing of rigid bodies) 1. Of particular interest in these descriptions are the principle axes or “eigenvectors” of the transformation which are the only vectors that do not change direction during the transform. The eigenspectrum describes the complete set of axes “eigenvectors”, and is defined as the non-zero solutions to this equation\n\\[\nC\\vec{v} = \\lambda\\vec{v}\n\\tag{1}\\]\nIn Equation 1, \\(C\\) is the linear transformation, represented as a matrix of real numbers; \\(\\vec{v}\\) is the eigenvector, represented as a list of real numbers; and \\(\\lambda\\) is the eigenvalue, a real number that shortens or lengthens the eigen vector.\n\n\n\n\n\n\nNote\n\n\n\n\n\nAs an example, this is one specific case of Equation 1.\n\\[\n\\begin{bmatrix}2&0\\\\0&2\\end{bmatrix}\\begin{bmatrix}1\\\\1\\end{bmatrix} = 2\\begin{bmatrix}1\\\\1\\end{bmatrix}\n\\]\nWe can see in performing the matrix multiplications that both of these expressions are equal to the vector \\([2,2]^t\\)\n\\[\n\\begin{align}\n\\begin{bmatrix}2&0\\\\0&2\\end{bmatrix}\\begin{bmatrix}v_1\\\\v_2\\end{bmatrix} &= \\begin{bmatrix}(2\\times v_1) + (0\\times v_2)\\\\(0\\times v_1)+(2\\times v_2)\\end{bmatrix} \\\\\n&= \\begin{bmatrix}(2\\times 1) + (0\\times1)\\\\(0\\times1)+(2\\times1)\\end{bmatrix} \\\\\n& = \\begin{bmatrix}2\\\\2\\end{bmatrix} \\\\\n&= 2\\begin{bmatrix}1\\\\1\\end{bmatrix}\n\\end{align}\n\\]\n\n\n\nThe eigenvectors and eigenvalues are useful precisely because they are the only stable descriptors of the transformation and can be used to consistently describe positions both before and after the transform.\nTo mathematically solve for these eigenvectors, one common technique is to first find the eigenvalues which are the solutions to Equation 2, and then substitute these eigenvalues into Equation 1 and solve for each of the eigenvectors (\\(\\vec{v}\\)). All applications of spectral factorization (i.e. SVD and PCA) use this fundamental equation to define their spectral components (‘eigenvectors’).\n\\[\n\\det(C - \\lambda I) = 0\n\\tag{2}\\]\nIn Equation 2, \\(C\\) is again the linear transformation; \\(I\\) is the identity matrix of the same size as \\(C\\), defined as having \\(1\\)s along the diagonal and \\(0\\) for all other entries; \\(det()\\) is the determinant function which describes a change in the degrees of freedom or number of dimensions after a linear transformation; and \\(\\lambda\\) is the variable that we are trying to infer (i.e., \\(\\lambda\\) equals the eigenvalue when Equation 2 is true).\nAs we will see, Equation 2 can also be expressed as the “characteristic polynomial” of the transform.\n\\[\n\\det(\\lambda I - C_{n\\times n}) = \\lambda^n - c_{n-1}\\lambda^{n-1} + c_{n-2}\\lambda^{n-2}  - c_{n-3}\\lambda^{n-3}... = 0\n\\tag{3}\\]\nThe characteristic polynomial is a monic alternating sign polynomial of degree \\(n\\) where \\(n\\) is the minimum dimension of \\(C\\). A monic polynomial means that the leading coefficient is always equal to \\(1\\). And alternating sign means that the sign of each subsequent term alternates in sign from \\(+\\) to \\(-\\) and back. The roots of this polynomial, (i.e., the values of \\(\\lambda\\) that set it equal to zero) are the eigenvalues of Equation 2.\n\n\n\n\n\n\nNote\n\n\n\n\n\nNote the change from \\(\\det(C - \\lambda I)\\) in Equation 2 to \\(\\det(\\lambda I - C)\\) in Equation 3.\nThis factor of \\(-1\\) ensures that the characteristic polynomial is always expressed with a positive leading coefficient. The definition in Equation 2, \\(\\det(C - \\lambda I)\\) has a negative leading coefficient for any matrix \\(C\\) with an odd number of rows and columns.\nIt can be awkward to display the expansion of \\(\\det(\\lambda I - C)\\), so we forgo showing the \\(-1\\) factor in this document until the last step to finish with the canonical form of the characteristic polynomial.\n\n\n\n\n\nRational for using \\(\\det(C-\\lambda I) = 0\\)\nTo fully intuit the logic behind for using the equation \\(\\det(C-\\lambda I) = 0\\) to solve for eigenvalues, it will help to review how matrices in linear algebra describe transformation of space.\nIf we multiply a vector \\(\\vec{u}\\) by a matrix \\(C\\) we will get a new vector that may be pointing in a new direction \\(\\vec{v}\\).\n\\[\nC\\vec{u} = \\vec{v}\n\\]\nTo reiterate, there are special vectors for each matrix \\(C\\) that do not change direction after the transformation – \\(C\\vec{v} = \\lambda\\vec{v}\\). Instead they only change in magnitude. These are exactly the eigenvectors of the matrix, and the magnitude (length of the vector) \\(\\lambda\\) is the eigenvalue. These eigenvectors and values are particularly important for describing the transformation and describing how points move through the transformation because they are the only stable axes during the transformation.\n\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1: example of linear transformation on regular vector (left) versus an eigen vector of that transformation (right)\n\n\n\nTo solve for the eigenvectors we can do some algebraic manipulations to factor out \\(\\vec{v}\\) within Equation 1\n\\[\n\\begin{align}\n    C\\vec{v} &=  \\lambda\\vec{v} \\\\\n    C\\vec{v} - \\lambda\\vec{v} &= 0 \\\\\n    C\\vec{v} - \\lambda I \\vec{v} &= 0 \\\\\n    (C - \\lambda I )\\vec{v} &= 0 \\\\\n\\end{align}\n\\]\nAfter these manipulations we have the eigenvector \\(\\vec{v}\\) multiplied by \\((C - \\lambda I)\\) a matrix of our original transform \\(C\\) subtracting out the eigenvalue on the diagonal.\n\n\n\n\n\n\nNote\n\n\n\n\n\nExpanding at this stage would show this form:\n\\[\n    (C - \\lambda I)\\vec{v} = \\begin{bmatrix}\n    c_{1,1} - \\lambda&\\cdots&c_{1,n} \\\\\n    \\vdots&\\ddots&\\vdots \\\\\n    c_{n,1}&\\cdots&c_{n,n}- \\lambda\\\\\n    \\end{bmatrix} \\begin{bmatrix}v_1\\\\\\vdots\\\\v_n\\end{bmatrix} = 0\n\\]\n\n\n\nNotice that making \\(\\vec{v}\\) equal to the zero vector is a trivial solution for all matrices. Because this solution is true for all matrices, eigenvectors are generally defined as only the non-zero solutions to Equation 1.\nSo when is \\(\\vec{v}\\) non-zero, and yet multiplying by \\((C - \\lambda I)\\) results in zero? Our prior manipulations were useful for answering this question because they let us play a quick thought experiment. Lets take a moment to assume that \\((C - \\lambda I)\\) is invertible. Invertible means that there exists some matrix \\((C - \\lambda I)^{-1}\\) that would completely reverse the transformation and place every vector back where it started, (i.e., the transformation matrix is canceled by its inverse transformation). So \\((C - \\lambda I)^{-1}(C - \\lambda I) = I\\) the identity matrix because for any matrix \\(\\cancel{A^{-1}A}\\vec{v} = I\\vec{v} = \\vec{v}\\).\nIf we place this inverse into the eigenvector equation from before we see that if \\((C - \\lambda I)\\) is invertible than \\(\\vec{v}\\) must equal the zero vector.\n\\[\n\\begin{align}\n        (C - \\lambda I)\\vec{v} &= 0 \\\\\n        (C - \\lambda I)^{-1} (C - \\lambda I)\\vec{v} &= (C - \\lambda I)^{-1}0 \\\\\n    I\\vec{v} &= 0 \\\\\n    \\vec{v} &= 0 \\\\\n\\end{align}\n\\]\nFrom this thought experiment we see that for \\(\\vec{v}\\) to be non-zero \\((C - \\lambda I)\\) must be non-invertible. A matrix being non-invertible essentially means that at least 2 vectors are placed in the same location after the transformation \\(A\\vec{u} = A\\vec{w}\\). In geometric terms, we can think of this as an reduction in dimensionality; a line being compressed into a single point, a plane being compressed into a line or point.\nWe can then interpret our search for eigenvalues as searching for intrinsic scales of dimensionality. We can expand a sphere from the origin and at particular radii we are canceling out dimensional axes, i.e. for particular values of \\(\\lambda\\) we are subtracting the full magnitude of a principal axis in our observed data which flattens all observations along that axis to zero.\nThe determinant function is how we measure this collapse of dimensionality. In the 2 dimensional case,the geometric interpretation behind the determinant is that it measures the area of the unit square after a transformation by matrix \\(C\\). If the transform \\(C\\) compresses all the points in the area of the unit square onto a single line or point, (a) the area of the unit square after the transform equals zero \\(\\det(C)=0\\), (b) this transform is not invertible. The transform is not invertible because multiple points are moved onto the same coordinate by the transform, and so to move every point back to its original location would require information lost by the transform. The determinant is used for finding eigenvalues because it is the exact measure of when a transform is non-invertible (i.e. has a loss of dimensionality).\n\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 2: example of unit square after different linear transforms. The last case (right) shows example of the 2d plane being compressed to a single line at which point the determinant equals zero\n\n\n\n\n\n\nThe determinant defined\nAnalytically, the determinant of a 2 x 2 matrix is defined as:\n\\[\n\\det{\\begin{pmatrix} a & b \\\\ c & d \\end{pmatrix}} = \\begin{vmatrix} a & b \\\\ c & d \\end{vmatrix} = ad - bc\n\\]\nAnd it is defined recursively for larger matrices.\n\\[\n\\det(C_{n\\times n}) = \\sum_{j=1}^n \\sigma_j C_{1,j} \\det(C_{-1, -j})\n\\tag{4}\\]\nwhere \\(\\sigma_j\\) is defined as \\(+1\\) if \\(j\\) is odd and \\(-1\\) if \\(j\\) is even; \\(C_{-1, -i}\\) is an \\(n-1 \\times n-1\\) matrix made by removing the first row and \\(j\\)th column.\nFor example, here is the first layer of recursion for a 3 x 3 matrix, which is defined as an alternating sum of 2 x 2 determinants weighted by each complementary element of the top row.\n\\[\n\\left|\\begin{array}{ccc}\n    a & b & c \\\\\n    d & e & f \\\\\n    g & h & i \\\\\n\\end{array}\\right| \\\\\n= a\\left|\\begin{array}{cc}e&f\\\\h&i\\end{array}\\right| -\n    b\\left|\\begin{array}{cc}d&f\\\\g&i\\end{array}\\right| +\n    c\\left|\\begin{array}{cc}d&e\\\\g&h\\end{array}\\right|\n\\]\nExpanded fully, the determinant forms a sum of \\(n\\) factorial (\\(n!\\)) products where \\(n\\) is the number of columns in the matrix.\n\\[\naei - afh - bdi + bfg + cdh - ceg\n\\]\n\n\nThe relationship between determinant and characteristic polynomial\nWhen all elements of the matrix are known, this sum of products collapses down to a single number: the result of the determinant. When there is an unknown variable in the matrix, like with with our eigenvalue problem in Equation 2, the determinant instead collapses to a polynomial of the unknown variable. This polynomial is the characteristic polynomial of the matrix.\nAs we can show with a 3x3 example:\n\\[\n\\begin{align}\n0 &= \\det(C - \\lambda I) \\\\\n&= \\left|\\begin{array}{ccc}\n    a - \\lambda & b & c \\\\\n    d & e - \\lambda & f \\\\\n    g & h & i - \\lambda \\\\\n\\end{array}\\right| \\\\\n&= (a - \\lambda)\\left|\\begin{array}{cc}e - \\lambda&f\\\\h&i - \\lambda\\end{array}\\right| -\n    b\\left|\\begin{array}{cc}d&f\\\\g&i - \\lambda\\end{array}\\right| +\n    c\\left|\\begin{array}{cc}d&e - \\lambda\\\\g&h\\end{array}\\right|\n\\end{align}\n\\]\nWhen expanded into the alternating sum of \\(n!\\) terms we see that some of these terms have more instances of \\(\\lambda\\) than others\n\\[\n(a - \\lambda)(e - \\lambda)(i - \\lambda) - (a - \\lambda)fh - bd(i - \\lambda) + bfg + cdh - c(e - \\lambda)g\n\\]\nWe can sort by the number of instances of \\(\\lambda\\)\n\\[\n(a - \\lambda)(e - \\lambda)(i - \\lambda) - fh(a - \\lambda) - bd(i - \\lambda) - cg(e - \\lambda) + bfg + cdh\n\\]\nTo continue, let’s make this more specific and take it term by term.\nFor this example we will use the matrix\n\\[\nC = \\begin{bmatrix}1&1&1\\\\1&1&1\\\\1&1&1\\end{bmatrix}\n\\]\nSo for this first term we can expand\n\\[\n\\begin{align}\n(a - \\lambda)(e - \\lambda)(i - \\lambda) &= (1 - \\lambda)(1 - \\lambda)(1 - \\lambda) \\\\\n&= -\\lambda^3 + 3\\lambda^2 - 3\\lambda + 1\n\\end{align}\n\\]\nfor the second, third, and fourth terms we get\n\\[\n\\begin{align}\n-fh(a - \\lambda) &= \\\\\n-bd(i - \\lambda) &= \\\\\n-cg(e - \\lambda) &= \\\\\n-(1\\times 1)(1 - \\lambda) &= \\lambda - 1\n\\end{align}\n\\]\nand our fifth and sixth terms both equal \\(+1\\).\n\\[bfg = cdh = 1\\cdot 1 \\cdot 1 =  1\\]\nPutting them together we get\n\\[\n\\begin{align}\n&(-\\lambda^3 + 3\\lambda^2 - 3\\lambda + 1) + (\\lambda - 1) + (\\lambda - 1) + (\\lambda - 1) + 1 + 1  \\\\\n&= -\\lambda^3 + 3\\lambda^2 - 3\\lambda + \\lambda + \\lambda + \\lambda - 1 - 1 - 1 + 1 + 1 + 1 \\\\\n&= -\\lambda^3 + 3\\lambda^2 - 3\\lambda + 3\\lambda + 3 - 3 \\\\\n&= -\\lambda^3 + 3\\lambda^2\n\\end{align}\n\\]\nTo finish, we multiply by -1 to get the canonical form of the characteristic polynomial because the characteristic polynomial is technically defined by \\(\\det(\\lambda I - C )\\) rather than \\(\\det(C - \\lambda I)\\)\n\\[\n\\det(\\lambda I - C) = \\lambda^3 - 3\\lambda^2 \\text{ when } C = \\begin{bmatrix}1&1&1\\\\1&1&1\\\\1&1&1\\end{bmatrix}\n\\]\nWhat we have described so far is that (i) eigenvectors are the stable principal axes of linear transformations; (ii) The determinant is used to solve for eigenvalues (and by proxy eigenvectors) because it measures when a principal axis (i.e., eigenvector) has been collapsed to zero and canceled out; (iii) the the eigenvalue problem in Equation 2 can be equivalently represented by the characteristic polynomial simply by expanding the determinant of a matrix with an unknown variable.\n\n\nThe eigenspectrum and singular value decomposition\nThis section has so far discussed how to find an individual eigenvector-eigenvalue pair (‘spectral component’). But it is important to remember that the original transform \\(C\\) is made up of the set of all spectral components. This concept is important for understanding how spectral factorization can describe data and physical observations rather than abstract linear transforms. Specifically, the full set of spectral components allows us to factor any arbitrary matrix into separate components of information.\nTo show this factorization, we start with the transform \\(C\\) and right multiply by its collection of eigenvectors \\(V\\) this has the effect of scaling each eigenvector by it’s associated eigenvalue. contained in matrix \\(\\Lambda\\) with each \\(\\lambda_i\\) on the diagonal. (this is exactly because these are the vectors that do not change direction and are only scaled by the transform.)\n\\[\nCV = V\\Lambda\n\\]\nBecause the collection of eigenvectors are a set of linearly independent unitary vectors (each vector has a length of \\(1\\) and is pointed in a mutually orthogonal direction – at right angle – to all other eigenvectors), we know that \\(V\\) has an inverse and that inverse is its transpose \\(VV^{-1} = VV^{t} = V^{t}V = I\\)\nSo\n\\[\nC = V\\Lambda V^t\n\\]\nThis equation tells us how to recreate our linear transform from its set of spectral components. More explicitly expanding this matrix multiplication, the transform \\(C\\) can be equivalently expressed as the sum\n\\[\nC = V\\Lambda V^t = \\sum_i \\lambda_i v_i v_i^t\n\\]\nHere \\(\\lambda_i v_i\\) is the \\(i\\)th scaled eigenvector and \\(v_i^t\\) is its transpose. The multiplication \\(\\lambda_i v_i v_i^t\\) tells us is how each original axis (usually measured traits) in \\(v_i^t\\) gets transformed by – projected onto – this spectral component \\(lambda_i v_i\\). It results in a matrix the same size as the original transform \\(C\\) and is called a rank 1 transform because it is composed of only a single vector. This representation emphasizes that each spectral component is describing one layer of information about the original matrix \\(C\\). Taken together the full set of spectral components completely recapitulates the original matrix.\nLet us now introduce the singular value decomposition (SVD). The SVD is an extension of eigen decomposition for non-square matrices. And allows the factorization of any matrix into 3 new matrices; \\(U\\) the left singular vectors; \\(\\Sigma\\) a matrix with the singular values along the diagonal; and \\(V^t\\) the transposed right singular vectors.\n\\[\nM = U\\Sigma V^t\n\\tag{5}\\]\nTo briefly see the relation to the eigen decomposition we can write\n\\[\n\\begin{align}\nMM^t &= U\\Sigma V^t V \\Sigma U^t \\\\\nMM^t &= U\\Sigma \\cancel{V^t V} \\Sigma U^t \\\\\nMM^t &= U\\Sigma^2 U^t \\\\\n\\end{align}\n\\]\nwhere \\(MM^t\\) is a matrix times its transpose – for scaled and centered matrices this is equivalent to the row-wise covariance matrix; \\(U\\) is both the left singular vectors of \\(M\\) and the eigenvectors of \\(MM^t\\); and \\(\\Sigma\\) is a matrix with the singular values on the diagonal elements and \\(\\Sigma^2\\) are the eigenvalues of \\(MM^t\\).\n\n\n\n\n\n\nNote\n\n\n\nCovariance is the same as a matrix multiplication when a matrix is scaled and centered on the origin\nmatrix multiplication of \\(X\\) with \\(i\\) rows and \\(n\\) columns and \\(Y\\) with \\(n\\) rows and \\(j\\) columns\n\\[\nXY = \\begin{bmatrix}\n\\sum_n x_{1n}y_{n1} & \\cdots & \\sum_n x_{1n}y_{nj} \\\\\n\\vdots & \\ddots & \\vdots \\\\\n\\sum_n x_{in}y_{n1} & \\cdots & \\sum_n x_{in}y_{nj} \\\\\n\\end{bmatrix} \\\\\n\\]\nFor each element in the resulting matrix we can get to the covariance by scaling by the number of measurements \\(\\frac{1}{n}\\) and subtracting each mean \\(\\bar{x}\\) and \\(\\bar{y}\\).\n\\[\nX_iY_j = \\sum_{i=n}^n(x_{in})(y_{jn})\n\\rightarrow \\frac{1}{n}\\sum_{i=n}^n(x_{in} - \\bar{x})(y_{jn} - \\bar{y})\n=\\text{cov}(X_i, Y_j)\n\\]\n\n\n\n\nHow relatedness affects the eigenspectrum\n\nCreating an ensemble of systems with varying degrees of relatedness\nIn this section we will use the concepts relating the eigenspectrum, the determinant, and the characteristic polynomial to show how the eigenspectrum changes as we increase the relatedness between systems. We purposefully use the term “system” because it is general and no property discussed is specifically tied to particular scale or field of physical science. However, to aid intuition we will pose the initial cases in terms of evolutionary history and genetics.\nA system in this case represents a biological organism that can be described in terms of genetic traits. For simplicity we can simulate an organism’s genome with a vector of \\(1\\)’s and \\(0\\)’s, where a \\(1\\) represents the presence of a genetic trait and a \\(0\\) represents the absence. For example organism \\(a\\) can be represented as\n\\[\na = \\begin{bmatrix}1&1&1&0&0&0\\end{bmatrix}\n\\]\nwhere organism \\(a\\) possesses the first three genetic traits and lacks the last 3.\nLikewise, an ensemble of systems or a population of organisms can be represented as a binary matrix where rows represent each organism and each column represents a particular genetic trait. for example\n\\[\n\\begin{bmatrix}c\\\\b\\\\a\\end{bmatrix} = \\begin{bmatrix}1&1&1&0&0&0\\\\1&1&1&0&0&0\\\\1&1&1&0&0&0\\end{bmatrix} = M_{similar}\n\\]\nIn this example organisms \\(a\\), \\(b\\), and \\(c\\) are all clones of each other they share the presence of the first 3 genetic traits and the absence of the last 3 genetic traits. This is a case of the ensemble or population being identical or “similar” to each other.\nAt the other extreme we could find an ensemble like this\n\\[\n\\begin{bmatrix}c\\\\b\\\\a\\end{bmatrix} = \\begin{bmatrix}0&0&0&1&1&1\\\\1&1&1&0&0&0\\\\1&1&1&0&0&0\\end{bmatrix} =  M_{modular}\n\\]\nHere the full ensemble is split into two sub-populations with no shared genetic traits between \\(c\\) and \\(\\{a, b\\}\\). This is a ‘modular’ case in the sense that these two sub-populations are completely disconnected in terms of shared information. The descriptors of one sub-population are completely orthogonal to the other; the two populations tell us nothing about each other.\nThe most common case for biological population is somewhere between these two extremes. We may find some organisms that are quite similar, along with other organisms that are more distantly related but still share some genetic traits\n\\[\n\\begin{bmatrix}c\\\\b\\\\a\\end{bmatrix} = \\begin{bmatrix}0&0&0&1&1&1\\\\1&1&0&0&0&1\\\\1&1&0&0&0&1\\end{bmatrix} =  M_{related}\n\\]\nOur questions are how does the eigenspectrum change as we adjust the degree of relatedness between systems in the ensemble, and where does the information about that relatedness fall in the eigenspectrum.\nTo calculate the eigenspectrum of each ensemble we first calculate the matrix \\(MM^t\\). The matrix \\(MM^t\\) is a square similarity matrix between each pair of organisms, or more generally between each pair of rows of \\(M\\). This is the standard first step toward calculating the SVD and recall from section §4.1.5 it is how we can calculate the eigenspectrum of rectangular matrices.\nWe calculate the similarity matrices for each of the degrees of relatedness.\n\\[\n\\begin{align*}\nM_{similar} &= \\begin{bmatrix}3&3&3\\\\3&3&3\\\\3&3&3\\\\\\end{bmatrix} \\\\\nM_{related} &= \\begin{bmatrix}3&1&1\\\\1&3&3\\\\1&3&3\\\\\\end{bmatrix} \\\\\nM_{modular} &= \\begin{bmatrix}3&0&0\\\\0&3&3\\\\0&3&3\\\\\\end{bmatrix} \\\\\n\\end{align*}\n\\]\nHere, each number in the matrix represents the number of shared genetic traits between each pair of organisms. And, note how the only numbers that change are between \\(c\\) (top) and \\(\\{a, b\\}\\) (bottom, middle respectively). Because of this isolation, we can easily parameterize this changing degree of relatedness as the variable gamma \\(\\gamma\\), which we can smoothly vary to understand the changes in the eigenspectrum.\nSpecifically, we are first interested in the changes to this equation with respect to \\(\\gamma\\)\n\\[\n\\det\\left(\\begin{bmatrix}\n    \\langle c|c \\rangle-\\lambda&\\gamma&\\gamma\\\\\n    \\gamma&\\langle b|b \\rangle-\\lambda&s\\\\\n    \\gamma&s&\\langle a|a \\rangle-\\lambda\\\\\n    \\end{bmatrix}\\right) = 0\n\\tag{6}\\]\nwhere, \\(\\langle c|c \\rangle\\) is the self similarity of organism \\(c\\) with itself. In our cases \\(c\\) shares \\(3\\) genetic traits with itself so \\(\\langle c|c \\rangle = 3\\). Likewise, \\(\\langle a|a\\rangle = \\langle b|b\\rangle = s = 3\\). We are using these variables help track which pairs of organisms contribute to the terms in the determinant and coefficients of the characteristic polynomial.\n\n\nHow do the eigenvalues change in response to a changing degree of relatedness?\nWe sought to understand how the magnitudes of the eigenvalues are dependent on the degree of relatedness between sub-populations of systems.\nTo start, we inserted our example’s variables into the first layer of the expanded determinant.\n\\[\n\\begin{align*}\n(\\langle c|c \\rangle-\\lambda)\\left|\\begin{array}{cc}(\\langle b|b \\rangle- \\lambda)&s\\\\ s&(\\langle a|a \\rangle-\\lambda)\\end{array}\\right| -\n    \\gamma\\left|\\begin{array}{cc}\\gamma&s\\\\\\gamma&(\\langle a|a \\rangle-\\lambda)\\end{array}\\right| +\n    \\gamma\\left|\\begin{array}{cc}\\gamma&(\\langle b|b \\rangle-\\lambda)\\\\\\gamma&s\\end{array}\\right|\n\\end{align*}\n\\]\nNote how if \\(\\gamma=0\\), all the terms that compare the similarity of \\(c\\) to \\(\\{a, b\\}\\) are zeroed out, and the only remaining first term corresponds specifically to the similarity of \\(c\\) onto itself and separately the determinant of \\(a\\) and \\(b\\). Also note, how the \\(\\gamma\\) variable is only in terms with a single \\(\\lambda\\). What this means is that the only term in the resulting characteristic polynomial dependent on \\(\\gamma\\) is the first order term of \\(\\lambda\\).\nExpanded and simplified we find that the characteristic polynomial including \\(\\gamma\\) is\n\\[\n\\lambda^3 - 9\\lambda^2 + (18 - 2\\gamma^2)\\lambda\n\\]\nwhich is indeed only dependent on \\(\\gamma\\) in the first order term of \\(\\lambda\\).\nSubstituting in and varying values of \\(\\gamma\\), i.e., varying the degree of relatedness gives us different instances of the characteristic polynomial.\n\nModular (\\(\\gamma = 0\\)): \\(\\lambda^3 - 9\\lambda^2 + 18\\lambda\\)\nRelated (\\(\\gamma = 1\\)): \\(\\lambda^3 - 9\\lambda^2 + 16\\lambda\\)\nRelated (\\(\\gamma = 2\\)): \\(\\lambda^3 - 9\\lambda^2 + 10\\lambda\\)\nSimilar (\\(\\gamma = 3\\)): \\(\\lambda^3 - 9\\lambda^2\\)\n\nWe note a trend in the first order term of \\(\\lambda\\); as the sub-populations become more related the first order coefficient in the polynomial gets closer and closer to zero. Once the sub-populations are identical the first order coefficient equals zero.\nHow does this changing coefficient change the roots (‘eigenvalues’) of the polynomial?\nPlotting the determinant polynomial with respect to \\(\\lambda\\) and more specifically the roots of the polynomals with respect to \\(\\gamma\\) shows a pattern. If \\(c\\) is completely dissimilar to \\(a\\) and \\(b\\), the first order coefficient, \\(c_{n-2}\\), is greater than zero and there are two necessarily non-zero eigenvalues: \\(λ_1\\) and \\(λ_2\\). Because \\(a\\) and \\(b\\) are completely similar in our example, λ_3 is always necessarily zero.\nAs the similarity of \\(c\\) to \\(a\\) and \\(b\\) increases and \\(c_{n-2}\\) goes to zero, there are constraints on how the set of eigenvalues change. Computing the eigenvalues as a function of similarity of \\(c\\) to \\(a\\) and \\(b\\) show that the two eigenvalues change in opposite directions: \\(λ_1\\) becomes more positive while \\(λ_2\\) becomes more negative. This relationship between \\(λ_1\\) and \\(λ_2\\) is a natural mathematical consequence of solving for the roots of a polynomial with maximum degree three and minimum degree 1.\n\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(left) Characteristic polynomial at\n3 different degrees of relatedness between organisms.\nFigure 3: (right) Roots of the characteristic polynomial while smoothly varying \\(γ\\)\n\n\n\nWe see that if we start with the characteristic polynomial including the degree of relatedness variable \\(\\gamma\\).\n\\[\n\\lambda^3 - 9\\lambda^2 + (18 - 2\\gamma^2)\\lambda\n\\]\nWe can immediately factor out a root and power of \\(\\lambda\\).\n\\[\n(\\lambda - 0)(\\lambda^2 - 9\\lambda^1 + (18 - 2\\gamma^2))\n\\]\nThis is the third root of the eigenvalue problem and it is always equal to zero because we have set this example with \\(a\\) and \\(b\\) as identical.\nFactoring out this root allows us to use the quadratic formula for the roots on the remaining 2nd order polynomial:\n\\[\n\\frac{-b \\pm \\sqrt{b^2 - 4ac}}{2a} \\rightarrow \\frac{9 \\pm \\sqrt{81 - 4(18 - 2\\gamma^2)}}{2} = \\frac{9 \\pm \\sqrt{8\\gamma^2 + 9}}{2}\n\\]\nHere we see that the remaining two roots are generically expressed using quadratic formula\n\\[\n(\\lambda - 0)\\left(\\lambda - \\frac{9 - \\sqrt{8\\gamma^2 + 9}}{2}\\right)\\left(\\lambda - \\frac{9 + \\sqrt{8\\gamma^2 + 9}}{2}\\right)\n\\]\nBecause \\(\\sqrt{8\\gamma^2 + 9}\\) will always be smaller than \\(9\\) while \\(\\gamma &lt; (\\langle a|a\\rangle = 3)\\), we can see that as \\(\\gamma\\) approaches \\(3\\) the roots approach \\(\\{0, 0, +9\\}\\) respectively. And likewise, as \\(\\gamma\\) approaches \\(0\\) the roots approach \\(\\{0, +3, +6\\}\\). These results make some intuitive sense when looking at Figure 3 which plots the determinant value with respect to \\(\\lambda\\). When \\(\\gamma\\) is large it drives the positive first order term of the polynomial to zero, which means that the negative second order term dominates for the region between \\(\\lambda = 0\\) to approximately \\(\\lambda = 6\\) until finally the positive third order term overtakes and dominates. In contrast when \\(\\gamma\\) is small, the positive first order is present and can dominate the polynomial for small values of \\(\\lambda\\) until the higher order terms begin to dominate the polynomial.\nWe also note two important facts:\nFirst, the second eigenvalue\n\\[\\left(\\lambda - \\frac{9 - \\sqrt{8\\gamma^2 + 9}}{2}\\right)\\]\nwill only equal zero when \\(\\gamma\\) is exactly equal to \\(3=\\langle a|a \\rangle =\\langle b|b \\rangle = s\\) – only when \\(c\\) is exactly identical to \\(a\\) and \\(b\\). At any point where there is a difference in similarity and relatedness between these subpopulations there will be exactly \\(2\\) eigenvalues, and thus exactly \\(2\\) spectral components.\nSecond, the two eigenvalues (‘roots’) will change in equal and opposite directions as the degree of related \\(\\gamma\\) changes. These dynamics are caused because the only occasion of \\(\\gamma\\) in the quadratic formula is behind the \\(\\pm\\) sign, we can see that as \\(\\gamma\\) changes the roots of the characteristic polynomial have to change by the same amount in both the positive and negative directions. We also note that the second eigenvalue very quickly drops off, following a power-law on the order of \\(\\gamma^2\\).\nThe results in this section support the idea that small eigenvalues—and by extension the spectral components they correspond to—are not noise. Up until sub-populations are exactly equal there are necessarily small spectral components, and because they roots change by at least the order of \\(\\gamma^2\\) even not vary related sub-populations can have very spectral components corresponding to eigenvalues with extremely small magnitude.\n\n\n\nChange of eigenvector contributions in a 3x3 ensemble of systems as a function of similarity\nTo better understand the relevance of the information being described by these minor spectral components, we computed the contribution of organisms \\(a\\), \\(b\\), and \\(c\\) to eigenvectors \\(v_1\\) and \\(v_2\\), defined by \\(λ_1\\) and \\(λ_2\\) respectively.\nFor eigenvector \\(v_1\\), we found that the contribution of \\(a\\) and \\(b\\) is relatively constant while the contribution of \\(c\\) rapidly changes from zero and asymptotically reaches the same constant as \\(a\\) and \\(b\\). In contrast, for eigenvector \\(v_2\\) we found that the contribution of \\(c\\) is relatively constant while the contribution of \\(a\\) and \\(b\\) rapidly changes from zero to asymptotically reach a constant value away from that of \\(h\\). These results indicate that the eigenvector \\(v_1\\) defines the similarity between \\(a\\), \\(b\\), and \\(c\\), whereas eigenvector \\(v_2\\) defines the difference between \\(a\\), \\(b\\), and \\(c\\). This relationship underlies using the eigenspectrum to define different scales of relatedness and is necessarily true independent of the percent variance harbored by each spectral component.\nYet, how is it that varying the similarity of \\(c\\) to \\(a\\) and \\(b\\) has different effects on the how each system relates to each other depending on which eigenvector is being considered?\n\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nContribution of organisms onto eigenvectors \\(v_1\\) and \\(v_2\\) as the\nFigure 4: degree of relatedness \\(\\gamma\\) is varied.\n\n\n\nWe sought to understand why changing the similarity of \\(c\\) to \\(a\\) and \\(b\\) differentially affects the contribution of each system to eigenvectors \\(v_1\\) and \\(v_2\\). Solving the eigenvectors for the set of eigenvalues defines a system of equations relating the contribution of each system to eigenvectors \\(v_1\\) and \\(v_2\\) and the similarity of \\(c\\) to \\(a\\) and \\(b\\). The eigenvector equation \\((C-\\lambda I)\\vec{v} = 0\\) expanded into matrix notation is\n\\[\n\\begin{bmatrix}\n    \\langle c|c \\rangle-\\lambda&\\gamma&\\gamma\\\\\n    \\gamma&\\langle b|b \\rangle-\\lambda&s\\\\\n    \\gamma&s&\\langle a|a \\rangle-\\lambda\\\\\n\\end{bmatrix}\\begin{bmatrix}x_c\\\\x_b\\\\x_a\\end{bmatrix}= \\begin{bmatrix}0\\\\0\\\\0\\end{bmatrix}\n\\tag{7}\\]\nWe are interested in how the contributions \\(\\{x_a, x_b, x_c\\}\\) of each organism change with respect to \\(\\gamma\\). This question necessitates calculating the partial derivative of the contribution of each system onto either eigenvector \\(v_1\\) or \\(v_2\\) with respect to the similarity of \\(c\\) to \\(a\\) and \\(b\\). We choose to calculate the derivative for each organism’s contribution starting at the modular example where the sub-populations are completely independent, \\(\\gamma = 0\\)\nTo calculate these derivatives it will be helpful to first calculate the contribution of each organism at the modular case and for comparison at the similar case so that we have concrete numbers that we can substitute into the different variables.\n\nModular case: eigenvector \\(v_1\\)\nwe can start with the modular case’s set of equations.\n\\[\n\\begin{bmatrix}\n    3-\\lambda&0&0\\\\\n    0&3-\\lambda&3\\\\\n    0&3&3-\\lambda\\\n\\end{bmatrix}\\begin{bmatrix}x_c\\\\x_b\\\\x_a\\end{bmatrix}= \\begin{bmatrix}0\\\\0\\\\0\\end{bmatrix}\n\\]\nAnd then substitute the first root in the modular case \\(\\lambda = 6\\)\n\\[\n\\begin{bmatrix}\n    -3&0&0\\\\\n    0&-3&3\\\\\n    0&3&-3\\\\\n\\end{bmatrix}\\begin{bmatrix}x_c\\\\x_b\\\\x_a\\end{bmatrix}= \\begin{bmatrix}0\\\\0\\\\0\\end{bmatrix}\n\\]\nto solve for \\(x_c\\) we look to the top row’s equation\n\\[\n-3x_c + 0x_b + 0x_a = 0\n\\]\nwhich is solved by setting \\(x_c = 0\\)\nthe equations for \\(x_b\\) and \\(x_a\\) work together to show that they can equal any real number so long as \\(x_a = x_b\\)\n\\[\n3x_a - 3x_b = x_a - x_b = 0\n\\]\nso to make \\([x_c,x_b,x_a]^t\\) a unitary vector (i.e., with length equal to \\(1\\)), we set \\(x_a = x_b = \\frac{1}{\\sqrt{2}}\\)\n\n\nModular case: eigenvector \\(v_2\\)\nWe can use the same process to find the contribution of each organism onto the second eigenvector with \\(\\lambda = 3\\)\n\\[\n\\begin{bmatrix}\n    0&0&0\\\\\n    0&0&3\\\\\n    0&3&0\\\\\n\\end{bmatrix}\\begin{bmatrix}x_c\\\\x_b\\\\x_a\\end{bmatrix}= \\begin{bmatrix}0\\\\0\\\\0\\end{bmatrix}\n\\]\nto solve for \\(x_c\\) we look to the top equation\n\\[\n0x_c + 0x_b + 0x_a = 0\n\\]\nand see that \\(x_c\\) can be any value.\nthe equations for \\(x_b\\) and \\(x_a\\) work together to show that they must both equal zero.\n\\[\n0x_c + 0x_b + 3x_a = x_a = 0\n\\]\n\\[\n0x_c + 3x_b + 0x_a = x_b = 0\n\\]\nso to make \\([x_c,x_b,x_a]^t\\) a unitary vector (i.e., with length equal to \\(1\\)), we set \\(x_a = x_b = 0\\) and \\(x_c = 1\\)\n\n\nSimilar case: eigenvector \\(v_1\\)\nWe also can look to our similar case and find that all contributions are uniformly distributed along the first eigenvector, with no other non-zero eigenvalues or eigenvectors.\n\\[\n\\begin{bmatrix}\n    -6&3&3\\\\\n    3&-6&3\\\\\n    3&3&-6\\\\\n\\end{bmatrix}\\begin{bmatrix}x_c\\\\x_b\\\\x_a\\end{bmatrix}= \\begin{bmatrix}0\\\\0\\\\0\\end{bmatrix}\n\\]\nthese are permutations of the same equation\n\\[\nx_a + x_b - 2x_c = 0\n\\]\n\\[\nx_a + x_c - 2x_b = 0\n\\]\n\\[\nx_c + x_b - 2x_a = 0\n\\]\nand is solved with \\(x_c = x_b = x_a\\)\nSo, to make \\([x_c,x_b,x_a]^t\\) a unitary vector, we set \\(x_a = x_b = x_c = \\frac{1}{\\sqrt{3}}\\)\n\n\nGathering the calculations\nAfter these calculations, we have this table of results showing the contribution of each organism onto eigenvectors both in the modular case and in the similar case\n\n\n\n\n\n\n\n\n\n\norganism contribution\nmodular  \\(v_1\\), \\(\\lambda=6\\)\nmodular  \\(v_2\\), \\(\\lambda=3\\)\nsimilar  \\(v_1\\), \\(\\lambda=9\\)\nsimilar  \\(v_2\\), \\(\\lambda=0\\)\n\n\n\n\n\\(x_c\\)\n\\(0\\)\n\\(1\\)\n\\(\\frac{1}{\\sqrt{3}}\\)\n\\(0\\)\n\n\n\\(x_b\\)\n\\(\\frac{1}{\\sqrt{2}}\\)\n\\(0\\)\n\\(\\frac{1}{\\sqrt{3}}\\)\n\\(0\\)\n\n\n\\(x_a\\)\n\\(\\frac{1}{\\sqrt{2}}\\)\n\\(0\\)\n\\(\\frac{1}{\\sqrt{3}}\\)\n\\(0\\)\n\n\n\nThese are the two extreme cases where the sub-populations are either completely distinct or completely identical. And what we see is that in the distinct case the contributions of each sub-population are partitioned onto separate eigenvalues, such that the larger sub-population \\(\\{a, b\\}\\) is on the larger eigenvector with no contribution from the smaller sub-population \\(c\\). Conversely, the smaller sub-population’s contribution is completely on the smaller eigenvector \\(v_2\\) with no contribution from the larger sub-population. Thus, once we have increased the degree of relatedness \\(\\gamma\\) to the point both sub-populations are identical, the contribution of each organisms is uniformly weighted on the first eigenvector.\nWe can now get a sense of what the contributions mean and how different behavior arises on each eigenvector by exploring how the contributions change as we move away from the modular case by increasing the degree of relatedness \\(\\gamma\\). Answering this question entails calculating the partial derivatives of \\(\\{x_a, x_b, x_c\\}\\) with respect to \\(\\gamma\\). We will perform this calculation across both eigenvectors \\(v_1\\) and \\(v_2\\).\n\n\npartial derivative: \\(\\frac{\\partial x_c}{\\partial \\gamma}\\)\nLet’s start with \\(x_c\\)\nOn both \\(v_1\\) and \\(v_2\\) we will need to solve this equation.\n\\[\n(\\langle c|c \\rangle-\\lambda)x_c + \\gamma x_b + \\gamma x_a = 0\n\\]\nwe can isolate \\(x_c\\)\n\\[\n\\begin{align}\n(\\langle c|c \\rangle-\\lambda)x_c + \\gamma x_b + \\gamma x_a &= 0 \\\\\n(\\langle c|c \\rangle-\\lambda)x_c &= -(\\gamma x_b + \\gamma x_a)\\\\\nx_c &= \\frac{-\\gamma(x_b + x_a)}{(\\langle c|c \\rangle-\\lambda)}\\\\\nx_c &= \\frac{\\gamma(x_b + x_a)}{\\lambda - \\langle c|c \\rangle}\\\\\n\\end{align}\n\\]\nBecause we are starting from the modular case:\n\non \\(v_1\\) we know that \\(x_a = x_b = \\frac{1}{\\sqrt{2}}\\)\non \\(v_2\\) we know that \\(x_a = x_b = 0\\)\n\nWe then get a different partial derivative for each eigenvector; simply from the fact the \\(x_a\\) and \\(x_b\\) zero out the derivative on eigenvector \\(v_2\\) and are non-zero on \\(v_1\\).\nOn \\(v_1\\) we can substitute and simplify\n\\[\n\\begin{align*}\nx_c = \\frac{\\gamma(x_b + x_a)}{\\lambda - \\langle c|c \\rangle} &= \\frac{\\gamma(\\frac{1}{\\sqrt{2}} + \\frac{1}{\\sqrt{2}})}{\\lambda - \\langle c|c \\rangle} \\\\\n&= \\frac{2\\gamma}{\\sqrt{2}\\left(\\lambda - \\langle c|c \\rangle\\right)} \\\\\nx_c &= \\frac{\\sqrt{2}\\gamma}{\\lambda - \\langle c|c \\rangle} \\\\\n\\end{align*}\n\\]\nOn \\(v_2\\) we can substitute and simplify\n\\[\n\\begin{align*}\nx_c = \\frac{\\gamma(x_b + x_a)}{\\lambda - \\langle c|c \\rangle} &= \\frac{\\gamma(0 + 0)}{\\lambda - \\langle c|c \\rangle} \\\\\nx_c &= 0\n\\end{align*}\n\\]\n\n\npartial derivative: \\(\\frac{\\partial x_b}{\\partial \\gamma}\\), \\(\\frac{\\partial x_a}{\\partial \\gamma}\\)\nIn contrast, when we we start with \\(x_b\\)’s equation\n\\[\n\\gamma x_c + (\\langle b|b \\rangle-\\lambda)x_b + s x_a = 0\n\\]\nAnd isolate \\(x_b\\)\n\\[\n\\begin{align}\n\\gamma x_c + (\\langle c|c \\rangle-\\lambda)x_b + s x_a &= 0\\\\\nx_b &= \\frac{-(\\gamma x_c + s x_a)}{(\\langle b|b \\rangle-\\lambda)}\\\\\nx_b &= \\frac{(\\gamma x_c + s x_a)}{\\lambda - \\langle b|b \\rangle}\\\\\n\\end{align}\n\\]\nWe see that on eigenvector \\(v_1\\), \\(x_c=0\\) so the partial derivative is zeroed out. And on eigenvector \\(v_2\\), because \\(x_c=1\\) the derivative with respect to \\(\\gamma\\) is\n\\[\n\\frac{\\partial x_b}{\\partial \\gamma} = \\frac{1}{\\lambda - \\langle b|b \\rangle}\n\\]\nUsing the exact same procedure as for \\(x_b\\), we find for \\(x_a\\) that its partial derivatives are essentially identical\nPulling together all these partial derivatives we start to see a pattern, and explanation for how contributions of organisms can rise and fall on different eigenvectors\n\n\n\n\n\n\n\n\n\neigenvector\npartial derivative \\(x_c\\)\npartial derivative \\(x_b\\)\npartial derivative \\(x_a\\)\n\n\n\n\n\\(\\text{eigenvector } v_1\\)\n\\(\\frac{\\partial x_c}{\\partial \\gamma} = \\frac{\\sqrt{2}}{\\lambda_1 - \\langle c|c \\rangle}\\)\n\\(\\frac{\\partial x_b}{\\partial \\gamma} = 0\\)\n\\(\\frac{\\partial x_a}{\\partial \\gamma} = 0\\)\n\n\n\\(\\text{eigenvector } v_2\\)\n\\(\\frac{\\partial x_c}{\\partial \\gamma} = 0\\)\n\\(\\frac{\\partial x_b}{\\partial \\gamma} = \\frac{1}{\\lambda_2 - \\langle b|b \\rangle}\\)\n\\(\\frac{\\partial x_a}{\\partial \\gamma} = \\frac{1}{\\lambda_2 - \\langle a|a \\rangle}\\)\n\n\n\nWe find that in the limit of a small increase in similarity of \\(c\\) to \\(a\\) and \\(b\\), the change in the contribution of \\(c\\) to eigenvector \\(v_1\\) is a constant while the that of \\(a\\) and \\(b\\) is zero. In contrast, the change in the contribution of \\(c\\) to eigenvector \\(v_2\\) is zero while that of \\(a\\) and \\(b\\) is a constant. Because \\(λ_1\\) and \\(λ_2\\) trend in opposite directions (and away from the singularity at \\(\\lambda=3\\)), the contribution of \\(c\\) to eigenvector \\(v_1\\) smoothly tends towards that of \\(a\\) and \\(b\\) thereby defining relative system similarity, while the contributions of \\(a\\) and \\(b\\) to eigenvector \\(v_2\\) smoothly tend away from that of \\(c\\) thereby defining the relative dissimilarity between systems."
  },
  {
    "objectID": "02_figure_02supp.html#local-parameter-sweep",
    "href": "02_figure_02supp.html#local-parameter-sweep",
    "title": "Spectral Tree Theory",
    "section": "Local parameter sweep",
    "text": "Local parameter sweep\nDoes spectral inference find the appropriate tree regardless of the number of taxa or number of features?\nSpectral inference works in the limit that we have enough features to describe all the extant sub-populations. i.e., generally when Nfeatures &gt;= Ntaxa. If features are carefully chosen its possible to use fewer features.\n\nusing Gotree_jll, Goalign_jll, SeqGen_jll\n\ntreedir = datadir(\"sims\", \"localsweep\", \"trees\") |&gt; mkpath\n\nnumleaves = [16, 32, 64, 128, 256, 512, 1024]\nnfeatures = [16, 32, 64, 128, 256, 512, 1024]\nbaldepth = Int.(log2.(numleaves));\nconst seed = 42;\n\nMake randomly generated trees. The branch lengths for each random tree are selected from an exponential distribution and trees from GTDB are selected based on number of leaves an internal node posesses.\n\n# branch lengths for each random tree are selected from an exponential distribution\nfor (d, nl) in zip(baldepth, numleaves)\n    run(pipeline(`$(gotree()) generate balancedtree --seed $(seed) -d $d`,\n    `$(gotree()) brlen clear`, \n    `$(gotree()) brlen setmin -l 1.0 -o $(treedir)/balancedtree-t$(nl)-s$(seed).nw`\n    ))\nend\n\n\n## Make MSAs from generated trees\nmsadir = datadir(\"sims\", \"localsweep\", \"MSAs\")\nrm(msadir, force=true, recursive=true)\nmkpath(msadir)\n\n# Nbits = 2 (binary)\nfor Nf in nfeatures\n    mkpath(msadir)\n    for f in readdir(treedir)\n        fn = first(split(f, \".\"))\n        run(pipeline(`$(seqgen()) -q -z$(seed) -s $(2/Nf) -or -l$Nf -mHKY -f0.5,0.0,0.0,0.5`,\n            stdin=joinpath(treedir, f),\n            stdout=joinpath(msadir, fn * \"-l$Nf-b2.phy\")))\n    end\nend\n\n\n# Run SpectralInference on balenced trees\ninputdir = datadir(\"sims\", \"localsweep\", \"MSAs\")\ninputfiles = joinpath.(inputdir, readdir(inputdir))\nsimnames = first.(split.(basename.(inputfiles), \".\"))\noutputdir  = projectdir(\"_research\", \"localsweep\", \"runSPI\")\noutputdirs = joinpath.(outputdir, simnames)\n\nfor (inputfile, simname, outdir) in zip(inputfiles, simnames, outputdirs)\n    mkpath(outdir)\n    run(pipeline(`julia -t 4 $(projectdir(\"scripts\", \"runners\", \"runSPI.jl\")) \\\n        -i $inputfile \\\n        -o $outdir \\\n        --nboot 100`, \n        stdout=joinpath(outdir, \"runSPI.out\")))\nend\n\n  Activating project at `~/projects/Doran_etal_2023`\n  Activating project at `~/projects/Doran_etal_2023`\n  Activating project at `~/projects/Doran_etal_2023`\n  Activating project at `~/projects/Doran_etal_2023`\n  Activating project at `~/projects/Doran_etal_2023`\n  Activating project at `~/projects/Doran_etal_2023`\n  Activating project at `~/projects/Doran_etal_2023`\n  Activating project at `~/projects/Doran_etal_2023`\n  Activating project at `~/projects/Doran_etal_2023`\n  Activating project at `~/projects/Doran_etal_2023`\n  Activating project at `~/projects/Doran_etal_2023`\n  Activating project at `~/projects/Doran_etal_2023`\n  Activating project at `~/projects/Doran_etal_2023`\n  Activating project at `~/projects/Doran_etal_2023`\n  Activating project at `~/projects/Doran_etal_2023`\n  Activating project at `~/projects/Doran_etal_2023`\n  Activating project at `~/projects/Doran_etal_2023`\n  Activating project at `~/projects/Doran_etal_2023`\n  Activating project at `~/projects/Doran_etal_2023`\n  Activating project at `~/projects/Doran_etal_2023`\n  Activating project at `~/projects/Doran_etal_2023`\n  Activating project at `~/projects/Doran_etal_2023`\n  Activating project at `~/projects/Doran_etal_2023`\n  Activating project at `~/projects/Doran_etal_2023`\n  Activating project at `~/projects/Doran_etal_2023`\n  Activating project at `~/projects/Doran_etal_2023`\n  Activating project at `~/projects/Doran_etal_2023`\n  Activating project at `~/projects/Doran_etal_2023`\n  Activating project at `~/projects/Doran_etal_2023`\n  Activating project at `~/projects/Doran_etal_2023`\n  Activating project at `~/projects/Doran_etal_2023`\n  Activating project at `~/projects/Doran_etal_2023`\n  Activating project at `~/projects/Doran_etal_2023`\n  Activating project at `~/projects/Doran_etal_2023`\n  Activating project at `~/projects/Doran_etal_2023`\n  Activating project at `~/projects/Doran_etal_2023`\n  Activating project at `~/projects/Doran_etal_2023`\n  Activating project at `~/projects/Doran_etal_2023`\n  Activating project at `~/projects/Doran_etal_2023`\n  Activating project at `~/projects/Doran_etal_2023`\n  Activating project at `~/projects/Doran_etal_2023`\n  Activating project at `~/projects/Doran_etal_2023`\n  Activating project at `~/projects/Doran_etal_2023`\n  Activating project at `~/projects/Doran_etal_2023`\n  Activating project at `~/projects/Doran_etal_2023`\n  Activating project at `~/projects/Doran_etal_2023`\n  Activating project at `~/projects/Doran_etal_2023`\n  Activating project at `~/projects/Doran_etal_2023`\n  Activating project at `~/projects/Doran_etal_2023`\n\n\n\n### SPI METRICS\nsourcetrees = joinpath.(datadir(), \"sims\", \"localsweep\", \"trees\", replace.(basename.(inputfiles), r\"-l[0-9].*\"=&gt;\".nw\"))\nmetricdf = DataFrame(\n    :treefile=&gt;sourcetrees,\n    :msafile=&gt;inputfiles,\n    :msaname=&gt;simnames,\n    :outputdir=&gt;outputdirs,\n    :ntaxa=&gt;parse.(Int, replace.(simnames, r\"(.*)((?&lt;=-t)[0-9]*)(.*)\"=&gt;s\"\\2\")),\n    :nfeatures=&gt;parse.(Int, replace.(simnames, r\"(.*)((?&lt;=-l)[0-9]*)(.*)\"=&gt;s\"\\2\")),\n    :nbits=&gt;parse.(Int, replace.(simnames, r\"(.*)((?&lt;=-b)[0-9]*)(.*)\"=&gt;s\"\\2\")),\n)\nmetricdf = transform(metricdf, :nbits =&gt; (x-&gt; x==20 ? \"AA\" : \"DNA\") =&gt; :chartype)\n\n@info \"Reading original source trees for SPI...\"\norigtrees = readnw.(read.(metricdf.treefile, String));\nas_polytomy!.(n-&gt;distance(n)&lt;1e-8, origtrees);\n\npredtreesfiles = joinpath.(projectdir(), \"_research\", \"localsweep\", \"runSPI\", metricdf.msaname, metricdf.msaname .* \"-supporttree.nw\")\n@info \"Reading in SPI predicted trees...\"\npredtrees = readnw.(read.(predtreesfiles, String));\nas_polytomy!.(n-&gt;NewickTree.support(n)&lt;.5, predtrees);\n@info \"Calculate SPI Fscore Precision & Recall...\"\nproformencemetrics = fscore_precision_recall.(origtrees, predtrees)\nproformencemetrics = hcat(vcat.(proformencemetrics...)...)\nmetricdf[!,:SPI_fscore] .= proformencemetrics[:, 1]\nmetricdf[!,:SPI_precision] .= proformencemetrics[:, 2]\nmetricdf[!,:SPI_recall] .= proformencemetrics[:, 3]\n\n@info \"Calculating SPI Branch Depth\"\nmmmdepths = map(predtrees) do tr\n    dists = mapinternalnodes(network_distance, tr, tr)\n    return [mean(dists), median(dists), maximum(dists)]\nend\nmmmdepths = hcat(mmmdepths...)'\nmetricdf[!,:SPI_meandepth] .= mmmdepths[:, 1]\nmetricdf[!,:SPI_mediandepth] .= mmmdepths[:, 2]\nmetricdf[!,:SPI_maxdepth] .= mmmdepths[:, 3]\n\nmkpath(datadir(\"exp_pro\", \"localsweep\"))\nCSV.write(datadir(\"exp_pro\", \"localsweep\", \"metricsSPI.csv\"), metricdf)\n\n┌ Info: Reading original source trees for SPI...\n└ @ Main /Users/bend/projects/Doran_etal_2023/notebooks/02_figure_02supp.ipynb:14\n┌ Info: Reading in SPI predicted trees...\n└ @ Main /Users/bend/projects/Doran_etal_2023/notebooks/02_figure_02supp.ipynb:19\n┌ Info: Calculate SPI Fscore Precision & Recall...\n└ @ Main /Users/bend/projects/Doran_etal_2023/notebooks/02_figure_02supp.ipynb:22\n┌ Info: Calculating SPI Branch Depth\n└ @ Main /Users/bend/projects/Doran_etal_2023/notebooks/02_figure_02supp.ipynb:29\n\n\n\"/Users/bend/projects/Doran_etal_2023/data/exp_pro/localsweep/metricsSPI.csv\"\n\n\n\npdir = plotsdir(\"localsweep\")\nmkpath(pdir)\ndf = CSV.read(datadir(\"exp_pro\", \"localsweep\", \"metricsSPI.csv\"), DataFrame);\nCSV.write(datadir(\"exp_pro\", \"localsweep\", \"TableS1.csv\"),\n    df[:, [:msaname, :ntaxa, :nfeatures, :chartype, :SPI_fscore, :SPI_recall, :SPI_precision]]\n)\npdf = df[:, [:ntaxa, :nfeatures, :SPI_fscore]] |&gt;\n    df-&gt;unstack(df, :nfeatures, :SPI_fscore) |&gt;\n    df-&gt;sort(df, :ntaxa) |&gt;\n    df-&gt;select(df, [\"ntaxa\", \"16\", \"32\",\"64\", \"128\", \"256\", \"512\", \"1024\"])\nheatmap(Matrix(pdf[!,2:end]), \n    ticks=(1:7, [ \"16\", \"32\", \"64\", \"128\", \"256\", \"512\", \"1024\"]),\n    xlabel=\"nfeatures\",\n    ylabel=\"ntaxa\",\n    clims=(0,1),\n    title=\"SPI fscore\",\n    c=:viridis)"
  },
  {
    "objectID": "02_figure_02supp.html#example-with-convergent-evolution",
    "href": "02_figure_02supp.html#example-with-convergent-evolution",
    "title": "Spectral Tree Theory",
    "section": "Example with convergent evolution",
    "text": "Example with convergent evolution\nSpectral decomposition’s like SVD and PCA are based on co-variation, therefore they incorporate information about contextual dependence between features and taxa. This means that Spectral Inference can infer the correct ancestral tree even in cases of convergent evolution. Below we created an alignment of 18 taxa described by 9 features, where there are multiple evolutionary paths to get to each feature, i.e., each feature is only a good genomic feature that matches a true ancestral divergence in the context of other features.\nSpectral Inference is able to perfectly recapitulate this ancestral tree, where standard phylogenetic tools fail.\n\nM = Float64.([\n    1 0 1 0 0 0 1 0 1;\n    0 1 1 0 0 0 1 0 1;\n    1 1 0 0 0 0 1 0 1;\n    1 0 1 0 0 0 0 1 1;\n    0 1 1 0 0 0 0 1 1;\n    1 1 0 0 0 0 0 1 1;\n    1 0 1 0 0 0 1 1 0;\n    0 1 1 0 0 0 1 1 0;\n    1 1 0 0 0 0 1 1 0;\n    1 0 1 1 0 1 0 0 0;\n    0 1 1 1 0 1 0 0 0;\n    1 1 0 1 0 1 0 0 0;\n    1 0 1 0 1 1 0 0 0;\n    0 1 1 0 1 1 0 0 0;\n    1 1 0 0 1 1 0 0 0;\n    1 0 1 1 1 0 0 0 0;\n    0 1 1 1 1 0 0 0 0;\n    1 1 0 1 1 0 0 0 0;\n]);\nheatmap(M, \n    c=[:white, :black], \n    ratio=1, \n    xticks=(1:9, [\"Pos $i\" for i in 1:9]),\n    xrotation=45,\n    yticks=(1:18, 'a':'r'),\n    yflip=true,\n    size=(300, 600),\n    margin=5Plots.mm,\n)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\nusv = svd(M);\n\n\nplot(\n    ylabel=\"explained variance (%)\", \n    xlabel=\"spectral component\", \n    legend=:none, \n    ylims=(0,1), xlims=(.5,9.5), \n    size=(500,500)\n)\nscatter!((usv.S.^2)/sum(usv.S.^2), \n    xticks=1:14, c=:black, markersize=5,\n)\nannotate!((1:length(usv.S)) .+ .1 , (usv.S.^2)/sum(usv.S.^2).+.06, round.((usv.S.^2)/sum(usv.S.^2)*100, digits=1))\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPhylogenetic inference with FastME, PhyML, and SPI\nIn the tree plots below only branches with an orange dot are statistically supported.\n\ntoyMSA_18x9_dir = datadir(\"sims\", \"toyMSA_18x9\") |&gt; mkpath\n# write out alignment\nwritephylip(\n    joinpath(toyMSA_18x9_dir, \"MSA.phylip\"),\n    join.(eachrow((replace(M, 0.0 =&gt; 'A', 1.0 =&gt; 'T')))),\n    collect('a':'r')\n)\n\n\n# FastME\nrun(`julia $(projectdir(\"scripts\", \"runners\", \"runFastME.jl\")) \n    -i $(datadir(\"sims\", \"toyMSA_18x9\", \"MSA.phylip\"))\n    -o $(projectdir(\"_research\", \"toyMSA_18x9\", \"FastME\"))\n    -m JC69\n`)\n# PhyML\nrun(`julia $(projectdir(\"scripts\", \"runners\", \"runPhyML.jl\")) \n    -i $(datadir(\"sims\", \"toyMSA_18x9\", \"MSA.phylip\"))\n    -o $(projectdir(\"_research\", \"toyMSA_18x9\", \"PhyML\"))\n    -m JC69\n`)\n# SpectralInference\nrun(`julia $(projectdir(\"scripts\", \"runners\", \"runSPI.jl\")) \n    -i $(datadir(\"sims\", \"toyMSA_18x9\", \"MSA.phylip\"))\n    -o $(projectdir(\"_research\", \"toyMSA_18x9\", \"SPI\"))\n    -m JC69\n`);\npdir_toyMSA_18x9 = plotsdir(\"toyMSA_18x9\") |&gt; mkpath\n\n  Activating project at `~/projects/Doran_etal_2023`\n  Activating project at `~/projects/Doran_etal_2023`\n  Activating project at `~/projects/Doran_etal_2023`\n\n\n[ Info: Starting FastME on MSA\n[ Info: using Booster to compute support values\n[ Info: stopping run\n ──────────────────────────────────────────────────────────────────────\n                              Time                    Allocations      \n                     ───────────────────────   ────────────────────────\n  Tot / % measured:       586ms /  91.3%           51.6MiB /  89.7%    \n\n Section     ncalls     time    %tot     avg     alloc    %tot      avg\n ──────────────────────────────────────────────────────────────────────\n total            1    535ms  100.0%   535ms   46.3MiB  100.0%  46.3MiB\n   booster        1    220ms   41.1%   220ms   1.16MiB    2.5%  1.16MiB\n   FastME         1    181ms   33.9%   181ms   3.29MiB    7.1%  3.29MiB\n ──────────────────────────────────────────────────────────────────────\n┌ Info: timing\n│   show(time) = nothing\n└   println(\"\") = nothing\n[ Info: Starting PhyML on MSA\n[ Info: stopping run\n ────────────────────────────────────────────────────────────────────\n                            Time                    Allocations      \n                   ───────────────────────   ────────────────────────\n Tot / % measured:      375ms /  87.4%           50.1MiB /  89.4%    \n\n Section   ncalls     time    %tot     avg     alloc    %tot      avg\n ────────────────────────────────────────────────────────────────────\n total          1    328ms  100.0%   328ms   44.8MiB  100.0%  44.8MiB\n   PhyML        1    194ms   59.2%   194ms   2.97MiB    6.6%  2.97MiB\n ────────────────────────────────────────────────────────────────────\n┌ Info: timing\n│   show(time) = nothing\n└   println(\"\") = nothing\n[ Info: Starting SPI inference\n[ Info: Setting up workspace\n[ Info: Running SPI\n[ Info: Writing out SPI Tree\n[ Info: Starting Bootstrap with 100\n[ Info: Writing out Bootstrap trees\n[ Info: using Booster to compute support values\n[ Info: Finishing run\n ────────────────────────────────────────────────────────────────────────────────\n                                        Time                    Allocations      \n                               ───────────────────────   ────────────────────────\n       Tot / % measured:            1.68s /  95.9%            294MiB /  98.0%    \n\n Section               ncalls     time    %tot     avg     alloc    %tot      avg\n ────────────────────────────────────────────────────────────────────────────────\n total                      1    1.61s  100.0%   1.61s    289MiB  100.0%   289MiB\n   running SPI              1    930ms   57.8%   930ms    167MiB   58.0%   167MiB\n   running bootstra...      1    183ms   11.4%   183ms   67.4MiB   23.3%  67.4MiB\n ────────────────────────────────────────────────────────────────────────────────\n┌ Info: \n│ timing\n│   show(time) = nothing\n└   println(\"\") = nothing\n\n\n\"/Users/bend/projects/Doran_etal_2023/plots/toyMSA_18x9\"\n\n\n\nmethod = \"FastME\"\nrun(pipeline(`$(gotree()) draw svg -c -w 400 -H 400 --support-cutoff .5 --with-branch-support`,\n    stdin=projectdir(\"_research\", \"toyMSA_18x9\", method, \"MSA-supporttree.nw\"),\n    stdout=joinpath(pdir_toyMSA_18x9, method * \".svg\")\n))\nshow_svg(joinpath(pdir_toyMSA_18x9, method * \".svg\"))\n\n\n\n\n\nmethod = \"PhyML\"\nrun(pipeline(`$(gotree()) draw svg -c -w 400 -H 400 --support-cutoff .5 --with-branch-support`,\n    stdin=projectdir(\"_research\", \"toyMSA_18x9\", method, \"MSA.phylip-supporttree.txt\"),\n    stdout=joinpath(pdir_toyMSA_18x9, method * \".svg\")\n))\nshow_svg(joinpath(pdir_toyMSA_18x9, method * \".svg\"))\n\n\n\n\n\nmethod = \"SPI\"\nrun(pipeline(`$(gotree()) draw svg -c -w 400 -H 400 --support-cutoff .5 --with-branch-support`,\n    stdin=projectdir(\"_research\", \"toyMSA_18x9\", method, \"MSA-supporttree.nw\"),\n    stdout=joinpath(pdir_toyMSA_18x9, method * \".svg\")\n))\nshow_svg(joinpath(pdir_toyMSA_18x9, method * \".svg\"))\n\n\n\n\n\n\nHow is information encoded about convergent processes?\nWe show that subsets of principal components, hold information that project taxa to different positions based on the ancestral path they took to obtain a particular genomic feature.\n\nbar(M[:, 5],\n    xticks=(1:18, 'a':'r'),\n    xlabel=\"taxa\",\n    ylabel=\"Pos 5\",\n    size=(600, 300),\n)\nvline!([9.5])\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ntaxa a-i and j-r split at the first generation. using position 5 as a gene marker would place j-l with a-i as they both lost this feature through convergent processes.\n\n\n\nMspectrallyfiltered = usv.U[:, 5:8] * Diagonal(usv.S[5:8]) * usv.Vt[5:8, :]\nheatmap(Mspectrallyfiltered, \n    c=:bwr, \n    ratio=1, \n    xticks=(1:9, [\"Pos $i\" for i in 1:9]),\n    xrotation=45,\n    yticks=(1:18, 'a':'r'),\n    yflip=true,\n    size=(300, 600),\n    margin=5Plots.mm,\n)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\nrecreated alignment matrix from components 5-8. These components shows the mutations incuded in generation F2 in blue\n\n\n\nbar(Mspectrallyfiltered[:, 5],\n    xticks=(1:18, 'a':'r'),\n    xlabel=\"taxa\",\n    ylabel=\"Pos 5\",\n    size=(600, 300),\n    ylims=(-.6667, .33334),\n    widen=true,\n    yticks=([-0.666, 0.0, .3333], [L\"\\frac{-2}{3}\", L\"0\", L\"\\frac{1}{3}\"])\n)\nvline!([9.5])\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nrecreating the alignment using components 5-8, transforms position 5 in such a way that taxa j-l are distict because they lost this feature in a different context as to taxa a-i\n\n\nWe show in this case as well that information regarding more recent generational differences correlate to deeper principal components\n\nspectralcorrs = map([i:(i+2) for i in 1:(size(M,2)-2)]) do window\n    spectralcorrelations(usv.U, window)\nend;\n\nF1mask = kron([1 0; 0 1], ones(3,3), ones(3,3))\nF2mask = kron(Diagonal(ones(6)), ones(3,3));\nuppertriangle = triu(trues(18, 18), 1);\n\n\nf1mi = map(spectralcorrs) do spcorr \n    empiricalMI(spcorr[uppertriangle], (F1mask .== 1)[uppertriangle]) # edges=-1:0.001:1\nend\nf2mi = map(spectralcorrs) do spcorr \n    empiricalMI(spcorr[uppertriangle], (F2mask .== 1)[uppertriangle]) # edges=-1:0.001:1\nend\n\nplot(\n    ylabel=\"Cumulative MI\\n (density)\",\n    xlabel=\"Principal component Window\\n [Principal component start to end]\",\n    yticks=[0.0, .5, 1.0],\n    xticks=(2:8, [\"[$i to $(i+2)]\" for i in 1:7]),\n    xrotation=45,\n    margin=5Plots.mm,\n)\nplot!(scaledcumsum(vcat(0, f1mi)), c=:red, marker=true, label=\"F1\", lw=2,)\nplot!(scaledcumsum(vcat(0, f2mi)), c=:orange, marker=true, label=\"F2\", lw=2,)"
  },
  {
    "objectID": "02_figure_02supp.html#timing-benchmark",
    "href": "02_figure_02supp.html#timing-benchmark",
    "title": "Spectral Tree Theory",
    "section": "Timing benchmark",
    "text": "Timing benchmark\nSpectral Inference is fast, it is based on PCA. So it has the potential to scale quite large. Thousands of taxa on a laptop, larger using clusters and distributed computing.\nHere we just show that Spectral Inference (SPI) does not grow exponentially with the number of taxa.\n\n## create UniProt subsets\nuniprot = readh5ad(datadir(\"exp_raw\", \"UP7047\", \"2020_02_UP7047.h5ad\"))\nrowmeta = uniprot.obs;\n\noutdir = datadir(\"exp_pro\", \"UPsubsetMSAs\") |&gt; mkpath\n\n\"/Users/bend/projects/Doran_etal_2023/data/exp_pro/UPsubsetMSAs\"\n\n\n\nSubset to different number of taxa\n\n25 taxa at Genus level (Ruminococcus)\n50 taxa at Family level (Rhodospirillaceae)\n103 taxa at Order level (Oceanospirillales)\n211 taxa at Class level (Bacteroidia)\n\n\n\nwrite out each subset as pseudo-alignment\n## Genus\ngenus_choice_df = combine(nrow, groupby(rowmeta, :Genus)) |&gt;\n    df-&gt;sort(df, :nrow, rev=true) |&gt;\n    df-&gt;filter(:nrow=&gt;x-&gt;24 .&lt; x .&lt; 27, df)\ndisplay(genus_choice_df)\n\nmask = findall(==(\"Ruminococcus\"), rowmeta.Genus);\nsubsetMSA = Char.(replace(uniprot.X[mask, :] .&gt; 0.0, true=&gt;'T', false=&gt;'A'))\nopen(joinpath(outdir, \"UPsubset_taxa=25_level=Genus_group=Ruminococcus_alphabet=AT.phy\"), \"w\") do io\n    println(io, size(subsetMSA, 1), \" \", size(subsetMSA, 2))\n    for (id, row) in zip(rowmeta.proteomeID[mask], eachslice(subsetMSA, dims=1))\n        println(io, id, \"    \", join(row))\n    end\nend\n\n## Family\nfamily_choice_df = combine(nrow, groupby(rowmeta, :Family)) |&gt;\n    df-&gt;sort(df, :nrow, rev=true) |&gt;\n    df-&gt;filter(:nrow=&gt;x-&gt;48 .&lt; x .&lt; 52, df)\ndisplay(family_choice_df)\n\nmask = findall(==(\"Rhodospirillaceae\"), rowmeta.Family);\nsubsetMSA = Char.(replace(uniprot.X[mask, :] .&gt; 0.0, true=&gt;'T', false=&gt;'A'))\nopen(joinpath(outdir, \"UPsubset_taxa=50_level=Family_group=Rhodospirillaceae_alphabet=AT.phy\"), \"w\") do io\n    println(io, size(subsetMSA, 1), \" \", size(subsetMSA, 2))\n    for (id, row) in zip(rowmeta.proteomeID[mask], eachslice(subsetMSA, dims=1))\n        println(io, id, \"    \", join(row))\n    end\nend\n\n## Order\norder_choice_df = combine(nrow, groupby(rowmeta, :Order)) |&gt;\n    df-&gt;sort(df, :nrow, rev=true) |&gt;\n    df-&gt;filter(:nrow=&gt;x-&gt;95 .&lt; x .&lt; 105, df)\ndisplay(order_choice_df)\n\nmask = findall(==(\"Oceanospirillales\"), rowmeta.Order);\nsubsetMSA = Char.(replace(uniprot.X[mask, :] .&gt; 0.0, true=&gt;'T', false=&gt;'A'))\nopen(joinpath(outdir, \"UPsubset_taxa=103_level=Order_group=Oceanospirillales_alphabet=AT.phy\"), \"w\") do io\n    println(io, size(subsetMSA, 1), \" \", size(subsetMSA, 2))\n    for (id, row) in zip(rowmeta.proteomeID[mask], eachslice(subsetMSA, dims=1))\n        println(io, id, \"    \", join(row))\n    end\nend\n\n## Class\nclass_choice_df = combine(nrow, groupby(rowmeta, :Class)) |&gt;\n    df-&gt;sort(df, :nrow, rev=true) |&gt;\n    df-&gt;filter(:nrow=&gt;x-&gt;190 .&lt; x .&lt; 215, df)\ndisplay(class_choice_df)\n\nmask = findall(==(\"Bacteroidia\"), rowmeta.Class);\nsubsetMSA = Char.(replace(uniprot.X[mask, :] .&gt; 0.0, true=&gt;'T', false=&gt;'A'))\nopen(joinpath(outdir, \"UPsubset_taxa=211_level=Class_group=Bacteroidia_alphabet=AT.phy\"), \"w\") do io\n    println(io, size(subsetMSA, 1), \" \", size(subsetMSA, 2))\n    for (id, row) in zip(rowmeta.proteomeID[mask], eachslice(subsetMSA, dims=1))\n        println(io, id, \"    \", join(row))\n    end\nend\n\n\n2×2 DataFrame\n\n\n\nRow\nGenus\nnrow\n\n\n\nString\nInt64\n\n\n\n\n1\nHelicobacter\n26\n\n\n2\nRuminococcus\n25\n\n\n\n\n\n\n2×2 DataFrame\n\n\n\nRow\nFamily\nnrow\n\n\n\nString\nInt64\n\n\n\n\n1\nAlteromonadaceae\n51\n\n\n2\nRhodospirillaceae\n50\n\n\n\n\n\n\n2×2 DataFrame\n\n\n\nRow\nOrder\nnrow\n\n\n\nString\nInt64\n\n\n\n\n1\nOceanospirillales\n103\n\n\n2\nPseudomonadales\n97\n\n\n\n\n\n\n1×2 DataFrame\n\n\n\nRow\nClass\nnrow\n\n\n\nString\nInt64\n\n\n\n\n1\nBacteroidia\n211\n\n\n\n\n\n\n\n## submit job to cluster to run all phylogenetic inference tasks in parallel\n# run(`sbatch $(projectdir(\"scripts\", \"slurm-run-PI-on-UPsubsets.sbatch\"))`)\n\n\ntime_per_run_df = CSV.read(projectdir(\"_research\", \"UPsubsetMSAs\", \"timeperjob.log\"), DataFrame, delim=\"\\t\");\n\n\npltdf = sort(time_per_run_df, :Seq) |&gt;\n    df-&gt;filter(:Exitval=&gt; ==(0), df) |&gt;\n    df-&gt;transform(df, :Command=&gt;(x-&gt;replace.(x, r\"(.*)((?&lt;=\\/t)[0-9]*)(.*)\"=&gt;s\"\\2\"))=&gt; :Ntaxa ) |&gt;\n    df-&gt;transform(df, :Command=&gt;(x-&gt;replace.(x, r\"(.*)((?&lt;=runners\\/run)[a-zA-Z]*)(.*)\"=&gt;s\"\\2\"))=&gt; :method);\n\npltdf = pltdf[:, [:method, :Ntaxa, :JobRuntime]];\npltdf.Ntaxa = parse.(Int, pltdf.Ntaxa);\npltdf = sort(pltdf, [:method, :Ntaxa]);\npltdf\n\n24×3 DataFrame\n\n\n\nRow\nmethod\nNtaxa\nJobRuntime\n\n\n\nString\nInt64\nFloat64\n\n\n\n\n1\nFastME\n25\n12.075\n\n\n2\nFastME\n50\n15.401\n\n\n3\nFastME\n103\n36.002\n\n\n4\nFastME\n211\n142.682\n\n\n5\nFastTree\n25\n883.487\n\n\n6\nFastTree\n50\n2011.95\n\n\n7\nFastTree\n103\n4044.1\n\n\n8\nFastTree\n211\n6906.7\n\n\n9\nMrBayes\n25\n728.282\n\n\n10\nMrBayes\n50\n1730.24\n\n\n11\nMrBayes\n103\n7628.71\n\n\n12\nMrBayes\n211\n9608.94\n\n\n13\nPhyML\n25\n439.039\n\n\n14\nPhyML\n50\n2441.14\n\n\n15\nPhyML\n103\n7875.46\n\n\n16\nPhyML\n211\n10119.2\n\n\n17\nRAxML\n25\n4905.39\n\n\n18\nRAxML\n50\n8285.4\n\n\n19\nRAxML\n103\n10093.6\n\n\n20\nRAxML\n211\n13513.1\n\n\n21\nSPI\n25\n65.94\n\n\n22\nSPI\n50\n67.507\n\n\n23\nSPI\n103\n83.168\n\n\n24\nSPI\n211\n138.193\n\n\n\n\n\n\n\nplot(title=\"Job runtime of phylogeny inference methods\",\n    ylabel=\"time (seconds)\",\n    yticks=([60, 600, 1800, 3600, 7200, 10800, 14400], [\"1m\", \"10m\", \"30m\", \"1h\", \"2h\", \"3h\", \"4h\"]),\n    xticks=([25, 50, 103, 211], [\n        \"Genus:Ruminococcus\\n #taxa=25\",\n        \"Family:Rhodospirillaceae\\n #taxa=50\",\n        \"Order:Oceanospirillales\\n #taxa=103\",\n        \"Class:Bacteroidia\\n #taxa=211\",\n         ]),\n    xrotation=30,\n    margin=5Plots.Measures.mm,\n    ylims=(-100, 14500),\n    xlims=(0, 220),\n    legend=:topleft,\n)\n@df pltdf plot!(:Ntaxa, :JobRuntime, group=:method, markers=true,\n    linewidth=2,\n    markersize=6,\n    markerstrokewidth=0,\n    c=permutedims(vcat([1],3:7)))"
  },
  {
    "objectID": "02_figure_02supp.html#footnotes",
    "href": "02_figure_02supp.html#footnotes",
    "title": "Spectral Tree Theory",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nHawkins, T. Cauchy and the spectral theory of matrices. Historia Mathematica 2, 1–29 (1975).↩︎"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "An evolution-based framework for describing human gut bacteria",
    "section": "",
    "text": "This code base is using the Julia Language and DrWatson to make a reproducible scientific project named &gt; Doran_etal_2023\nThis project reproduces results from:\nAn evolution-based framework for describing human gut bacteria\nTo (locally) reproduce this project, do the following:\n\nDownload this code base.\ngit clone --recurse-submodules git@github.com:aramanlab/Doran_etal_2023.git\ncd Doran_etal_2023\nOpen a Julia console and do:\njulia&gt; using Pkg\njulia&gt; Pkg.add(\"DrWatson\") # install globally, for using `quickactivate`\njulia&gt; Pkg.activate(\"path/to/this/project\")\njulia&gt; Pkg.instantiate()\n\nThis will install all necessary packages for you to be able to run the scripts and everything should work out of the box, including correctly finding local paths.\nYou may notice that most scripts start with the commands:\nusing DrWatson\n@quickactivate projectdir()\nwhich auto-activates the project and enables local path handling from DrWatson."
  },
  {
    "objectID": "index.html#initalizing-project",
    "href": "index.html#initalizing-project",
    "title": "An evolution-based framework for describing human gut bacteria",
    "section": "",
    "text": "This code base is using the Julia Language and DrWatson to make a reproducible scientific project named &gt; Doran_etal_2023\nThis project reproduces results from:\nAn evolution-based framework for describing human gut bacteria\nTo (locally) reproduce this project, do the following:\n\nDownload this code base.\ngit clone --recurse-submodules git@github.com:aramanlab/Doran_etal_2023.git\ncd Doran_etal_2023\nOpen a Julia console and do:\njulia&gt; using Pkg\njulia&gt; Pkg.add(\"DrWatson\") # install globally, for using `quickactivate`\njulia&gt; Pkg.activate(\"path/to/this/project\")\njulia&gt; Pkg.instantiate()\n\nThis will install all necessary packages for you to be able to run the scripts and everything should work out of the box, including correctly finding local paths.\nYou may notice that most scripts start with the commands:\nusing DrWatson\n@quickactivate projectdir()\nwhich auto-activates the project and enables local path handling from DrWatson."
  },
  {
    "objectID": "05_figure_05.html",
    "href": "05_figure_05.html",
    "title": "Predicting Strain Phenotype",
    "section": "",
    "text": "julia setup\nusing DrWatson\n@quickactivate projectdir()\n\nusing SpectralInference\nusing NewickTree\nusing MLJ\nusing MLJBase: train_test_pairs\nusing Distances, Clustering\nusing Muon, CSV, DataFrames\nusing Gotree_jll\nusing Random: seed!\nusing FreqTables\nusing NearestNeighbors\nusing HypothesisTests\nusing MultipleTesting: adjust, Bonferroni, BenjaminiHochberg\nusing StatsPlots, StatsBase\ntheme(:default, grid=false, label=\"\")\ninclude(srcdir(\"helpers.jl\"))\n\nddir = datadir(\"exp_raw\", \"BB669\")\nrdir = projectdir(\"_research\", \"metabolite_SLE_Lasso_model_outofbag\") |&gt; mkpath\npdir = plotsdir(\"metabolite_SLE_Lasso_model_outofbag\") |&gt; mkpath\nsupptbl_dir = projectdir(\"_research\", \"SuppTables\") |&gt; mkpath\n\nspeciescolordf = CSV.read(datadir(\"exp_raw\",\"BB669\",\"subsettreecolors.csv\"), DataFrame)\nspecies_color_dict = Dict(k=&gt;v for (k,v) in zip(speciescolordf.species_name, speciescolordf.color));"
  },
  {
    "objectID": "05_figure_05.html#training-a-lasso-model",
    "href": "05_figure_05.html#training-a-lasso-model",
    "title": "Predicting Strain Phenotype",
    "section": "Training a LASSO model",
    "text": "Training a LASSO model\n\n# Takes 1 min\nK = 1 # Make predictions with SPI-LASSO on 1 nearest neighbor\nλ = 1e-3\nREPS = 5\nNFOLDS = 4\n\nseed!(424242)\ncv = StratifiedCV(nfolds=NFOLDS, shuffle=true);\nfolds = vcat([train_test_pairs(cv, 1:sum(full_train_mask), trnYdf.Species) for i in 1:REPS]...)\n\n\nmdl = MLJLinearModels.LassoRegressor(lambda=λ)\n\n\noob_preds_df_stacked = DataFrame()\noof_preds_df_stacked = DataFrame()\ninf_preds_df_stacked = DataFrame()\ncoefdf = DataFrame()\nfor (i, (fold_trn, fold_tst)) in collect(enumerate(folds))\n# (i, (fold_trn, fold_tst)) = (1, folds[1])\n# (i, (fold_trn, fold_tst)) = (2, folds[2])\n\n    # Use tree to get lineage traces for each training and test sample\n    # using projections of taxa into UniProt so these loadings are constant regardless of folds\n    foldPCs = UPfullPCs[fold_trn,:]\n    trn_nns = map(r-&gt;partialsortperm(r, 1:K), eachrow(subsetDij[fold_trn, fold_trn]))\n    tst_nns = map(r-&gt;partialsortperm(r, 1:K), eachrow(subsetDij[fold_tst, fold_trn]))\n    oob_nns = map(r-&gt;partialsortperm(r, 1:K), eachrow(subset_oob_Dij[:, fold_trn]))\n\n    # UPGMA tree building...\n    foldhc = UPGMA_tree(subsetDij[fold_trn, fold_trn])\n    foldtree = readnw(SpectralInference.newickstring(foldhc, trnYdf.Strain_ID[fold_trn]))\n    # ladderize!(foldtree, rev=false)\n    \n    # Make SLE ancester encoding\n    trnXdf_all = map(prewalk(foldtree)) do node\n        tmp = zeros(length(fold_trn))\n        tmp[indexin(getleafnames(node), trnYdf.Strain_ID[fold_trn])] .= 1\n        \"node__$(id(node))\" =&gt; tmp\n    end |&gt; DataFrame;\n    isinternal_fold = map(!isleaf, prewalk(foldtree));\n    # reorder nodes by tree depth\n    treedists = mapinternalnodes(foldtree) do node\n        network_distance(foldtree, node)\n    end\n    trnXdf = trnXdf_all[:, isinternal_fold];\n    trnXdf = trnXdf[:, sortperm(treedists)];\n    rename!(trnXdf, [\"node__$i\" for i in 1:size(trnXdf, 2)])\n    \n    # Get features for each out-of-fold isolate\n    tstXdf = map(tst_nns) do nn\n        trnXdf[nn, :] |&gt;\n        df -&gt; combine(df, [c =&gt; mean for c in 1:size(df, 2)])\n    end |&gt; x-&gt;vcat(x...)\n\n    # Get features for each out-of-bag isolate\n    oobXdf = map(oob_nns) do nn\n        trnXdf[nn, :] |&gt;\n        df -&gt; combine(df, [c =&gt; mean for c in 1:size(df, 2)])\n    end |&gt; x-&gt;vcat(x...)\n\n    # fit lasso model\n    individual_metabolite_results = []\n    for (target_idx, (target, mlabel)) in enumerate(zip(metabolite_names, metabolite_label))\n        # train model on metabolite feature\n        mach = machine(mdl, trnXdf, metab_trnY[fold_trn, target_idx])\n        Base.with_logger(Base.NullLogger()) do\n            fit!(mach, verbosity=0)\n        end\n        \n        # save results of trained model\n        # in fold predictions\n        inf_preds_df_stacked = vcat(inf_preds_df_stacked, DataFrame(\n            :row_id =&gt; fold_trn,\n            :metabolite_name =&gt; target,\n            :metabolite_label =&gt; mlabel,\n            :fold =&gt; ((i-1)%NFOLDS)+1,\n            :resample =&gt; ((i-1)÷NFOLDS)+1,\n            :truth =&gt; metab_trnY[fold_trn, target_idx],\n            :preds =&gt; MLJ.predict(mach, trnXdf),\n        ))\n\n        # out-of-fold predictions\n        oof_preds_df_stacked = vcat(oof_preds_df_stacked, DataFrame(\n            :row_id =&gt; fold_tst,\n            :msk_id =&gt; trnYdf.Strain_ID[fold_tst],\n            :metabolite_name =&gt; target,\n            :metabolite_label =&gt; mlabel,\n            :fold =&gt; ((i-1)%NFOLDS)+1 ,\n            :resample =&gt; ((i-1)÷NFOLDS)+1 ,\n            :truth =&gt; metab_trnY[fold_tst, target_idx],\n            :preds =&gt; MLJ.predict(mach, tstXdf),\n        ))\n\n        # out-of-bag predictions used for consortia predictions\n        oob_preds_df_stacked = vcat(oob_preds_df_stacked, DataFrame(\n            :msk_id =&gt; outofbag_mskids,\n            :metabolite_name =&gt; target,\n            :metabolite_label =&gt; mlabel,\n            :fold =&gt; ((i-1)%NFOLDS)+1 ,\n            :resample =&gt; ((i-1)÷NFOLDS)+1 ,\n            # don't know truth # :truth =&gt; metab_trnY[fold_tst, target_idx],\n            :preds =&gt; MLJ.predict(mach, oobXdf),\n        ))\n\n        # coefs of model\n        coefdf = vcat(coefdf, stack(DataFrame(fitted_params(mach).coefs)) |&gt;\n            df -&gt; begin df[!, :treedist] .= sort(treedists); df end |&gt;\n            df-&gt; DataFrames.select(df,\n                :value =&gt; ByRow(x-&gt;target) =&gt; :metabolite_name,\n                :value =&gt; ByRow(x-&gt;i) =&gt; :fold,\n                :variable =&gt; (x-&gt;split.(x, \"__\")) =&gt; [:treedepth, :class],\n                :variable =&gt; :node_id,\n                :value =&gt; :coef,\n                :treedist,\n            )\n        )\n    end;\n    println(\"on $(i)th resample\")\nend\n\nCSV.write(joinpath(rdir, \"oof_predictions_stacked_SPItreeLASSO_ancestralencoding_lambda=$(λ).csv\"), oof_preds_df_stacked)\nCSV.write(joinpath(rdir, \"oob_predictions_stacked_SPItreeLASSO_ancestralencoding_lambda=$(λ).csv\"), oob_preds_df_stacked)\nCSV.write(joinpath(rdir, \"infold_predictions_stacked_SPItreeLASSO_ancestralencoding_lambda=$(λ).csv\"), inf_preds_df_stacked)\nCSV.write(joinpath(rdir, \"coefs_SPItreeLASSO_ancestralencoding_lambda=$(λ).csv\"), coefdf)\n\non 1th resample\non 2th resample\non 3th resample\non 4th resample\non 5th resample\non 6th resample\non 7th resample\non 8th resample\non 9th resample\non 10th resample\non 11th resample\non 12th resample\non 13th resample\non 14th resample\non 15th resample\non 16th resample\non 17th resample\non 18th resample\non 19th resample\non 20th resample\n\n\n\"/Users/bend/projects/Doran_etal_2023/_research/metabolite_SLE_Lasso_model_outofbag/coefs_SPItreeLASSO_ancestralencoding_lambda=0.001.csv\""
  },
  {
    "objectID": "05_figure_05.html#training-a-lasso-model-on-3-10-pcs-for-comparison",
    "href": "05_figure_05.html#training-a-lasso-model-on-3-10-pcs-for-comparison",
    "title": "Predicting Strain Phenotype",
    "section": "Training a LASSO model on 3 & 10 PCs for comparison",
    "text": "Training a LASSO model on 3 & 10 PCs for comparison\n\n# Takes 1 min\nK = 1 # Make predictions with SPI-LASSO on 1 nearest neighbor\nλ = 1e-3 # regularization coef\nR = 3 # Number of PCs to use for training\nREPS = 5\nNFOLDS = 4\n\nseed!(424242)\ncv = StratifiedCV(nfolds=NFOLDS, shuffle=true);\nfolds = vcat([train_test_pairs(cv, 1:sum(full_train_mask), trnYdf.Species) for i in 1:REPS]...)\n\nXdf = DataFrame(float.(bbmtx_trn), biobank[\"oggs\"].var_names[ogg_mask])\nmdl = MLJLinearModels.LassoRegressor(lambda=λ)\n\n\noob_preds_df_stacked_top3 = DataFrame()\noof_preds_df_stacked_top3 = DataFrame()\ninf_preds_df_stacked_top3 = DataFrame()\ncoefdf_top3 = DataFrame()\nfor (i, (fold_trn, fold_tst)) in collect(enumerate(folds))\n# (i, (fold_trn, fold_tst)) = (1, folds[1])\n# (i, (fold_trn, fold_tst)) = (2, folds[2])\n\n    Xmtx_fold_trn = Matrix(Xdf[fold_trn, :])\n    Xmtx_fold_tst = Matrix(Xdf[fold_tst, :])\n\n    # redo svd for each fold\n    foldusv = svd(Xmtx_fold_trn);\n    PCs_foldtrn = foldusv.U * diagm(foldusv.S)\n    trnXdf = DataFrame(PCs_foldtrn[:, 1:R], [\"PC_$r\" for r in 1:R])\n    tstXdf = DataFrame((projectinLSV(Xmtx_fold_tst, foldusv) * diagm(foldusv.S))[:, 1:R],[\"PC_$r\" for r in 1:R])\n    oobXdf = DataFrame((projectinLSV(oob_ogg_counts_bborder, foldusv) * diagm(foldusv.S))[:, 1:R],[\"PC_$r\" for r in 1:R])\n\n    # fit lasso model\n    individual_metabolite_results = []\n    for (target_idx, (target, mlabel)) in enumerate(zip(metabolite_names, metabolite_label))\n        # train model on metabolite feature\n        mach = machine(mdl, trnXdf, metab_trnY[fold_trn, target_idx])\n        Base.with_logger(Base.NullLogger()) do\n            fit!(mach, verbosity=0)\n        end\n        \n        # save results of trained model\n        # in fold predictions\n        inf_preds_df_stacked_top3 = vcat(inf_preds_df_stacked_top3, DataFrame(\n            :row_id =&gt; fold_trn,\n            :metabolite_name =&gt; target,\n            :metabolite_label =&gt; mlabel,\n            :fold =&gt; ((i-1)%NFOLDS)+1,\n            :resample =&gt; ((i-1)÷NFOLDS)+1,\n            :truth =&gt; metab_trnY[fold_trn, target_idx],\n            :preds =&gt; MLJ.predict(mach, trnXdf),\n        ))\n\n        # out-of-fold predictions\n        oof_preds_df_stacked_top3 = vcat(oof_preds_df_stacked_top3, DataFrame(\n            :row_id =&gt; fold_tst,\n            :msk_id =&gt; trnYdf.Strain_ID[fold_tst],\n            :metabolite_name =&gt; target,\n            :metabolite_label =&gt; mlabel,\n            :fold =&gt; ((i-1)%NFOLDS)+1 ,\n            :resample =&gt; ((i-1)÷NFOLDS)+1 ,\n            :truth =&gt; metab_trnY[fold_tst, target_idx],\n            :preds =&gt; MLJ.predict(mach, tstXdf),\n        ))\n\n        # out-of-bag predictions used for consortia predictions\n        oob_preds_df_stacked_top3 = vcat(oob_preds_df_stacked_top3, DataFrame(\n            :msk_id =&gt; outofbag_mskids,\n            :metabolite_name =&gt; target,\n            :metabolite_label =&gt; mlabel,\n            :fold =&gt; ((i-1)%NFOLDS)+1 ,\n            :resample =&gt; ((i-1)÷NFOLDS)+1 ,\n            # don't know truth # :truth =&gt; metab_trnY[fold_tst, target_idx],\n            :preds =&gt; MLJ.predict(mach, oobXdf),\n        ))\n\n        # coefs of model\n        coefdf_top3 = vcat(coefdf_top3, stack(DataFrame(fitted_params(mach).coefs)) |&gt;\n            df-&gt; DataFrames.select(df,\n                :value =&gt; ByRow(x-&gt;target) =&gt; :metabolite_name,\n                :value =&gt; ByRow(x-&gt;i) =&gt; :fold,\n                :variable =&gt; :ogg,\n                :value =&gt; :coef,\n            )\n        )\n    end;\n    println(\"on $(i)th resample\")\nend\n\nCSV.write(joinpath(rdir, \"oob_predictions_stacked_top3PCs_lambda=$(λ).csv\"), oob_preds_df_stacked_top3)\nCSV.write(joinpath(rdir, \"oof_predictions_stacked_top3PCs_lambda=$(λ).csv\"), oof_preds_df_stacked_top3)\nCSV.write(joinpath(rdir, \"infold_predictions_stacked_top3PCs_lambda=$(λ).csv\"), inf_preds_df_stacked_top3)\nCSV.write(joinpath(rdir, \"coefs_top3PCs_lambda=$(λ).csv\"), coefdf_top3)\n\non 1th resample\non 2th resample\non 3th resample\non 4th resample\non 5th resample\non 6th resample\non 7th resample\non 8th resample\non 9th resample\non 10th resample\non 11th resample\non 12th resample\non 13th resample\non 14th resample\non 15th resample\non 16th resample\non 17th resample\non 18th resample\non 19th resample\non 20th resample\n\n\n\"/Users/bend/projects/Doran_etal_2023/_research/metabolite_SLE_Lasso_model_outofbag/coefs_top3PCs_lambda=0.001.csv\"\n\n\n\n# Takes 1 min\nK = 1 # Make predictions with SPI-LASSO on 1 nearest neighbor\nλ = 1e-3 # regularization coef\nR = 10 # Number of PCs to use for training\nREPS = 5\nNFOLDS = 4\n\nseed!(424242)\ncv = StratifiedCV(nfolds=NFOLDS, shuffle=true);\nfolds = vcat([train_test_pairs(cv, 1:sum(full_train_mask), trnYdf.Species) for i in 1:REPS]...)\n\nXdf = DataFrame(float.(bbmtx_trn), biobank[\"oggs\"].var_names[ogg_mask])\nmdl = MLJLinearModels.LassoRegressor(lambda=λ)\n\n\noob_preds_df_stacked_top10 = DataFrame()\noof_preds_df_stacked_top10 = DataFrame()\ninf_preds_df_stacked_top10 = DataFrame()\ncoefdf_top10 = DataFrame()\nfor (i, (fold_trn, fold_tst)) in collect(enumerate(folds))\n# (i, (fold_trn, fold_tst)) = (1, folds[1])\n# (i, (fold_trn, fold_tst)) = (2, folds[2])\n\n    Xmtx_fold_trn = Matrix(Xdf[fold_trn, :])\n    Xmtx_fold_tst = Matrix(Xdf[fold_tst, :])\n\n    # redo svd for each fold\n    foldusv = svd(Xmtx_fold_trn);\n    PCs_foldtrn = foldusv.U * diagm(foldusv.S)\n    trnXdf = DataFrame(PCs_foldtrn[:, 1:R], [\"PC_$r\" for r in 1:R])\n    tstXdf = DataFrame((projectinLSV(Xmtx_fold_tst, foldusv) * diagm(foldusv.S))[:, 1:R],[\"PC_$r\" for r in 1:R])\n    oobXdf = DataFrame((projectinLSV(oob_ogg_counts_bborder, foldusv) * diagm(foldusv.S))[:, 1:R],[\"PC_$r\" for r in 1:R])\n\n    # fit lasso model\n    individual_metabolite_results = []\n    for (target_idx, (target, mlabel)) in enumerate(zip(metabolite_names, metabolite_label))\n        # train model on metabolite feature\n        mach = machine(mdl, trnXdf, metab_trnY[fold_trn, target_idx])\n        Base.with_logger(Base.NullLogger()) do\n            fit!(mach, verbosity=0)\n        end\n        \n        # save results of trained model\n        # in fold predictions\n        inf_preds_df_stacked_top10 = vcat(inf_preds_df_stacked_top10, DataFrame(\n            :row_id =&gt; fold_trn,\n            :metabolite_name =&gt; target,\n            :metabolite_label =&gt; mlabel,\n            :fold =&gt; ((i-1)%NFOLDS)+1,\n            :resample =&gt; ((i-1)÷NFOLDS)+1,\n            :truth =&gt; metab_trnY[fold_trn, target_idx],\n            :preds =&gt; MLJ.predict(mach, trnXdf),\n        ))\n\n        # out-of-fold predictions\n        oof_preds_df_stacked_top10 = vcat(oof_preds_df_stacked_top10, DataFrame(\n            :row_id =&gt; fold_tst,\n            :msk_id =&gt; trnYdf.Strain_ID[fold_tst],\n            :metabolite_name =&gt; target,\n            :metabolite_label =&gt; mlabel,\n            :fold =&gt; ((i-1)%NFOLDS)+1 ,\n            :resample =&gt; ((i-1)÷NFOLDS)+1 ,\n            :truth =&gt; metab_trnY[fold_tst, target_idx],\n            :preds =&gt; MLJ.predict(mach, tstXdf),\n        ))\n\n        # out-of-bag predictions used for consortia predictions\n        oob_preds_df_stacked_top10 = vcat(oob_preds_df_stacked_top10, DataFrame(\n            :msk_id =&gt; outofbag_mskids,\n            :metabolite_name =&gt; target,\n            :metabolite_label =&gt; mlabel,\n            :fold =&gt; ((i-1)%NFOLDS)+1 ,\n            :resample =&gt; ((i-1)÷NFOLDS)+1 ,\n            # don't know truth # :truth =&gt; metab_trnY[fold_tst, target_idx],\n            :preds =&gt; MLJ.predict(mach, oobXdf),\n        ))\n\n        # coefs of model\n        coefdf_top10 = vcat(coefdf_top10, stack(DataFrame(fitted_params(mach).coefs)) |&gt;\n            df-&gt; DataFrames.select(df,\n                :value =&gt; ByRow(x-&gt;target) =&gt; :metabolite_name,\n                :value =&gt; ByRow(x-&gt;i) =&gt; :fold,\n                :variable =&gt; :ogg,\n                :value =&gt; :coef,\n            )\n        )\n    end;\n    println(\"on $(i)th resample\")\nend\n\nCSV.write(joinpath(rdir, \"oob_predictions_stacked_top10PCs_lambda=$(λ).csv\"), oob_preds_df_stacked_top10)\nCSV.write(joinpath(rdir, \"oof_predictions_stacked_top10PCs_lambda=$(λ).csv\"), oof_preds_df_stacked_top10)\nCSV.write(joinpath(rdir, \"infold_predictions_stacked_top10PCs_lambda=$(λ).csv\"), inf_preds_df_stacked_top10)\nCSV.write(joinpath(rdir, \"coefs_top10PCs_lambda=$(λ).csv\"), coefdf_top10)\n\non 1th resample\non 2th resample\non 3th resample\non 4th resample\non 5th resample\non 6th resample\non 7th resample\non 8th resample\non 9th resample\non 10th resample\non 11th resample\non 12th resample\non 13th resample\non 14th resample\non 15th resample\non 16th resample\non 17th resample\non 18th resample\non 19th resample\non 20th resample\n\n\n\"/Users/bend/projects/Doran_etal_2023/_research/metabolite_SLE_Lasso_model_outofbag/coefs_top10PCs_lambda=0.001.csv\""
  },
  {
    "objectID": "05_figure_05.html#comparison-of-models",
    "href": "05_figure_05.html#comparison-of-models",
    "title": "Predicting Strain Phenotype",
    "section": "Comparison of models",
    "text": "Comparison of models\n\n# rdir = projectdir(\"_research\", \"metabolite_SLE_Lasso_model\") |&gt; mkpath\nλ = 1e-3\nREPS = 5\nNFOLDS = 4\n\noof_preds_df_stacked = CSV.read(joinpath(rdir, \"oof_predictions_stacked_SPItreeLASSO_ancestralencoding_lambda=$(λ).csv\"), DataFrame)\ncoefdf = CSV.read(joinpath(rdir, \"coefs_SPItreeLASSO_ancestralencoding_lambda=$(λ).csv\"), DataFrame);\n\noof_preds_df_stacked_top3 = CSV.read(joinpath(rdir, \"oof_predictions_stacked_top3PCs_lambda=$(λ).csv\"), DataFrame)\ncoefdf_top3 = CSV.read(joinpath(rdir, \"coefs_top3PCs_lambda=$(λ).csv\"), DataFrame);\n\noof_preds_df_stacked_top10 = CSV.read(joinpath(rdir, \"oof_predictions_stacked_top10PCs_lambda=$(λ).csv\"), DataFrame)\ncoefdf_top10 = CSV.read(joinpath(rdir, \"coefs_top10PCs_lambda=$(λ).csv\"), DataFrame);\n\n\noof_preds_df_stacked\n\n56960×8 DataFrame56935 rows omitted\n\n\n\nRow\nrow_id\nmsk_id\nmetabolite_name\nmetabolite_label\nfold\nresample\ntruth\npreds\n\n\n\nInt64\nString\nString\nString\nInt64\nInt64\nFloat64\nFloat64\n\n\n\n\n1\n342\nMSK.19.38\nAcetate\nAcetate\n1\n1\n2.35396\n2.61133\n\n\n2\n90\nMSK.22.14\nAcetate\nAcetate\n1\n1\n0.198325\n0.694874\n\n\n3\n121\nMSK.22.19\nAcetate\nAcetate\n1\n1\n0.906867\n0.535348\n\n\n4\n223\nMSK.18.5\nAcetate\nAcetate\n1\n1\n2.45019\n3.10572\n\n\n5\n163\nMSK.19.91\nAcetate\nAcetate\n1\n1\n0.962586\n1.80566\n\n\n6\n285\nMSK.17.63\nAcetate\nAcetate\n1\n1\n3.0863\n2.61133\n\n\n7\n82\nMSK.19.93\nAcetate\nAcetate\n1\n1\n-0.0611344\n0.0224312\n\n\n8\n133\nDFI.1.38\nAcetate\nAcetate\n1\n1\n2.85979\n1.87079\n\n\n9\n229\nMSK.22.90\nAcetate\nAcetate\n1\n1\n1.40515\n1.14363\n\n\n10\n11\nMSK.17.85\nAcetate\nAcetate\n1\n1\n1.59181\n1.40582\n\n\n11\n268\nMSK.22.113\nAcetate\nAcetate\n1\n1\n2.9636\n2.97771\n\n\n12\n243\nDFI.1.133\nAcetate\nAcetate\n1\n1\n1.52278\n1.2134\n\n\n13\n210\nMSK.8.22\nAcetate\nAcetate\n1\n1\n2.27702\n1.39391\n\n\n⋮\n⋮\n⋮\n⋮\n⋮\n⋮\n⋮\n⋮\n⋮\n\n\n56949\n317\nMSK.15.37\nValine\nValine\n4\n5\n-0.376526\n-0.190937\n\n\n56950\n208\nMSK.23.18\nValine\nValine\n4\n5\n0.367251\n0.188958\n\n\n56951\n36\nMSK.20.13\nValine\nValine\n4\n5\n-0.0974977\n-0.125681\n\n\n56952\n149\nDFI.1.54\nValine\nValine\n4\n5\n0.336755\n0.0613872\n\n\n56953\n335\nMSK.18.78\nValine\nValine\n4\n5\n-0.903232\n-0.343759\n\n\n56954\n170\nMSK.17.56\nValine\nValine\n4\n5\n1.1932\n0.133518\n\n\n56955\n264\nMSK.22.64\nValine\nValine\n4\n5\n0.0885085\n0.0162928\n\n\n56956\n24\nMSK.11.50\nValine\nValine\n4\n5\n0.384005\n0.382765\n\n\n56957\n106\nMSK.15.52\nValine\nValine\n4\n5\n1.23039\n0.0192463\n\n\n56958\n148\nMSK.23.42\nValine\nValine\n4\n5\n0.488847\n0.0389307\n\n\n56959\n345\nMSK.20.44\nValine\nValine\n4\n5\n0.0122909\n-0.125681\n\n\n56960\n294\nMSK.23.63\nValine\nValine\n4\n5\n-0.182895\n-0.0852253\n\n\n\n\n\n\n\nslelassopltdf = oof_preds_df_stacked |&gt;\n    df -&gt; rename(df, :preds =&gt; :preds_SLE) |&gt;\n    df -&gt; select(df, [:row_id, :metabolite_label, :fold, :resample, :truth, :preds_SLE]) |&gt;\n    df -&gt; groupby(df, [:metabolite_label, :fold, :resample]) |&gt;\n    df -&gt; combine(df,\n        [:preds_SLE, :truth] =&gt; ((yhat, y)-&gt;rsquared(yhat,y)) =&gt; :rsquared_SLE, \n    ) |&gt;\n    df -&gt; groupby(df, [:metabolite_label]) |&gt;\n    df -&gt; DataFrames.transform(df, \n        :rsquared_SLE =&gt; mean,\n    ) |&gt;\n    df -&gt; stack(df, :rsquared_SLE) |&gt;\n    df -&gt; sort(df, [:metabolite_label, :resample, :fold]) |&gt;\n    df -&gt; rename(df, :variable =&gt; :measure_model, :value =&gt; :rsquared)\nCSV.write(joinpath(supptbl_dir, \"Supplementary_Table_6A.tsv\"), slelassopltdf, delim=\"\\t\")\n\nslelassopltdf |&gt;\n    df -&gt; groupby(df, :metabolite_label) |&gt;\n    df -&gt; combine(df, :rsquared =&gt; mean)\nCSV.write(joinpath(supptbl_dir, \"Supplementary_Table_6B.tsv\"), slelassopltdf, delim=\"\\t\");\n\n\nR squared plots\n\nslelassopltdf = oof_preds_df_stacked |&gt;\n    df -&gt; rename(df, :preds =&gt; :preds_SLE) |&gt;\n    df -&gt; select(df, [:row_id, :metabolite_label, :fold, :resample, :truth, :preds_SLE]) |&gt;\n    df -&gt; groupby(df, [:metabolite_label, :fold, :resample]) |&gt;\n    df -&gt; combine(df,\n        [:preds_SLE, :truth] =&gt; ((yhat, y)-&gt;rsquared(yhat,y)) =&gt; :rsquared_SLE, \n    ) |&gt;\n    df -&gt; groupby(df, [:metabolite_label]) |&gt;\n    df -&gt; DataFrames.transform(df, \n        :rsquared_SLE =&gt; mean,\n        [:fold, :resample] =&gt; ((x, y) -&gt; x.*y) =&gt; :fold_iter,\n    ) |&gt;\n    df -&gt; stack(df, :rsquared_SLE) |&gt;\n    df -&gt; sort(df, [:metabolite_label, :fold_iter])\n\ntop3lassopltdf = oof_preds_df_stacked_top3 |&gt;\n    df -&gt; rename(df, :preds =&gt; :preds_top3) |&gt;\n    df -&gt; select(df, [:row_id, :metabolite_label, :fold, :resample, :truth, :preds_top3]) |&gt;\n    df -&gt; groupby(df, [:metabolite_label, :fold, :resample]) |&gt;\n    df -&gt; combine(df,\n        [:preds_top3, :truth] =&gt; ((yhat, y)-&gt;rsquared(yhat,y)) =&gt; :rsquared_top3, \n    ) |&gt;\n    df -&gt; groupby(df, [:metabolite_label]) |&gt;\n    df -&gt; DataFrames.transform(df, \n        :rsquared_top3 =&gt; mean,\n        [:fold, :resample] =&gt; ((x, y) -&gt; x.*y) =&gt; :fold_iter,\n    ) |&gt;\n    df -&gt; stack(df, :rsquared_top3) |&gt;\n    df -&gt; sort(df, [:metabolite_label, :fold_iter]) |&gt;\n    df -&gt; insertcols!(df, :rsquared_SLE_mean =&gt; slelassopltdf.rsquared_SLE_mean)\n\ninsertcols!(slelassopltdf, :rsquared_top3_mean =&gt; top3lassopltdf.rsquared_top3_mean)\n\npltdf_full = vcat(select(slelassopltdf, [:metabolite_label, :rsquared_SLE_mean, :rsquared_top3_mean, :variable, :value]),\n             select(top3lassopltdf, [:metabolite_label, :rsquared_SLE_mean, :rsquared_top3_mean, :variable, :value])) |&gt;\n    df -&gt; sort(df, :rsquared_SLE_mean)\n\nsigresults = pltdf_full |&gt;\n    df -&gt; groupby(df, :metabolite_label) |&gt;\n    df -&gt; combine(df,\n        :rsquared_SLE_mean =&gt; first =&gt; :rsquared_SLE_mean,\n        :rsquared_top3_mean =&gt; first =&gt; :rsquared_top3_mean,\n        [:variable, :value] =&gt; ((grp, rsqval) -&gt; \n            pvalue(UnequalVarianceTTest(rsqval[grp.==\"rsquared_SLE\"], rsqval[grp.==\"rsquared_top3\"]), tail=:right)) =&gt; :pval\n            # pvalue(MannWhitneyUTest(rsqval[grp.==\"rsquared_SLE\"], rsqval[grp.==\"rsquared_top3\"]), tail=:right)) =&gt; :pval\n    ) |&gt;\n    df -&gt; DataFrames.transform(df, :pval =&gt; (p-&gt;adjust(p, Bonferroni())) =&gt; :pval_bon) |&gt;\n    df -&gt; DataFrames.transform(df, :pval_bon =&gt; (p-&gt;floor.(Int, log10.(1 ./ p))) =&gt; :poweroftest);\n\npredictablemetabolites = filter(\n    [:rsquared_SLE_mean, :rsquared_top3_mean, :pval_bon] =&gt; \n        (sle_mean, top3_mean, σ) -&gt; sle_mean &gt; 0.5 || top3_mean &gt; 0.5 || σ &lt; 0.05,\n    sigresults\n);\n\n\npltdf = filter(:metabolite_label =&gt; ∈(predictablemetabolites.metabolite_label), pltdf_full);\nplot(\n    ylabel=\"out-of-fold R²\",\n    bottommargin=12Plots.Measures.mm,\n    xrotation=45,\n    legend=:outertop,\n    legendcolumns=2,\n    size=(600, 300),\n    xflip=true, \n)\n@df pltdf dotplot!(\n    string.(round.(:rsquared_SLE_mean, digits=6)), :value,\n    group=:variable,\n    mode=:none,\n    side=[:left :right],\n    alpha=.7,\n    markerstrokewidth=0,\n    xticks=((1:length(unique(:metabolite_label))).-.5, unique(:metabolite_label)),\n    ylims=(-Inf, 1.2),\n    widen=true,\n    # label=\"Full lasso\",\n    c=[3 4],\n)\nhline!([0], c=:black, lw=.5, linestyle=:dash)\n@df predictablemetabolites annotate!(\n    string.(round.(:rsquared_SLE_mean, digits=6)), \n    ones(nrow(sigresults)) .+ 0.01,\n    text.(\n        repeat.(\"*\", (:poweroftest .&gt;=10) .+ (:poweroftest .&gt;=5) .+ (:poweroftest .&gt;=1)),\n        12, :left, rotation=90\n    ),\n)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nscatter plots\n\nTop 3 PCs plot\n\ntop3_explainedvar = map(folds) do (fold_trn, fold_tst)\n    Xmtx_fold_trn = Matrix(Xdf[fold_trn, :])\n    foldusv = svd(Xmtx_fold_trn)\n    ev = explainedvariance(foldusv.S) .* 100\n    sum(ev[1:3])\nend |&gt; mean;\n\n\n\nr = 5\npredsdf = filter(:metabolite_name =&gt; ==(metabolite_name), oof_preds_df_stacked_top3) |&gt;\n    df -&gt; filter(:resample =&gt; ==(r), df)\nspeciescolors_ordered = get.(Ref(species_color_dict), trnYdf.Species[predsdf.row_id], :grey)\n@df predsdf scatter(\n    :preds, :truth,\n    group=trnYdf.Species[:row_id],\n    c=speciescolors_ordered,\n    lims=extrema(vcat(:preds, :truth)),\n    widen=true,\n    ratio=1,\n    size=(550,600),\n    legend=:outerbottom,\n    legend_column=2,\n    markerstrokewidth=.1,\n    alpha=.8,\n    title=\"top 10 PCS ($(round(top3_explainedvar, digits=1))%)\",\n    xlabel=\"$metabolite_name (out-of-fold prediction)\",\n    ylabel=\"$metabolite_name (log2FC)\",\n)\nplot!(identity, -20, 20, c=:black, alpha=.5, lw=0.5)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTop 10 PCs plot\n\ntop10_explainedvar = map(folds) do (fold_trn, fold_tst)\n    Xmtx_fold_trn = Matrix(Xdf[fold_trn, :])\n    foldusv = svd(Xmtx_fold_trn)\n    ev = explainedvariance(foldusv.S) .* 100\n    sum(ev[1:10])\nend |&gt; mean;\n\n\nr = 5\npredsdf = filter(:metabolite_name =&gt; ==(metabolite_name), oof_preds_df_stacked_top10) |&gt;\n    df -&gt; filter(:resample =&gt; ==(r), df)\nspeciescolors_ordered = get.(Ref(species_color_dict), trnYdf.Species[predsdf.row_id], :grey)\n@df predsdf scatter(\n    :preds, :truth,\n    group=trnYdf.Species[:row_id],\n    c=speciescolors_ordered,\n    lims=extrema(vcat(:preds, :truth)),\n    widen=true,\n    ratio=1,\n    size=(550,600),\n    legend=:outerbottom,\n    legend_column=2,\n    markerstrokewidth=.1,\n    alpha=.8,\n    title=\"top 10 PCS ($(round(top10_explainedvar, digits=1))%)\",\n    xlabel=\"$metabolite_name (out-of-fold prediction)\",\n    ylabel=\"$metabolite_name (log2FC)\",\n)\nplot!(identity, -20, 20, c=:black, alpha=.5, lw=0.5)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSLE plot\n\n\nr = 5\npredsdf = filter(:metabolite_name =&gt; ==(metabolite_name), oof_preds_df_stacked) |&gt;\n    df -&gt; filter(:resample =&gt; ==(r), df)\nspeciescolors_ordered = get.(Ref(species_color_dict), trnYdf.Species[predsdf.row_id], :grey)\n@df predsdf scatter(\n    :preds, :truth,\n    group=trnYdf.Species[:row_id],\n    c=speciescolors_ordered,\n    lims=extrema(vcat(:preds, :truth)),\n    widen=true,\n    ratio=1,\n    size=(550,600),\n    legend=:outerbottom,\n    legend_column=2,\n    markerstrokewidth=.1,\n    alpha=.8,\n    xlabel=\"$metabolite_name (out-of-fold prediction)\",\n    ylabel=\"$metabolite_name (log2FC)\",\n)\nplot!(identity, -20, 20, c=:black, alpha=.5, lw=0.5)"
  },
  {
    "objectID": "05_figure_05.html#plot-tree-and-metabolites",
    "href": "05_figure_05.html#plot-tree-and-metabolites",
    "title": "Predicting Strain Phenotype",
    "section": "Plot tree and metabolites",
    "text": "Plot tree and metabolites\n\n# plot cladogram\nstrvar_tree_hc = UPGMA_tree(subsetDij ./ size(biobank[\"UPorder_oggs\"], 2))\nsubsettreestring = SpectralInference.newickstring(strvar_tree_hc, trnYdf.Strain_ID)\nsubsettree = readnw(subsettreestring);\nplot(strvar_tree_hc, \n    # size=(600, 900),\n    lw=.5,\n    yflip=true, \n    xmirror=true,\n    xticks=:none,\n    permute=(:y, :x),\n    grid=false,\n    tickdirection=:none,\n    rightmargin=1Plots.Measures.mm, \n    label=\"\",\n    framestyle=:grid,\n)\n\n# plot annotation rectangles\nrectangle(w, h, x, y) = Shape(x .+ [0,w,w,0], y .+ [0,0,h,h])\nspeciesvector = trnYdf.Species[strvar_tree_hc.order]\nbreaks = findall(speciesvector[begin:(end-1)] .!= speciesvector[2:end])[Not([10, 11, 12, 13, 14,15])]\nedges = [(s, e) for (s,e) in zip(vcat([0],breaks), vcat(breaks, [length(speciesvector)]))];\nrects = [rectangle(2,(e-s),0,s+.5) for (s,e) in zip(vcat([0],breaks), vcat(breaks, [length(speciesvector)]))];\nrectspeciescolors = permutedims(speciescolordf.color[indexin(speciesvector[first.(edges).+1], speciescolordf.species_name)]);\nfancy_treeplot = plot!(permutedims(rects), fill=0.35, lw=0, c=rectspeciescolors, label=\"\")\n\n# plot legend for tree\nspecieslabels= [\n    \"Bacteroides uniformis\",\n    \"Phocaeicola vulgatus\",\n    \"Bacteroides thetaiotaomicron\",\n    \"[Ruminococcus] gnavus\",\n    \"Bifidobacterium breve\",\n    \"[Eubacterium] rectale\",\n    \"Dorea formicigenerans\",\n    \"Coprococcus comes\",\n    \"Blautia luti & Blautia wexlerae\",\n    \"Anaerostipes hadrus\",\n]\nfancy_treeplot = plot!(zeros(1, 10), \n    legend=:left,\n    labels=permutedims(reverse(specieslabels)), \n    c=reverse(rectspeciescolors),\n    legendfontsize=5,\n);\n\n# plot metabolite heatmap\ntreeorder = indexin(getleafnames(subsettree), trnYdf.Strain_ID);\nhplot = heatmap(metab_trnY[treeorder, :],\n    c=:bwr, clims=getlims(metab_trnY),\n    xticks=(1:size(metab_trnY,2), metabolite_label),\n    xrotation=90, xtickfontsize=7,\n    yticks=:none,\n);\n\nplot(fancy_treeplot, hplot, size=(900,900))\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\nZooming in we can look at A. hadrus, and its measured Acetate relative concentration and our prediction for those Acetate relative concentration\n\n## Plot Hadrus tree with metabolite truth & predictions\n\n# tree data\ntreeorder = indexin(getleafnames(subsettree), trnYdf.Strain_ID);\nhadrusnames = trnYdf.Strain_ID[findall(contains.(trnYdf.Species, \"hadrus\"))]\nhadrus_treeidxs = indexin(hadrusnames, getleafnames(subsettree));\nhadrustree = readnw(NewickTree.nwstr(NewickTree.extract(subsettree, hadrusnames)))\nhadrusnames = getleafnames(hadrustree)\nhadrus_treeidxs = indexin(hadrusnames, getleafnames(subsettree));\n\n# tree plot\ntp = plot(hadrustree, fs=6, \n    ylabel=\"A. hadrus\", \n    rightmargin=15Plots.mm, \n    leftmargin=5Plots.mm,\n    framestyle=:grid,\n    ticks=false,\n)\n\n# heatmap data\npltdf = filter(:metabolite_name =&gt; ==(\"Acetate\"), oof_preds_df_stacked) |&gt;\n    df -&gt; filter(:resample =&gt; ==(5), df) |&gt;\n    df -&gt; sort(df, :row_id);\nhadruspltdf = pltdf[treeorder, :][hadrus_treeidxs, :];\npltmtx = Matrix(hadruspltdf[:, [:truth, :preds]])\n\n# heatmap\nhp = heatmap(pltmtx,\n    c=:bwr, clims=getlims(pltmtx),\n    xticks=(1:2, [\"measured\", \"SLE prediction\"]),\n    xrotation=45,\n    yticks=false,\n    framestyle=:box\n)\n\n# combined plot\nlayout = @layout [a{.4w} b]\nplot(tp, hp, layout=layout, link=:y, size=(600,600))"
  },
  {
    "objectID": "05_figure_05.html#plot-example-fold-tree",
    "href": "05_figure_05.html#plot-example-fold-tree",
    "title": "Predicting Strain Phenotype",
    "section": "Plot example fold tree",
    "text": "Plot example fold tree\n\nfold_trn = folds[1][1]\nfolddij = subsetDij[fold_trn, fold_trn] ./ size(biobank[\"UPorder_oggs\"], 2)\nfoldtree_hc = UPGMA_tree(folddij)\nfoldtree = readnw(SpectralInference.newickstring(foldtree_hc, trnYdf.Strain_ID[fold_trn]));\nladderize!(foldtree)\n\nbranchcolors = map(prewalk(foldtree)) do node\n    mskids = name.(getleaves(node))\n    species_id = mode(trnYdf.Species[indexin(mskids, trnYdf.Strain_ID)])\n    get.(Ref(species_color_dict), species_id, :grey)\nend |&gt; vec |&gt; x-&gt;x[2:end] |&gt; permutedims\n\nplot(foldtree, \n    linecolor=branchcolors,\n    title=\"Fold tree (#leaves = $(length(getleaves(foldtree))))\",\n    size=(800,800),\n    fs=1,\n    rightmargin=5.5Plots.cm,\n    framestyle=:grid, ticks=false\n)\n\n# species \nspeciesvector = trnYdf.Species[fold_trn][indexin(getleafnames(foldtree), trnYdf.Strain_ID[fold_trn])];\nfor (i, (k,v)) in enumerate(zip(speciescolordf.species_name, speciescolordf.color))\n    yval = median(findall(==(k), speciesvector))\n    annotate!(4.5, yval, text(k, 9, :left, v))\nend\nplot!()"
  },
  {
    "objectID": "04_figure_04.html",
    "href": "04_figure_04.html",
    "title": "Interpreting New Strain Relationships",
    "section": "",
    "text": "using DrWatson\n@quickactivate projectdir()\n\nusing SpectralInference\nusing NewickTree\nusing HypothesisTests\nusing MultipleTesting: adjust, Bonferroni, BenjaminiHochberg\nusing CSV, DataFrames\nusing StatsBase\nusing Muon\nusing Random: shuffle, seed!\nusing CategoricalArrays: cut, recode!\nusing LaTeXStrings\nusing Images\n\nusing StatsPlots\ntheme(:default, grid=false, label=false, tickdir=:out)\ninclude(srcdir(\"helpers.jl\"))\n\nbbdir = datadir(\"exp_pro\", \"BB669\") |&gt; mkpath;\npdir = plotsdir(\"strain_variation_tree_and_tests\") |&gt; mkpath;\nrdir = projectdir(\"_research\", \"strain_variation_wilcoxon_tests\") |&gt; mkpath\n\n\"/Users/bend/projects/Doran_etal_2023/_research/strain_variation_wilcoxon_tests\""
  },
  {
    "objectID": "04_figure_04.html#statistical-tests-through-the-spectral-tree",
    "href": "04_figure_04.html#statistical-tests-through-the-spectral-tree",
    "title": "Interpreting New Strain Relationships",
    "section": "Statistical tests through the spectral tree",
    "text": "Statistical tests through the spectral tree\nGiven that we are able to create a spectral tree that respects taxonomic relationships and even captures sub-species groupings that corresponds with host environment, we were interested in understanding what genomic signatures were describing these sub-species groupings. However, because these sub-species groups a specifically defined by these genomic features, assumptions of independence typical to statistical tests are violated. Therefore we use a more stringent test to determine whether a given OGG is differentially abundant by using how likely it is for any of the features we are looking at to be significant before deciding if each individual OGG feature is significant.\nSpecifically to determine whether a given OGG is differentially abundant in a statistically significant way across two groups (‘group A’ and ‘group B’) that arise from a common node in the Spectral Tree, we first generate a ‘reference p-value’ and a ‘null distribution’. The reference p-value signifies the difference in \\(OGG_i\\) across the two groups (Wilcoxon test). To generate a null distribution of p-values, we create 100 permutations of the distributions between groups A and B that randomly shuffles entries in the two groups. For all OGGs within the Spectral Tree, we compute a distribution of the most significant p-values across all permutations. The Q-value for a given OGG is computed as the number of p-values in the null distribution that are less than the reference p-value (\\(P\\)) relative to the total number of p-values in the null distribution (equation).\n\\[Q = \\frac{N_{p_{perm}} &lt; N_{p_{ref}}}{N_{p_{perm}}}\\]\n\nFiltering to species that have &gt; 20 strain replicates\n\nuniprot = readh5ad(datadir(\"exp_raw\", \"UP7047\", \"2020_02_UP7047.h5ad\"))\nbiobank = readh5mu(datadir(\"exp_raw\", \"BB669\", \"BB669.h5mu\"))\n\n┌ Warning: Cannot join columns with the same name because var_names are intersecting.\n└ @ Muon /Users/bend/.julia/packages/Muon/eLqpV/src/mudata.jl:351\n\n\nMuData object 669 ✕ 21475\n└ metabolites_foldchange\n  AnnData object 669 ✕ 50\n└ UPorder_oggs\n  AnnData object 669 ✕ 10177\n└ oggs\n  AnnData object 669 ✕ 11248\n\n\n\nupmtx = uniprot.X[:, :]\nupusv = svd(upmtx)\nbbmtx = biobank[\"UPorder_oggs\"].X[:,:]\nsize(bbmtx)\n\n(669, 10177)\n\n\n\nkeptspecies = sort(filter(x-&gt; last(x) &gt;= 20, countmap(biobank.obs.Species)), byvalue=true, rev=true)\nfilter!(!=(\"unclassified\"), keptspecies)\n# species =&gt; number of strains belonging to that species\n\nOrderedCollections.OrderedDict{String, Int64} with 12 entries:\n  \"Phocaeicola vulgatus\"         =&gt; 88\n  \"[Ruminococcus] gnavus\"        =&gt; 41\n  \"Bacteroides thetaiotaomicron\" =&gt; 35\n  \"Anaerostipes hadrus\"          =&gt; 31\n  \"Bacteroides uniformis\"        =&gt; 27\n  \"unclassified\"                 =&gt; 26\n  \"Blautia luti\"                 =&gt; 24\n  \"Bifidobacterium breve\"        =&gt; 24\n  \"Coprococcus comes\"            =&gt; 23\n  \"Dorea formicigenerans\"        =&gt; 22\n  \"Blautia wexlerae\"             =&gt; 21\n  \"[Eubacterium] rectale\"        =&gt; 20\n\n\nI had previously calculated which strains belonged to these species when I saved the biobank dataset\n\nstrvarmtx = bbmtx[biobank.obs.kept_species.==1,:];\n@show size(strvarmtx)\n\nstrvarobs = biobank.obs[biobank.obs.kept_species.==1, :]\nstrvar_obsnames = strvarobs.Strain_ID\n\n# infer hierarchical relationships of just the species with\n# greater than 20 strain replicates\nuhat = projectinLSV(strvarmtx, upusv)\ndij = spectraldistances(uhat, upusv.S; alpha=1.5, q=.75) ./ size(uniprot, 2)\nstrvartree_hc = UPGMA_tree(dij)\nstrvartree = readnw(SpectralInference.newickstring(strvartree_hc, strvar_obsnames))\n# ladderize!(strvartree)\n\n## write out tree\nopen(joinpath(bbdir, \"strvar-spitree.nw\"), \"w\") do io\n    writenw(io, strvartree)\nend\n\nsize(strvarmtx) = (356, 10177)\n\n\n12064\n\n\n\ncountmap(strvarobs.NCBI_Phylum)\n\nDict{String, Int64} with 3 entries:\n  \"Firmicutes\"     =&gt; 182\n  \"Bacteroidetes\"  =&gt; 150\n  \"Actinobacteria\" =&gt; 24\n\n\n\nphylum_color_dict = Dict(k=&gt;v for (k,v) in zip(unique(strvarobs.NCBI_Phylum), palette(:Accent)[[4,2,3]]));\nphylum_linecolors = map(prewalk(strvartree)) do node; strvarobs, strvar_obsnames, phylum_color_dict\n    leafids = getleafnames(node)\n    leafphylum = strvarobs.NCBI_Phylum[indexin(leafids, strvar_obsnames)]\n    get(phylum_color_dict, mode(leafphylum), :grey)\nend |&gt; x-&gt;x[2:end] |&gt; permutedims\n\nplot(strvartree,\n    fs=2, rightmargin=7Plots.mm,\n    c=phylum_linecolors,\n    lw=3,\n    size=(400, 600),\n)\n# phyla \nfor (i, (k,v)) in enumerate(zip(unique(strvarobs.NCBI_Phylum), palette(:Accent)[[4,2,3]]))\n    annotate!(0, i*10 - 30, text(k, 7, :left, :black,v), c=v)\nend\nplot!()\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nspeciescolordf = CSV.read(datadir(\"exp_raw\",\"BB669\",\"subsettreecolors.csv\"), DataFrame)\nspecies_color_dict = Dict(k=&gt;v for (k,v) in zip(speciescolordf.species_name, speciescolordf.color));\nspeciesvector = strvarobs.Species[indexin(getleafnames(strvartree), strvar_obsnames)];\nspecies_linecolors = map(prewalk(strvartree)) do node; strvarobs, strvar_obsnames, species_color_dict\n    leafids = getleafnames(node)\n    leafspecies = strvarobs.Species[indexin(leafids, strvar_obsnames)]\n    if length(unique(leafspecies)) == 1\n        get(species_color_dict, mode(leafspecies), :grey)\n    else\n        :grey\n    end\nend |&gt; x-&gt;x[2:end] |&gt; permutedims\n\n plot(strvartree,\n    yticks=false,\n    fs=1, rightmargin=5.4Plots.cm,\n    c=species_linecolors,\n    lw=3, size=(900, 900),\n    framestyle=:grid,\n)\n# species \nfor (i, (k,v)) in enumerate(zip(speciescolordf.species_name, speciescolordf.color))\n    yval = median(findall(==(k), speciesvector))\n    annotate!(4.5, yval, text(k, 9, :left, v))\nend\nannotate!(4.5, 356, text(\"Blautia luti (2)\", 9, :left, species_color_dict[\"Blautia luti\"]))\n# vline!([.5,2.5])\nfancy_tree_plot = plot!()\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nsavefig(joinpath(pdir, \"str_var_tree_colored_by_species.pdf\"));\n\n\n# plot cladogram\nstrvartree_hc = UPGMA_tree(dij)\nsubsettreestring = SpectralInference.newickstring(strvartree_hc, strvarobs.Strain_ID)\nsubsettree = readnw(subsettreestring);\nplot(strvartree_hc, \n    size=(800, 900),\n    lw=.5,\n    yflip=true, \n    xmirror=true,\n    xticks=:none,\n    permute=(:y, :x),\n    grid=false,\n    tickdirection=:none,\n    rightmargin=5.5Plots.cm, \n    label=\"\",\n    framestyle=:grid,\n)\n\n# plot annotation rectangles\nrectangle(w, h, x, y) = Shape(x .+ [0,w,w,0], y .+ [0,0,h,h])\nspeciesvector = strvarobs.Species[strvartree_hc.order]\nbreaks = findall(speciesvector[begin:(end-1)] .!= speciesvector[2:end])[Not([10, 11, 12, 13, 14,15])]\nedges = [(s, e) for (s,e) in zip(vcat([0],breaks), vcat(breaks, [length(speciesvector)]))];\nrects = [rectangle(2,(e-s),0,s+.5) for (s,e) in zip(vcat([0],breaks), vcat(breaks, [length(speciesvector)]))];\nrectspeciescolors = permutedims(speciescolordf.color[indexin(speciesvector[first.(edges).+1], speciescolordf.species_name)]);\nfancy_treeplot = plot!(permutedims(rects), fill=0.35, lw=0, c=rectspeciescolors, label=\"\")\n\n# species \nfor (i, (k,v)) in enumerate(zip(speciescolordf.species_name, speciescolordf.color))\n    yval = median(findall(==(k), speciesvector))\n    annotate!(-0.1, yval, text(k, 9, :left, v))\nend\nannotate!(-0.1, 356, text(\"Blautia luti (2)\", 9, :left, species_color_dict[\"Blautia luti\"]))\n\nfancy_treeplot"
  },
  {
    "objectID": "04_figure_04.html#statistically-test-clades-at-each-node-in-tree",
    "href": "04_figure_04.html#statistically-test-clades-at-each-node-in-tree",
    "title": "Interpreting New Strain Relationships",
    "section": "Statistically test clades at each node in tree",
    "text": "Statistically test clades at each node in tree\n\n# functions to compare differences\nfunction cliffs_d(a, b) \n    ans = 0.\n    for i in a, j in b\n        ans += sign(i - j)\n    end\n    ans / (length(a) * length(b))\nend\n\nfunction log2FC(a, b) \n    mean(log2.(a .+ 1)) - mean(log2.(b .+ 1))\nend\n\nlog2FC (generic function with 1 method)\n\n\n\n# significance tests across full strain variation tree\nseed!(123456789)\ntree = strvartree\n\nmaxtreeheight = last(maximum(getheights(tree)))\nleaves = getleaves(tree)\nleafnames = name.(leaves);\ntreeorder = indexin(leafnames, strvar_obsnames);\n\nogg_mtx = biobank[\"oggs\"].X[:,:][biobank.obs.kept_species.==1,:]\nogg_mask = vec(mapslices(c-&gt;std(c) &gt; 0, ogg_mtx, dims=1))\nogg_mtx = ogg_mtx[treeorder, ogg_mask]\n@show size(ogg_mtx)\nogg_names = biobank[\"oggs\"].var_names[ogg_mask]\n\nogg_freqs = vec(mean(ogg_mtx .&gt; 0, dims=1))\n\ntaxon_info = strvarobs[treeorder, :]\ntaxon_info.species_donor = join.(eachrow(strvarobs[treeorder, [:Species, :Donor]]), \" \")\n\n\nisolate_ids = getleafnames(tree)\ntestresults = DataFrame()\n\n\nfor node in prewalk(tree)\n    #  if group size would be less than 1 skip node\n    (isleaf(node) || any(isleaf.(node.children))) && continue\n    \n    # find comparison groups\n    grp1_idx = indexin(getleafnames(node.children[1]), isolate_ids)\n    grp2_idx = indexin(getleafnames(node.children[2]), isolate_ids)\n    \n    pvals = mapslices(ogg_mtx, dims=1) do column\n        pvalue(MannWhitneyUTest(column[grp1_idx], column[grp2_idx]))\n    end |&gt; vec\n    \n    # make null\n    seed!(1234)\n    null_qs = map(1:100) do i\n        n = length(grp1_idx)\n        m = length(grp2_idx)\n        perm_idx = shuffle(vcat(grp1_idx, grp2_idx))\n        qs = mapslices(ogg_mtx, dims=1) do column_perm\n            q = pvalue(MannWhitneyUTest(column_perm[perm_idx[1:n]], column_perm[perm_idx[n+1:end]]))\n        end\n        minimum(qs)\n    end\n\n    qvals = mapslices(ogg_mtx, dims=1) do column\n        pval = pvalue(MannWhitneyUTest(column[grp1_idx], column[grp2_idx]))\n        mean(null_qs .&lt; pval)\n    end |&gt; vec\n    \n    effects = mapslices(ogg_mtx, dims=1) do column\n        abs(mean(column[grp1_idx]) - mean(column[grp2_idx]) / std(column))\n    end |&gt; vec\n\n    log_effects = mapslices(ogg_mtx, dims=1) do column\n        logcol = log2.(column.+1)\n        abs(mean(logcol[grp1_idx]) - mean(logcol[grp2_idx]) / std(logcol))\n    end |&gt; vec\n    \n    log2FCs = mapslices(ogg_mtx, dims=1) do column\n        log2FC(column[grp1_idx], column[grp2_idx])\n    end |&gt; vec\n\n    cliffs_ds = mapslices(ogg_mtx, dims=1) do column\n        cliffs_d(column[grp1_idx], column[grp2_idx])\n    end |&gt; vec\n\n    grp1_prp_exp = mapslices(ogg_mtx, dims=1) do column\n        mean(column[grp1_idx] .&gt; 0)\n    end |&gt; vec\n\n    grp2_prp_exp = mapslices(ogg_mtx, dims=1) do column\n        mean(column[grp2_idx] .&gt; 0)\n    end |&gt; vec\n    \n    testresults = vcat(testresults, \n        DataFrame(\n            :nodeids =&gt; id(node),\n            :nodeheight =&gt;  NewickTree.height(node),\n            :nodedepth =&gt;  maxtreeheight - NewickTree.height(node),\n            :grp1_N =&gt; length(grp1_idx),\n            :grp2_N =&gt; length(grp2_idx),\n            :grp1_phylum_mode =&gt; mode(taxon_info.Phylum[grp1_idx]),\n            :grp2_phylum_mode =&gt; mode(taxon_info.Phylum[grp2_idx]),\n            :grp1_species_mode =&gt; mode(taxon_info.Species[grp1_idx]),\n            :grp2_species_mode =&gt; mode(taxon_info.Species[grp2_idx]),\n            :grp1_species_donor_mode =&gt; mode(taxon_info.species_donor[grp1_idx]),\n            :grp2_species_donor_mode =&gt; mode(taxon_info.species_donor[grp2_idx]),\n            :ogg_name =&gt; ogg_names,\n            :ogg_idx =&gt; collect(axes(ogg_mtx, 2)),\n            :ogg_freqs =&gt; ogg_freqs,\n            :grp1_prp_exp =&gt; grp1_prp_exp,\n            :grp2_prp_exp =&gt; grp2_prp_exp,\n            :effectsize =&gt; effects,\n            :logeffectsize =&gt; log_effects,\n            :log2FC =&gt; log2FCs,\n            :cliffs_d =&gt; cliffs_ds,\n            :pvals =&gt; pvals,\n            :qvals =&gt; qvals,\n        )\n    )\nend\ntestresults[!, \"pval_BH\"] .= adjust(testresults.pvals, BenjaminiHochberg());\ntestresults[!, \"pval_Bon\"] .= adjust(testresults.pvals, Bonferroni());\ntestresults[!, \"qval_BH\"] .= adjust(testresults.qvals, BenjaminiHochberg());\n\ntree_discretization = cut(testresults.nodedepth, [0, 2, 4, 5])\nrecode!(tree_discretization, \n    \"[4, 5)\"=&gt;\"phylum level\", \n    \"[2, 4)\"=&gt;\"species level\",\n    \"[0, 2)\"=&gt;\"strain level\")\ntestresults[!, \"tree_level\"] = tree_discretization\ntestresults;\n\nsize(ogg_mtx) = (356, 5449)\n\n\n\ncountmap(testresults.tree_level)\n\nDict{CategoricalArrays.CategoricalValue{String, UInt32}, Int64} with 3 entries:\n  \"species level\" =&gt; 59939\n  \"strain level\"  =&gt; 457716\n  \"phylum level\"  =&gt; 5449\n\n\n\nCSV.write(joinpath(rdir, \"full_ogg_wilcoxon_testresults_on_big10species.csv\"), testresults)\ntestresults |&gt; \n    df-&gt;filter(:pval_BH =&gt; &lt;(0.05), df) |&gt;\n    df-&gt;CSV.write(joinpath(rdir, \"significant_BH_ogg_wilcoxon_testresults_on_big10species.csv\"), df)\ntestresults |&gt;\n    df-&gt;filter(:pval_Bon =&gt; &lt;(0.05), df) |&gt;\n    df-&gt;CSV.write(joinpath(rdir, \"significant_Bon_ogg_wilcoxon_testresults_on_big10species.csv\"), df)\ntestresults |&gt;\n    df-&gt;filter(:qval_BH =&gt; &lt;(0.05), df) |&gt;\n    df-&gt;CSV.write(joinpath(rdir, \"significant_Qbh_ogg_wilcoxon_testresults_on_big10species.csv\"), df)\n\n\"/Users/bend/projects/Doran_etal_2023/_research/strain_variation_wilcoxon_tests/significant_Qbh_ogg_wilcoxon_testresults_on_big10species.csv\""
  },
  {
    "objectID": "04_figure_04.html#filtering-to-most-significant-results",
    "href": "04_figure_04.html#filtering-to-most-significant-results",
    "title": "Interpreting New Strain Relationships",
    "section": "Filtering to most significant results",
    "text": "Filtering to most significant results\n\ntestresults = CSV.read(joinpath(rdir, \"full_ogg_wilcoxon_testresults_on_big10species.csv\"), DataFrame);\n\n\nsigtestresults = filter(:qval_BH =&gt; &lt;(0.05), testresults) |&gt;\n    df -&gt; filter(:logeffectsize =&gt; &gt;(1), df) |&gt;\n    df -&gt; filter(:effectsize =&gt; &gt;(1), df) |&gt;\n    df -&gt; filter(:log2FC =&gt; x-&gt;abs.(x) .&gt; 1 , df);\n\n\n@show sigtestresults.ogg_name |&gt; unique |&gt; length\n@show sigtestresults.nodeids |&gt; unique |&gt; length\n@show sum(sigtestresults.tree_level .== \"phylum level\")\n@show sum(sigtestresults.tree_level .== \"species level\")\n@show sum(sigtestresults.tree_level .== \"strain level\");\n\n(sigtestresults.ogg_name |&gt; unique) |&gt; length = 1530\n(sigtestresults.nodeids |&gt; unique) |&gt; length = 66\nsum(sigtestresults.tree_level .== \"phylum level\") = 415\nsum(sigtestresults.tree_level .== \"species level\") = 1117\nsum(sigtestresults.tree_level .== \"strain level\") = 1070\n\n\n\n# how many OGGs are still duplicated?\nsigtestresults |&gt; \n    df -&gt; groupby(df, :ogg_name) |&gt;\n    df -&gt; subset(df, :log2FC =&gt; x -&gt; abs.(x) .== maximum(abs.(x))) |&gt;\n    df -&gt; countmap(df.ogg_name) |&gt;\n    cm -&gt; sum(values(cm) .&gt; 1)\n\n27\n\n\n\n# for these remaining OGGs select the shallowest significant example\nuniqueOGGresults = sigtestresults |&gt; \n    df -&gt; groupby(df, :ogg_name) |&gt;\n    df -&gt; subset(df, :log2FC =&gt; x -&gt; abs.(x) .== maximum(abs.(x))) |&gt;\n    df -&gt; groupby(df, :ogg_name) |&gt;\n    df -&gt; subset(df, :nodeheight =&gt; x -&gt; x .== minimum(x));\n@show nrow(uniqueOGGresults) == length(unique(uniqueOGGresults.ogg_name))\n@show sum(uniqueOGGresults.tree_level .== \"phylum level\")\n@show sum(uniqueOGGresults.tree_level .== \"species level\")\n@show sum(uniqueOGGresults.tree_level .== \"strain level\");\n\nnrow(uniqueOGGresults) == length(unique(uniqueOGGresults.ogg_name)) = true\nsum(uniqueOGGresults.tree_level .== \"phylum level\") = 273\nsum(uniqueOGGresults.tree_level .== \"species level\") = 676\nsum(uniqueOGGresults.tree_level .== \"strain level\") = 581\n\n\n\nCSV.write(joinpath(rdir, \"unique_sig_ogg_wilcoxon_testresults_on_big10species.csv\"), uniqueOGGresults)\n\n\"/Users/bend/projects/Doran_etal_2023/_research/strain_variation_wilcoxon_tests/unique_sig_ogg_wilcoxon_testresults_on_big10species.csv\"\n\n\nPhylum level significant orthologs\n\nogg_plotting_order = uniqueOGGresults |&gt;\n    df-&gt;subset(df,  :tree_level =&gt; x-&gt; x.==(\"phylum level\"), :grp1_N =&gt; x-&gt; x.&gt;=3, :grp2_N =&gt; x-&gt; x.&gt;=3) |&gt;\n    df-&gt;subset(df, :nodeids =&gt; (x-&gt;get.(Ref(countmap(x)), x, 0) .&gt; 10)) |&gt;\n    df-&gt;sort(df, [:nodeids, :log2FC]);\n\nhmapplot = heatmap(log2.(ogg_mtx[:, ogg_plotting_order.ogg_idx] .+ 1), \n# hmapplot = heatmap(log2.(ogg_mtx[:, uniqueOGGresults.ogg_idx]),\n    title=\"Phylum level tests; \" * L\"Q_{BH} &lt; 0.05, |\\log_2 FC| &gt; 1\",\n    yticks=false,\n    # xticks=(1:nrow(uniqueOGGresults), uniqueOGGresults.ogg_name),\n    xticks=[1, findall(diff(ogg_plotting_order.nodeids) .!= 0)..., nrow(ogg_plotting_order)],\n    xrotation=45,\n    ylims=(.5,356.5),\n    framestyle=:grid,\n    cticks=(1:4, string.(2 .^ 1:4)),\n    c=cgrad(:bilbao, rev=true),\n    leftmargin=0Plots.mm,\n);\n\nrectangle(w, h, x, y) = Shape(x .+ [0,w,w,0], y .+ [0,0,h,h])\nleafnames = getleafnames(strvartree)\noggrects = map(unique(ogg_plotting_order.nodeids)) do nid\n    node = filter(x-&gt; id(x)==(nid), prewalk(strvartree))[1]\n    idx_taxa = indexin(getleafnames(node), leafnames)\n    noderesults = filter(:nodeids =&gt; ==(nid), ogg_plotting_order)\n    idx_oggs = indexin(noderesults.ogg_name, ogg_plotting_order.ogg_name)\n    x = minimum(idx_oggs)\n    y = minimum(idx_taxa)\n    width = maximum(idx_oggs) - minimum(idx_oggs)\n    height = maximum(idx_taxa) - minimum(idx_taxa)\n    rectangle(width, height, x, y)\nend\n\nplot!(permutedims(oggrects), fill=0.0, lw=1.5, linecolor=\"red\", label=\"\")\n\nlayout = @layout [a{.2w} b]\nplot(plot(fancy_treeplot, title=\"SPI tree\"), hmapplot; layout, xrotation=45, size=(1000,600), link=:y, legend=:none, margin=3Plots.Measures.mm)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\nsavefig(joinpath(pdir, \"significantOGGS_pernode_phylumlevel_treeandheatmap_coloredboxes.pdf\"))\n\n\"/Users/bend/projects/Doran_etal_2023/plots/strain_variation_tree_and_tests/significantOGGS_pernode_phylumlevel_treeandheatmap_coloredboxes.pdf\"\n\n\nSpecies level significant orthologs\n\nogg_plotting_order = uniqueOGGresults |&gt;\n    df-&gt;subset(df,  :tree_level =&gt; x-&gt; x.==(\"species level\"), :grp1_N =&gt; x-&gt; x.&gt;=3, :grp2_N =&gt; x-&gt; x.&gt;=3) |&gt;\n    df-&gt;subset(df, :nodeids =&gt; (x-&gt;get.(Ref(countmap(x)), x, 0) .&gt; 10)) |&gt;\n    df-&gt;sort(df, [:nodeids, :log2FC]);\n\nhmapplot = heatmap(log2.(ogg_mtx[:, ogg_plotting_order.ogg_idx] .+ 1), \n# hmapplot = heatmap(log2.(ogg_mtx[:, uniqueOGGresults.ogg_idx]),\n    title=\"Species level tests; \" * L\"Q_{BH} &lt; 0.05, |\\log_2 FC| &gt; 1\",\n    yticks=false,\n    # xticks=(1:nrow(uniqueOGGresults), uniqueOGGresults.ogg_name),\n    xticks=[1, findall(diff(ogg_plotting_order.nodeids) .!= 0)..., nrow(ogg_plotting_order)],\n    xrotation=45,\n    ylims=(.5,356.5),\n    framestyle=:grid,\n    cticks=(1:4, string.(2 .^ 1:4)),\n    c=cgrad(:bilbao, rev=true),\n    leftmargin=0Plots.mm,\n);\n\nrectangle(w, h, x, y) = Shape(x .+ [0,w,w,0], y .+ [0,0,h,h])\nleafnames = getleafnames(strvartree)\noggrects = map(unique(ogg_plotting_order.nodeids)) do nid\n    node = filter(x-&gt; id(x)==(nid), prewalk(strvartree))[1]\n    idx_taxa = indexin(getleafnames(node), leafnames)\n    noderesults = filter(:nodeids =&gt; ==(nid), ogg_plotting_order)\n    idx_oggs = indexin(noderesults.ogg_name, ogg_plotting_order.ogg_name)\n    x = minimum(idx_oggs)\n    y = minimum(idx_taxa)\n    width = maximum(idx_oggs) - minimum(idx_oggs)\n    height = maximum(idx_taxa) - minimum(idx_taxa)\n    rectangle(width, height, x, y)\nend\n\nplot!(permutedims(oggrects), fill=0.0, lw=1.5, linecolor=\"aqua\", label=\"\")\n\nlayout = @layout [a{.2w} b]\nplot(plot(fancy_treeplot, title=\"SPI tree\"), hmapplot; layout, xrotation=45, size=(1000,600), link=:y, legend=:none, margin=3Plots.Measures.mm)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\nsavefig(joinpath(pdir, \"significantOGGS_pernode_specieslevel_treeandheatmap_coloredboxes.pdf\"))\n\n\"/Users/bend/projects/Doran_etal_2023/plots/strain_variation_tree_and_tests/significantOGGS_pernode_specieslevel_treeandheatmap_coloredboxes.pdf\"\n\n\nStrain level significant orthologs\n\nogg_plotting_order = uniqueOGGresults |&gt;\n    df-&gt;subset(df,  :tree_level =&gt; x-&gt; x.==(\"strain level\"), :grp1_N =&gt; x-&gt; x.&gt;=3, :grp2_N =&gt; x-&gt; x.&gt;=3) |&gt;\n    df-&gt;subset(df, :nodeids =&gt; (x-&gt;get.(Ref(countmap(x)), x, 0) .&gt; 10)) |&gt;\n    df-&gt;sort(df, [:nodeids, :log2FC]);\n\nhmapplot = heatmap(log2.(ogg_mtx[:, ogg_plotting_order.ogg_idx] .+ 1), \n# hmapplot = heatmap(log2.(ogg_mtx[:, uniqueOGGresults.ogg_idx]),\n    title=\"Strain level tests; \" * L\"Q_{BH} &lt; 0.05, |\\log_2 FC| &gt; 1\",\n    yticks=false,\n    # xticks=(1:nrow(uniqueOGGresults), uniqueOGGresults.ogg_name),\n    xticks=[1, findall(diff(ogg_plotting_order.nodeids) .!= 0)..., nrow(ogg_plotting_order)],\n    xrotation=45,\n    ylims=(.5,356.5),\n    framestyle=:grid,\n    cticks=(1:4, string.(2 .^ 1:4)),\n    c=cgrad(:bilbao, rev=true),\n    leftmargin=0Plots.mm,\n);\n\nrectangle(w, h, x, y) = Shape(x .+ [0,w,w,0], y .+ [0,0,h,h])\nleafnames = getleafnames(strvartree)\noggrects = map(unique(ogg_plotting_order.nodeids)) do nid\n    node = filter(x-&gt; id(x)==(nid), prewalk(strvartree))[1]\n    idx_taxa = indexin(getleafnames(node), leafnames)\n    noderesults = filter(:nodeids =&gt; ==(nid), ogg_plotting_order)\n    idx_oggs = indexin(noderesults.ogg_name, ogg_plotting_order.ogg_name)\n    x = minimum(idx_oggs)\n    y = minimum(idx_taxa)\n    width = maximum(idx_oggs) - minimum(idx_oggs)\n    height = maximum(idx_taxa) - minimum(idx_taxa)\n    rectangle(width, height, x, y)\nend\n\nplot!(permutedims(oggrects), fill=0.0, lw=1.5, linecolor=\"lightgreen\", label=\"\")\n# vline!(findall(diff(ogg_plotting_order.nodeids) .&gt; 0) .- .5, lw=1, c=:black, label=\"\")\n\nlayout = @layout [a{.2w} b]\nplot(plot(fancy_treeplot, title=\"SPI tree\"), hmapplot; layout, xrotation=45, size=(1000,600), link=:y, legend=:none, margin=3Plots.Measures.mm)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\nsavefig(joinpath(pdir, \"significantOGGS_pernode_strainlevel_treeandheatmap_coloredboxes.pdf\"))\n\n\"/Users/bend/projects/Doran_etal_2023/plots/strain_variation_tree_and_tests/significantOGGS_pernode_strainlevel_treeandheatmap_coloredboxes.pdf\"\n\n\nzoom-ins of strain level significant orthologs\n\n### Strain level zoomin P. vulgatus\nogg_plotting_order.nodeids |&gt; unique\nogg_plotting_order = uniqueOGGresults |&gt;\n    df-&gt;subset(df,  :tree_level =&gt; x-&gt; x.==(\"strain level\"), :grp1_N =&gt; x-&gt; x.&gt;=3, :grp2_N =&gt; x-&gt; x.&gt;=3) |&gt;\n    df-&gt;subset(df, :nodeids =&gt; (x-&gt;get.(Ref(countmap(x)), x, 0) .&gt; 10)) |&gt;\n    df-&gt;sort(df, [:nodeids, :log2FC]) |&gt;\n    df-&gt;filter(:nodeids =&gt; ==(136), df)\nnid = 136\nnode = filter(x-&gt; id(x)==(nid), prewalk(strvartree))[1]\nidx_taxa = indexin(getleafnames(node), leafnames)\n\nhmapplot = heatmap(log2.(ogg_mtx[idx_taxa, ogg_plotting_order.ogg_idx] .+ 1), \n# hmapplot = heatmap(log2.(ogg_mtx[:, uniqueOGGresults.ogg_idx]),\n    title=\"P. vulgatus (zoomin); \" * L\"Q_{BH} &lt; 0.05, |\\log_2 FC| &gt; 1\",\n    yticks=false,\n    xticks=(1:nrow(ogg_plotting_order), ogg_plotting_order.ogg_name),\n    # xtickfontsize=1,\n    xrotation=90,\n    # ylims=(.5,356.5),\n    tickdirection=:out,\n    framestyle=:grid,\n    cticks=(1:4, string.(2 .^ 1:4)),\n    clims=(0, 6.1),\n    c=cgrad(:bilbao, rev=true),\n    size=(550,550),\n    leftmargin=0Plots.mm,\n    grid=false\n)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n### Strain level zoomin C. comes\nogg_plotting_order.nodeids |&gt; unique\nogg_plotting_order = uniqueOGGresults |&gt;\n    df-&gt;subset(df,  :tree_level =&gt; x-&gt; x.==(\"strain level\"), :grp1_N =&gt; x-&gt; x.&gt;=3, :grp2_N =&gt; x-&gt; x.&gt;=3) |&gt;\n    df-&gt;subset(df, :nodeids =&gt; (x-&gt;get.(Ref(countmap(x)), x, 0) .&gt; 10)) |&gt;\n    df-&gt;sort(df, [:nodeids, :log2FC]) |&gt;\n    df-&gt;filter(:nodeids =&gt; ==(523), df)\nnid = 523\nnode = filter(x-&gt; id(x)==(nid), prewalk(strvartree))[1]\nidx_taxa = indexin(getleafnames(node), leafnames)\n\nhmapplot = heatmap(log2.(ogg_mtx[idx_taxa, ogg_plotting_order.ogg_idx] .+ 1), \n    title=\"C. comes (zoomin); \" * L\"Q_{BH} &lt; 0.05, |\\log_2 FC| &gt; 1\",\n    yticks=false,\n    xticks=(1:nrow(ogg_plotting_order), ogg_plotting_order.ogg_name),\n    xrotation=90,\n    tickdirection=:out,\n    framestyle=:grid,\n    cticks=(1:4, string.(2 .^ 1:4)),\n    clims=(0, 6.1),\n    c=cgrad(:bilbao, rev=true),\n    size=(550,550),\n    leftmargin=0Plots.mm,\n    grid=false\n)"
  },
  {
    "objectID": "04_figure_04.html#explore-differences-within-e.-rectale",
    "href": "04_figure_04.html#explore-differences-within-e.-rectale",
    "title": "Interpreting New Strain Relationships",
    "section": "Explore differences within E. rectale",
    "text": "Explore differences within E. rectale\n\ntargetid = \"MSK.16.22\"\nstrvar_leaves = getleaves(strvartree)\nbasenode = strvar_leaves[findfirst(n-&gt;name(n) == targetid, strvar_leaves)]\nsubtree = readnw(nwstr(nthparent(basenode, 3)))\nrectale_idxs = indexin(getleafnames(subtree),strvarobs.Strain_ID)\n\n\ntiplabels = strvarobs.Donor[rectale_idxs]\nidmapping = Dict(k=&gt;v for (k,v) in zip(getleafnames(subtree), tiplabels))\nrename_treeleaves!(subtree, idmapping)\n\nrectale_donor_dict = Dict(\n    \"MSK.22\"=&gt;\"#026691\", \n    \"MSK.17\"=&gt;\"#0b8bc1\", \n    \"MSK.16\"=&gt;\"#f9ad07\", \n    \"MSK.13\"=&gt;\"#c9a964\", \n    \"MSK.9\"=&gt;\"#af9b01\",\n)\n\nrectale_linecolors = map(prewalk(subtree)) do node; rectale_donor_dict\n    if length(unique(getleafnames(node))) == 1\n        get(rectale_donor_dict, mode(getleafnames(node)), :grey)\n    else\n        :grey\n    end\nend |&gt; x-&gt;x[2:end] |&gt; permutedims\n\nplot(subtree,\n    c=rectale_linecolors,\n    # alpha=.5,\n    lw=3, fs=2,\n    size=(400,600),\n    rightmargin=2Plots.cm,\n    leftmargin=10Plots.mm,\n    ylabel=\"E. rectale\",\n    framestyle=:grid,\n    ticks=false,\n)\n# donor annotations \nfor (i, (k,v)) in enumerate(rectale_donor_dict)\n    yvals = findall(==(k), getleafnames(subtree))\n    yval = median(yvals)\n    annotate!(1.8, yval, text(\"$k\\n(n=$(length(yvals)))\", 9, :center, v))\nend\np1 = plot!()\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nogg_plotting_order = uniqueOGGresults |&gt;\n    # select test at root of rectale sub tree\n    df-&gt;subset(df, :nodeids =&gt; x-&gt; x.==(id(nthparent(basenode, 3)))) |&gt;\n    df-&gt;select(df, [:nodeids, :log2FC, :grp1_N, :grp2_N, :ogg_name, :ogg_idx]) |&gt;\n    # add in descriptions of each ogg\n    df-&gt;leftjoin(df, uniprot.var[:, [:og, :description]], on = :ogg_name =&gt; :og) |&gt;\n    # sort oggs based on abundence per group\n    df-&gt;sort(df, [:nodeids, :log2FC]) |&gt;\n    # get shorter descriptions for lables\n    df-&gt;coalesce.(df, \"\") |&gt;\n    df-&gt;transform(df, \n        :description =&gt; ByRow(x-&gt;first(replace.(x, r\"\\(.*\\)\"=&gt;\"\"), 75)) =&gt; :ogg_labels\n    );\n\n\n# more abundant in MSK.17 and MSK.22\nsubset(ogg_plotting_order,\n    :log2FC =&gt; ByRow(&lt;(0)),\n    :description =&gt; ByRow(!=(\"\"))\n)\n\n17×8 DataFrame\n\n\n\nRow\nnodeids\nlog2FC\ngrp1_N\ngrp2_N\nogg_name\nogg_idx\ndescription\nogg_labels\n\n\n\nInt64\nFloat64\nInt64\nInt64\nString15\nInt64\nString\nString\n\n\n\n\n1\n433\n-2.52345\n7\n13\nCOG1345\n3757\nRequired for morphogenesis and for the elongation of the flagellar filament by facilitating polymerization of the flagellin monomers at the tip of growing filament. Forms a capping structure, which prevents flagellin subunits (transported through the central channel of the flagellum) from leaking out without polymerization at the distal end\nRequired for morphogenesis and for the elongation of the flagellar filament\n\n\n2\n433\n-2.26897\n7\n13\nCOG1344\n3756\nbacterial-type flagellum-dependent cell motility\nbacterial-type flagellum-dependent cell motility\n\n\n3\n433\n-2.03848\n7\n13\nCOG5444\n5401\nnuclease activity\nnuclease activity\n\n\n4\n433\n-2.03047\n7\n13\nCOG5001\n5338\ncyclic-guanylate-specific phosphodiesterase activity\ncyclic-guanylate-specific phosphodiesterase activity\n\n\n5\n433\n-2.0\n7\n13\nCOG3210\n4625\ndomain, Protein\ndomain, Protein\n\n\n6\n433\n-1.94674\n7\n13\nCOG3547\n4769\nTransposase (IS116 IS110 IS902 family)\nTransposase\n\n\n7\n433\n-1.8723\n7\n13\nCOG4495\n5124\nDomain of unknown function (DUF4176)\nDomain of unknown function\n\n\n8\n433\n-1.74526\n7\n13\nCOG1442\n3821\nlipopolysaccharide 3-alpha-galactosyltransferase activity\nlipopolysaccharide 3-alpha-galactosyltransferase activity\n\n\n9\n433\n-1.58496\n7\n13\nCOG4786\n5238\nFlagellar basal body rod\nFlagellar basal body rod\n\n\n10\n433\n-1.50843\n7\n13\nCOG5279\n5367\nprotein involved in cytokinesis, contains TGc (transglutaminase protease-like) domain\nprotein involved in cytokinesis, contains TGc domain\n\n\n11\n433\n-1.38462\n7\n13\nCOG1776\n4031\nchemotaxis\nchemotaxis\n\n\n12\n433\n-1.35998\n7\n13\nCOG2944\n4514\nsequence-specific DNA binding\nsequence-specific DNA binding\n\n\n13\n433\n-1.29925\n7\n13\nCOG0842\n3475\nTransport permease protein\nTransport permease protein\n\n\n14\n433\n-1.29925\n7\n13\nCOG1516\n3869\nflagellar protein fliS\nflagellar protein fliS\n\n\n15\n433\n-1.22499\n7\n13\nCOG0835\n3469\nchemotaxis\nchemotaxis\n\n\n16\n433\n-1.22499\n7\n13\nCOG2186\n4263\nTranscriptional regulator\nTranscriptional regulator\n\n\n17\n433\n-1.22499\n7\n13\nCOG2198\n4271\nHistidine kinase\nHistidine kinase\n\n\n\n\n\n\n\n# more abundant in MSK.9, MSK.13, and MSK.16\nsubset(ogg_plotting_order,\n    :log2FC =&gt; ByRow(&gt;(0)),\n    :description =&gt; ByRow(!=(\"\"))\n)\n\n5×8 DataFrame\n\n\n\nRow\nnodeids\nlog2FC\ngrp1_N\ngrp2_N\nogg_name\nogg_idx\ndescription\nogg_labels\n\n\n\nInt64\nFloat64\nInt64\nInt64\nString15\nInt64\nString\nString\n\n\n\n\n1\n433\n1.16713\n7\n13\nCOG5015\n5347\nPyridoxamine 5'-phosphate oxidase\nPyridoxamine 5'-phosphate oxidase\n\n\n2\n433\n1.32193\n7\n13\nCOG3534\n4763\nalpha-L-arabinofuranosidase\nalpha-L-arabinofuranosidase\n\n\n3\n433\n1.64425\n7\n13\nCOG3378\n4691\nPhage plasmid primase P4 family\nPhage plasmid primase P4 family\n\n\n4\n433\n1.92997\n7\n13\nCOG0286\n2997\nsite-specific DNA-methyltransferase (adenine-specific) activity\nsite-specific DNA-methyltransferase activity\n\n\n5\n433\n2.99151\n7\n13\nCOG0732\n3379\ntype I restriction modification DNA specificity domain\ntype I restriction modification DNA specificity domain\n\n\n\n\n\n\n\npltmtx = ogg_mtx[indexin(strvarobs.Strain_ID, getleafnames(strvartree)), ogg_plotting_order.ogg_idx][rectale_idxs, :]\np2 = heatmap(log2.(pltmtx .+ 1), \n    yticks=false,\n    xticks=(1:nrow(ogg_plotting_order), ogg_plotting_order.ogg_labels),\n    tickdirection=:out,\n    cticks=(1:4, string.(2 .^ 1:4)),\n    c=cgrad(:bilbao, rev=true),\n    leftmargin=0Plots.mm,\n    rightmargin=4Plots.cm,\n    topmargin=1.5Plots.cm,\n    grid=false,\n    framestyle=:box,\n    xmirror=true,\n    xrotation=45,\n);\n\nplot(p1, p2, layout=@layout([a{.25w} b]), link=:y, size=(1000, 800))"
  },
  {
    "objectID": "04_figure_04.html#validation-experiment",
    "href": "04_figure_04.html#validation-experiment",
    "title": "Interpreting New Strain Relationships",
    "section": "Validation experiment",
    "text": "Validation experiment\nWe noted that groups of strains from donors 22 and 17 had many orthologs related to the flagellum, that were absent from donors 9, 13, and 16. Conversely donors 9, 13, and 16 had orthologs related to viral (bacteriophage) infection. It suggested that in donors 9, 13, and 16 there had been an infection of populations that caused these strains to lose their flagellum and thus motility, likely to become more resistant to this bacteriophage.\nWe just wanted to test whether these strains where indeed non-motile, to verify that we were detecting accurate and functional differences between these strains. So we grew a sample of these strain in BHIS media, took pictures at the 24 hour mark and a time-series of optical density measurements (OD600).\n\n\nplot motility assay\nearlydf = CSV.read(datadir(\"exp_raw\", \"OD600_motility\", \"earlygrowth_OD600.tsv\"), DataFrame, delim=\"\\t\") |&gt;\n    df -&gt; stack(df, 2:5) |&gt;\n    df -&gt; rename(df, :variable =&gt; :time, :value =&gt; :OD600);\nearlydf = earlydf |&gt;\n    df -&gt; transform(df,\n        :ID =&gt; (x-&gt;join.(first.(split.(x, \".\"), 2), \".\")) =&gt; :msk_id,\n        :ID =&gt; (x-&gt;last.(split.(x, \".\"))) =&gt; :replicate,\n    );\n\nvortexdf = CSV.read(datadir(\"exp_raw\", \"OD600_motility\", \"postvortex_OD600.tsv\"), DataFrame, delim=\"\\t\") |&gt;\n    df -&gt; stack(df, 2:8) |&gt;\n    df -&gt; rename(df, :variable =&gt; :time, :value =&gt; :OD600);\nvortexdf = vortexdf |&gt;\n    df -&gt; transform(df,\n        :ID =&gt; (x-&gt;join.(first.(split.(x, \".\"), 2), \".\")) =&gt; :msk_id,\n        :ID =&gt; (x-&gt;last.(split.(x, \".\"))) =&gt; :replicate,\n    );\nvortexpltdf = vortexdf |&gt;\n    df-&gt;groupby(df, [:time, :msk_id]) |&gt;\n    df-&gt;combine(df, \n        :OD600 =&gt; mean,\n        :OD600 =&gt; std,\n    );\n\nfulldf = vcat(earlydf, vortexdf)\n# fulldf = filter(:msk_id =&gt; x-&gt;startswith(x, r\"(9|17|22|neg)\"), fulldf)\nfullpltdf = fulldf |&gt;\n    df-&gt;groupby(df, [:time, :msk_id]) |&gt;\n    df-&gt;combine(df, \n        :OD600 =&gt; mean,\n        :OD600 =&gt; std,\n    );\nfullpltdf.OD600_std .= replace(fullpltdf.OD600_std, NaN =&gt; 0.); # set correct std for single negative control\n\ncmap=Dict(\n    \"neg\" =&gt; :grey,\n    \"9.13\" =&gt; \"#c07b7b\",\n    \"9.15\" =&gt; \"#f7afaf\",\n    \"16.22\" =&gt; \"#ebb041\",\n    \"17.70\" =&gt; \"#15e871\",\n    \"17.78\" =&gt; \"#66e39d\",\n    \"22.92\" =&gt; \"#03893e\"\n)\n\nplot(\n    ylabel=\"OD600\",\n    legend=:outerright,\n    xrotation=45,\n    margin=5Plots.Measures.mm,\n    size=(700,300),\n    bottommargins=10Plots.mm,\n)\n@df fulldf scatter!(\n    :time, :OD600,\n    group=:ID, \n    c=[cmap[id] for id in :msk_id],\n    label=\"\", markersize=3, markerstrokewidth=0,\n)\nvline!([4], c=:black, lw=.5, linestyle=:dash)\n@df fullpltdf plot!(\n    :time, :OD600_mean,\n    group=:msk_id, ribbon=:OD600_std,\n    c=[cmap[id] for id in :msk_id],\n    fillalpha=.25,\n)\nannotate!(4.8, .27, text(\"vortex\"))\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nimg = load(datadir(\"exp_raw\", \"OD600_motility\", \"swimmers_after24h.jpg\"))\nysize = floor.(Int, quantile(1:size(img,1), [0.2, 0.77])) |&gt; x-&gt;x[1]:x[2]\nxsize = floor.(Int, quantile(1:size(img,2), [0.15, 0.73])) |&gt; x-&gt;x[1]:x[2]\nimg[ysize, xsize]\n\n\n\n\n\nimg = load(datadir(\"exp_raw\", \"OD600_motility\", \"nonswimmers_after24h.jpg\"))\nysize = floor.(Int, quantile(1:size(img,1), [0.2, 0.77])) |&gt; x-&gt;x[1]:x[2]\nxsize = floor.(Int, quantile(1:size(img,2), [0.2, 0.71])) |&gt; x-&gt;x[1]:x[2]\nimg[ysize, xsize]"
  },
  {
    "objectID": "04_figure_04.html#how-conserved-are-these-features",
    "href": "04_figure_04.html#how-conserved-are-these-features",
    "title": "Interpreting New Strain Relationships",
    "section": "How conserved are these features?",
    "text": "How conserved are these features?\nThe flagellum is generally highly conserved, it is remarkable that phage seemed to be involved with deleting such seemingly important machinery from the organism.\nThus, we examined the conservation pattern of the 12 annotated gene groups that were absent in E. rectale strains isolated from donors 9, 13, 16 but present in strains isolated from donors 17 and 22 across the entire Spectral Tree\n\nuniprot = readh5ad(datadir(\"exp_raw\", \"UP7047\", \"2020_02_UP7047.h5ad\"))\nupmtx = uniprot.X[:,:];\nuptree = readnw(readline(projectdir(\"_research\", \"UP7047_neighborjoined_spitree\", \"2020_02_UP7047-supporttree_50pct.nw\")));\nleafnodes = getleaves(uptree);\ntreeorder = indexin(getleafnames(uptree), uniprot.obs_names);\n\n\nspecies_name = \"rectale\"\nfoundtaxa = uniprot.obs[contains.(uniprot.obs.Species, species_name), [:Kingdom, :Phylum, :Class, :Order, :Family, :Genus, :Species]]\n@info \"string: '$(species_name)' finds $(nrow(foundtaxa)) taxa:\\n$(foundtaxa)\"\n\n┌ Info: string: 'rectale' finds 1 taxa:\n│ 1×7 DataFrame\n│  Row │ Kingdom   Phylum      Class       Order          Family           Genus   Species\n│      │ String    String      String      String         String           String  String\n│ ─────┼─────────────────────────────────────────────────────────────────────────────────────────────────\n│    1 │ Bacteria  Firmicutes  Clostridia  Clostridiales  Lachnospiraceae          [Eubacterium] rectale\n└ @ Main /Users/bend/projects/Doran_etal_2023/notebooks/04_figure_04.ipynb:3\n\n\n\ntest_oggs = subset(ogg_plotting_order,\n    :description =&gt; ByRow(!=(\"\")), # drop unannotated oggs\n    :description =&gt; ByRow(!=(\"domain, Protein\")), # drop unannotated oggs\n    :log2FC =&gt; ByRow(&lt;(0)), # drop oggs increased in the presence of phage\n).ogg_name\nuniprot.var[indexin(sort(test_oggs), uniprot.var_names), [:og, :description]]\n\n16×2 DataFrame\n\n\n\nRow\nog\ndescription\n\n\n\nString\nString\n\n\n\n\n1\nCOG0835\nchemotaxis\n\n\n2\nCOG0842\nTransport permease protein\n\n\n3\nCOG1344\nbacterial-type flagellum-dependent cell motility\n\n\n4\nCOG1345\nRequired for morphogenesis and for the elongation of the flagellar filament by facilitating polymerization of the flagellin monomers at the tip of growing filament. Forms a capping structure, which prevents flagellin subunits (transported through the central channel of the flagellum) from leaking out without polymerization at the distal end\n\n\n5\nCOG1442\nlipopolysaccharide 3-alpha-galactosyltransferase activity\n\n\n6\nCOG1516\nflagellar protein fliS\n\n\n7\nCOG1776\nchemotaxis\n\n\n8\nCOG2186\nTranscriptional regulator\n\n\n9\nCOG2198\nHistidine kinase\n\n\n10\nCOG2944\nsequence-specific DNA binding\n\n\n11\nCOG3547\nTransposase (IS116 IS110 IS902 family)\n\n\n12\nCOG4495\nDomain of unknown function (DUF4176)\n\n\n13\nCOG4786\nFlagellar basal body rod\n\n\n14\nCOG5001\ncyclic-guanylate-specific phosphodiesterase activity\n\n\n15\nCOG5279\nprotein involved in cytokinesis, contains TGc (transglutaminase protease-like) domain\n\n\n16\nCOG5444\nnuclease activity\n\n\n\n\n\n\n\n# oggs from E. rectale test that are in Uniprot\nchosen_oggs_idx = indexin(test_oggs, uniprot.var_names);\n# make presence/absence matix `subset_ogg_mtx`\nsubset_ogg_mtx = upmtx[:, chosen_oggs_idx] .&gt; 0;\n@show chosen_oggs;\n\nchosen_oggs = [\"COG1345\", \"COG1344\", \"COG5444\", \"COG5001\", \"COG3547\", \"COG4495\", \"COG1442\", \"COG4786\", \"COG5279\", \"COG1776\", \"COG2944\", \"COG0842\", \"COG1516\", \"COG0835\", \"COG2186\", \"COG2198\"]\n\n\n\n# collect parent nodes back to pseudo-root of uniprot tree\nspecies_node_idx = findall(contains.(uniprot.obs.Species[treeorder], species_name))[1]\nspeciesnode = leafnodes[species_node_idx]\ndepthofspecies = network_distance(uptree, speciesnode)\nspeciesparents = []\nnode = speciesnode\nfor i in 1:depthofspecies\n    node = parent(node)\n    push!(speciesparents, node)\nend\ncladesizes = length.(getleafnames.(speciesparents))\n@info \"# of taxa per clade = $(cladesizes)\"\n\n┌ Info: # of taxa per clade = [3, 10, 23, 101, 216, 265, 380, 600, 733, 1022, 1065, 2376, 6709, 7047]\n└ @ Main /Users/bend/projects/Doran_etal_2023/notebooks/04_figure_04.ipynb:12\n\n\n\n# for each node find all children and measure percentage of children where \n# chosen oggs are present\ncladesateachtreelevel = getleafnames.(speciesparents);\nfrac_present = map(cladesateachtreelevel) do clade_ids\n    cladeidx = indexin(clade_ids, uniprot.obs_names)\n    mean(subset_ogg_mtx[cladeidx, :], dims=1) |&gt; vec\nend |&gt; stack\n\n# check how many oggs (n=16) are fully conserved across the smallest clade (n=3)\nislocallypresent = frac_present[:, 1] .== 1;\n@info \"# locally present = $(sum(islocallypresent)), # not locally present = $(sum(.!islocallypresent))\"\nnumcols = length(cladesizes);\n\n┌ Info: # locally present = 12, # not locally present = 4\n└ @ Main /Users/bend/projects/Doran_etal_2023/notebooks/04_figure_04.ipynb:11\n\n\n\n# plot the locally present oggs up through the tree\nplot(\n    xticks=(1:numcols, string.(cladesizes)),\n    xrotation=45,\n    ylabel=\"fractional coverage of taxa\",\n    xlabel=\"# taxa in clade\",\n    margin=5Plots.Measures.mm,\n    ylims=(0,1), widen=true,\n    size=(600,300),\n    yticks=0:.25:1,\n    legend=:bottomleft,\n)\nhline!([.25, .5, .75], c=:grey, alpha=.5, linestyle=:dash)\nviolin!(permutedims(1:numcols), frac_present[islocallypresent, :], alpha=.3, c=\"#6182ce\")\ndotplot!(permutedims(1:numcols), frac_present[islocallypresent, :], c=\"#6182ce\", alpha=.5, mode=:none, )\nscatter!([NaN], label=permutedims([\"$(species_name) locally conserved OGG (n=$(sum(islocallypresent)))\"]), c=[\"#6182ce\"], alpha=[0.5] )\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nthese results seemed to show that indeed the orthologs absent from phage-assoiated strains in E. rectale are present on over half of the 250 most closely related species. And, even across all bacteria, there at least 3 orthologs that are conserved across half of bacteria."
  },
  {
    "objectID": "04_figure_04.html#what-phage-related-differences-are-present-for-other-species",
    "href": "04_figure_04.html#what-phage-related-differences-are-present-for-other-species",
    "title": "Interpreting New Strain Relationships",
    "section": "What phage related differences are present for other species?",
    "text": "What phage related differences are present for other species?\nGiven the results in E. rectale we wanted to explore if these results were consistent across other species.\n\n\nfunction to plot sample oggs across distribution of oggs in uniprot\nfunction plot_conserved_oggs(species_title, chosen_oggs)\n    chosen_oggs_idx = indexin(chosen_oggs, uniprot.var_names);\n    coverage_uniprot = mean(upmtx .&gt; 0, dims=1) |&gt; vec\n    sample_coverage = coverage_uniprot# [chosen_oggs_idx]\n    sample_percentile = map(sample_coverage) do x \n        mean(coverage_uniprot .&lt; x)\n    end\n    order = sortperm(sample_percentile)\n    plot(\n        title=species_title,\n        xlabel=\"percentile\",\n        ylabel=\"fractional presence\",\n        lims=(0,1), \n        # widen=true, \n        ratio=1,\n        grid=true,\n        ticks=[0, .5, 1],\n        tickdirection=:out,\n        framestyle=:box,\n    )\n\n\n    plot!(sample_percentile[order], sample_coverage[order],\n        c=:lightgrey, linewidth=4,\n    )\n    sample_coverage = coverage_uniprot[chosen_oggs_idx]\n    sample_percentile = map(sample_coverage) do x \n        mean(coverage_uniprot .&lt; x)\n    end\n    p1 = scatter!(sample_percentile, sample_coverage,\n        alpha=.5,c=\"#6182ce\", markersize=6,\n    )\n    margindensity = density(coverage_uniprot, \n        trim=true, fill=0, c=:yellow, linecolor=:black, permute=(:x, :y),\n        ylabel=\"density\",  yrotation=270, yticks=0:5:10,\n        # xticks=false,\n    )\n    plot(p1, margindensity, layout = @layout([a{.9w} b]), size=(500,400), link=:y)\nend\n\n\nplot_conserved_oggs (generic function with 1 method)\n\n\n\n\nfunctions to extract strain ids and donor ids to each statistical test\nfunction getuniquedonors_fromtree(tree, target_id) \n    node = filter!(n -&gt; id(n) == target_id, prewalk(tree))[1]\n    grp1 = getleafnames(children(node)[1])\n    doner_ids_1 = join(unique(replace.(grp1, r\"\\.\\d+$\"=&gt;\"\")), \";\")\n    grp2 = getleafnames(children(node)[2])\n    doner_ids_2 = join(unique(replace.(grp2, r\"\\.\\d+$\"=&gt;\"\")), \";\")\n    doner_ids_1, doner_ids_2\nend\nfunction getuniquestrains_fromtree(tree, target_id) \n    node = filter!(n -&gt; id(n) == target_id, prewalk(tree))[1]\n    grp1 = getleafnames(children(node)[1])\n    doner_ids_1 = join(grp1, \";\")\n    grp2 = getleafnames(children(node)[2])\n    doner_ids_2 = join(grp2, \";\")\n    doner_ids_1, doner_ids_2\nend\n\n\ngetuniquestrains_fromtree (generic function with 1 method)\n\n\n\nstrain_level_testresults = testresults |&gt;\n    df-&gt;subset(df, \n        :tree_level =&gt; ByRow(==(\"strain level\")), \n        :log2FC =&gt; ByRow(x-&gt; abs(x) &gt; 1), \n        :qval_BH =&gt; ByRow(&lt;(0.05)),\n        ) |&gt;\n    df-&gt;leftjoin(df, uniprot.var[:, [:og, :description]], on = :ogg_name =&gt; :og) |&gt;\n    df-&gt;subset(df, :description =&gt; ByRow(x-&gt; (!ismissing(x)) && (x!=(\"\")))) |&gt;\n    df-&gt;select(df, :nodeids, :nodedepth, :grp1_species_mode =&gt; :species, :grp1_N, :grp2_N, :ogg_name,:ogg_freqs, :grp1_prp_exp, :grp2_prp_exp, :log2FC, :qval_BH, :description) |&gt;\n    df-&gt;groupby(df, :nodeids) |&gt;\n    df-&gt;transform(df, \n        :nodeids =&gt; ByRow(x -&gt; getuniquedonors_fromtree(strvartree, x)) =&gt; [:grp1_donor_ids, :grp2_donor_ids],\n        :nodeids =&gt; ByRow(x -&gt; getuniquestrains_fromtree(strvartree, x)) =&gt; [:grp1_strain_ids, :grp2_strain_ids],\n    ) |&gt;\n    df-&gt;sort(df, [:nodeids, :log2FC])\nfirst(strain_level_testresults, 5)\n\n5×16 DataFrame\n\n\n\nRow\nnodeids\nnodedepth\nspecies\ngrp1_N\ngrp2_N\nogg_name\nogg_freqs\ngrp1_prp_exp\ngrp2_prp_exp\nlog2FC\nqval_BH\ndescription\ngrp1_donor_ids\ngrp2_donor_ids\ngrp1_strain_ids\ngrp2_strain_ids\n\n\n\nInt64\nFloat64\nString31\nInt64\nInt64\nString15\nFloat64\nFloat64\nFloat64\nFloat64\nFloat64\nString?\nString\nString\nString\nString\n\n\n\n\n1\n4\n1.59622\nBacteroides uniformis\n4\n23\nCOG1115\n0.924157\n0.25\n1.0\n-1.3891\n0.0\namino acid carrier protein\nDFI.1;MSK.17\nMSK.19;MSK.20;MSK.16;DFI.3;MSK.18;DFI.4\nDFI.1.247;DFI.1.135;DFI.1.173;MSK.17.15\nMSK.19.71;MSK.19.54;MSK.19.4;MSK.19.91;MSK.19.84;MSK.20.30;MSK.20.3;MSK.20.79;MSK.16.71;MSK.16.7;MSK.16.46;MSK.16.44;MSK.16.39;DFI.3.57;MSK.18.66;MSK.18.33;MSK.18.78;MSK.18.89;MSK.18.30;MSK.18.25;MSK.18.77;MSK.18.74;DFI.4.149\n\n\n2\n4\n1.59622\nBacteroides uniformis\n4\n23\nCOG0639\n0.266854\n0.25\n0.956522\n-1.26605\n0.0\nphosphoprotein phosphatase activity\nDFI.1;MSK.17\nMSK.19;MSK.20;MSK.16;DFI.3;MSK.18;DFI.4\nDFI.1.247;DFI.1.135;DFI.1.173;MSK.17.15\nMSK.19.71;MSK.19.54;MSK.19.4;MSK.19.91;MSK.19.84;MSK.20.30;MSK.20.3;MSK.20.79;MSK.16.71;MSK.16.7;MSK.16.46;MSK.16.44;MSK.16.39;DFI.3.57;MSK.18.66;MSK.18.33;MSK.18.78;MSK.18.89;MSK.18.30;MSK.18.25;MSK.18.77;MSK.18.74;DFI.4.149\n\n\n3\n4\n1.59622\nBacteroides uniformis\n4\n23\nCOG3958\n0.842697\n0.0\n1.0\n-1.12717\n0.0\ntransketolase activity\nDFI.1;MSK.17\nMSK.19;MSK.20;MSK.16;DFI.3;MSK.18;DFI.4\nDFI.1.247;DFI.1.135;DFI.1.173;MSK.17.15\nMSK.19.71;MSK.19.54;MSK.19.4;MSK.19.91;MSK.19.84;MSK.20.30;MSK.20.3;MSK.20.79;MSK.16.71;MSK.16.7;MSK.16.46;MSK.16.44;MSK.16.39;DFI.3.57;MSK.18.66;MSK.18.33;MSK.18.78;MSK.18.89;MSK.18.30;MSK.18.25;MSK.18.77;MSK.18.74;DFI.4.149\n\n\n4\n4\n1.59622\nBacteroides uniformis\n4\n23\nCOG3959\n0.842697\n0.0\n1.0\n-1.12717\n0.0\ntransketolase activity\nDFI.1;MSK.17\nMSK.19;MSK.20;MSK.16;DFI.3;MSK.18;DFI.4\nDFI.1.247;DFI.1.135;DFI.1.173;MSK.17.15\nMSK.19.71;MSK.19.54;MSK.19.4;MSK.19.91;MSK.19.84;MSK.20.30;MSK.20.3;MSK.20.79;MSK.16.71;MSK.16.7;MSK.16.46;MSK.16.44;MSK.16.39;DFI.3.57;MSK.18.66;MSK.18.33;MSK.18.78;MSK.18.89;MSK.18.30;MSK.18.25;MSK.18.77;MSK.18.74;DFI.4.149\n\n\n5\n4\n1.59622\nBacteroides uniformis\n4\n23\nCOG1226\n0.241573\n1.0\n1.0\n-1.06998\n0.0\n(belongs to the monovalent cation proton antiporter 2 (CPA2) transporter (TC 2.A.37) family)\nDFI.1;MSK.17\nMSK.19;MSK.20;MSK.16;DFI.3;MSK.18;DFI.4\nDFI.1.247;DFI.1.135;DFI.1.173;MSK.17.15\nMSK.19.71;MSK.19.54;MSK.19.4;MSK.19.91;MSK.19.84;MSK.20.30;MSK.20.3;MSK.20.79;MSK.16.71;MSK.16.7;MSK.16.46;MSK.16.44;MSK.16.39;DFI.3.57;MSK.18.66;MSK.18.33;MSK.18.78;MSK.18.89;MSK.18.30;MSK.18.25;MSK.18.77;MSK.18.74;DFI.4.149\n\n\n\n\n\n\n\nCSV.write(joinpath(rdir, \"strain_level_testresults_with_annotations.tsv\"), strain_level_testresults; delim=\"\\t\")\n\n\"/Users/bend/projects/Doran_etal_2023/_research/strain_variation_wilcoxon_tests/strain_level_testresults_with_annotations.tsv\"\n\n\n\n\nstrain-level test results where ogg is only shown if was not found elsewhere\nuniqueOGGresults |&gt;\n    df-&gt;subset(df, \n        :tree_level =&gt; ByRow(==(\"strain level\")), \n        :log2FC =&gt; ByRow(x-&gt; abs(x) &gt; 1), \n        :qval_BH =&gt; ByRow(&lt;(0.05)),\n        ) |&gt;\n    df-&gt;leftjoin(df, uniprot.var[:, [:og, :description]], on = :ogg_name =&gt; :og) |&gt;\n    df-&gt;subset(df, :description =&gt; ByRow(x-&gt; (!ismissing(x)) && (x!=(\"\")))) |&gt;\n    df-&gt;select(df, :nodeids, :nodedepth, :grp1_species_mode =&gt; :species, :grp1_N, :grp2_N, :ogg_name,:ogg_freqs, :grp1_prp_exp, :grp2_prp_exp, :log2FC, :qval_BH, :description) |&gt;\n    df-&gt;groupby(df, :nodeids) |&gt;\n    df-&gt;transform(df, \n        :nodeids =&gt; ByRow(x -&gt; getuniquedonors_fromtree(strvartree, x)) =&gt; [:grp1_donor_ids, :grp2_donor_ids],\n        :nodeids =&gt; ByRow(x -&gt; getuniquestrains_fromtree(strvartree, x)) =&gt; [:grp1_strain_ids, :grp2_strain_ids],\n    ) |&gt;\n    df-&gt;sort(df, [:nodeids, :log2FC]) |&gt;\n    df-&gt;CSV.write(joinpath(rdir, \"uniqueOGGresults_strainlevel_testresults.tsv\"), df; delim=\"\\t\")\n\n\n\"/Users/bend/projects/Doran_etal_2023/_research/strain_variation_wilcoxon_tests/uniqueOGGresults_strainlevel_testresults.tsv\"\n\n\nExploring these tables of test results revealed other instances of phage related strain level differences. For P. vulgatus, M. gnavus, B. thetaiotaomicron, and C. comes we found cases where OGGs associated with phage infection where more abundant in multiple strains in contrast to other “phage suppressed OGGs”. We found no specificity in degree of conservation for these phage suppressed OGGs, highly conserved OGGs were just as likely to be suppressed as OGGs only found in a small number of taxa across all of UniProt.\n\nP. vulgatus\n\nspecies_title = \"Phocaeicola vulgatus\"\ntargetid = \"DFI.3.23\"\nstrvar_leaves = getleaves(strvartree)\nbasenode = strvar_leaves[findfirst(n-&gt;name(n) == targetid, strvar_leaves)]\nsubtree = readnw(nwstr(nthparent(basenode, 4)))\nladderize!(subtree)\n# tiplabels = join.(eachrow(strvarobs[indexin(getleafnames(subtree), strvarobs.Strain_ID), [:Strain_ID, :NCBI_Species]]), \" \")\n# idmapping = Dict(k=&gt;v for (k,v) in zip(getleafnames(subtree), tiplabels))\n# rename_treeleaves!(subtree, idmapping)\n\nplot(subtree,\n    c=:black,\n    lw=3, fs=5,\n    size=(600,600),\n    rightmargin=3Plots.cm,\n    leftmargin=10Plots.mm,\n    ylabel=species_title * \" (n = $(length(getleaves(subtree))))\",\n    framestyle=:grid,\n    ticks=false,\n)\n\n# find and plot test nodes in subtree\nleaves_of_test_nodes = map(prewalk(nthparent(basenode, 4))) do node; test_nodes=unique(strain_level_testresults.nodeids)\n    if (Int(id(node)) ∈ test_nodes) && minimum(length.(getleaves.(children(node)))) &gt; 6\n        join(sort(getleafnames(node)), \";\")\n    else\n        nothing\n    end\nend |&gt; x-&gt;filter(!isnothing, x)\nsubtreepos = NewickTree.treepositions(subtree)\ntestnode_positions = map(keys(subtreepos), values(subtreepos)) do k,v\n    x, y = v\n    label = join(sort(getleafnames(k)), \";\")\n    if label ∈ leaves_of_test_nodes\n        (; x, y, label)\n    else\n        nothing\n    end\nend |&gt; x-&gt;filter(!isnothing, x)\n@df DataFrame(testnode_positions) scatter!(:x, :y, markersize=6, c=:yellow, markershape=:diamond)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# collected by manually searching through strain-level test results\nnotable_oggs = [\"COG0863\",\"COG1083\",\"COG4744\", \"32ZV1\", \"COG0666\",\"COG2214\",\"2Z8QV\"]\nplot_conserved_oggs(\"P. vulgatus\", notable_oggs) \n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nM. gnavus\n\nspecies_title = \"[Ruminococcus] gnavus\"\ntargetid = \"MSK.22.91\"\nstrvar_leaves = getleaves(strvartree)\nbasenode = strvar_leaves[findfirst(n-&gt;name(n) == targetid, strvar_leaves)]\nsubtreeroot = nthparent(basenode, 5)\nsubtree = readnw(nwstr(subtreeroot))\nladderize!(subtree)\n# tiplabels = join.(eachrow(strvarobs[indexin(getleafnames(subtree), strvarobs.Strain_ID), [:Strain_ID, :NCBI_Species]]), \" \")\n# idmapping = Dict(k=&gt;v for (k,v) in zip(getleafnames(subtree), tiplabels))\n# rename_treeleaves!(subtree, idmapping)\n\nplot(subtree,\n    c=:black,\n    lw=3, fs=5,\n    size=(600,600),\n    rightmargin=3Plots.cm,\n    leftmargin=10Plots.mm,\n    ylabel=\"M. gnavus (n = 41)\",\n    framestyle=:grid,\n    ticks=false,\n)\n\n# find and plot test nodes in subtree\nleaves_of_test_nodes = map(prewalk(subtreeroot)) do node; test_nodes=unique(strain_level_testresults.nodeids)\n    if (Int(id(node)) ∈ test_nodes) && minimum(length.(getleaves.(children(node)))) &gt;= 4\n        join(sort(getleafnames(node)), \";\")\n    else\n        nothing\n    end\nend |&gt; x-&gt;filter(!isnothing, x)\nsubtreepos = NewickTree.treepositions(subtree)\ntestnode_positions = map(keys(subtreepos), values(subtreepos)) do k,v\n    x, y = v\n    label = join(sort(getleafnames(k)), \";\")\n    if label ∈ leaves_of_test_nodes\n        (; x, y, label)\n    else\n        nothing\n    end\nend |&gt; x-&gt;filter(!isnothing, x)\n@df DataFrame(testnode_positions) scatter!(:x, :y, markersize=6, c=:yellow, markershape=:diamond)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# collected by manually searching through strain-level test results\nnotable_oggs =     [\"COG1440\",\"COG1447\",\"COG1694\", \"COG0531\",\"COG1501\",\"COG2222\"]\nplot_conserved_oggs(\"M. gnavus\", notable_oggs) \n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nB. thetaiotaomicron\n\nspecies_title = \"Bacteroides thetaiotaomicron\"\ntargetid = \"DFI.4.108\"\nstrvar_leaves = getleaves(strvartree)\nbasenode = strvar_leaves[findfirst(n-&gt;name(n) == targetid, strvar_leaves)]\nsubtreeroot = nthparent(basenode, 4)\nsubtree = readnw(nwstr(subtreeroot))\nladderize!(subtree)\n# tiplabels = join.(eachrow(strvarobs[indexin(getleafnames(subtree), strvarobs.Strain_ID), [:Strain_ID, :NCBI_Species]]), \" \")\n# idmapping = Dict(k=&gt;v for (k,v) in zip(getleafnames(subtree), tiplabels))\n# rename_treeleaves!(subtree, idmapping)\n\nplot(subtree,\n    c=:black,\n    lw=3, fs=5,\n    size=(600,600),\n    rightmargin=3Plots.cm,\n    leftmargin=10Plots.mm,\n    ylabel=species_title * \" (n = $(length(getleaves(subtree))))\",\n    framestyle=:grid,\n    ticks=false,\n)\n\n# find and plot phage related test nodes in subtree\nleaves_of_test_nodes = map(prewalk(subtreeroot)) do node; test_nodes=unique(strain_level_testresults.nodeids)\n    if (Int(id(node)) ∈ test_nodes) && minimum(length.(getleaves.(children(node)))) == 7\n        join(sort(getleafnames(node)), \";\")\n    else\n        nothing\n    end\nend |&gt; x-&gt;filter(!isnothing, x)\nsubtreepos = NewickTree.treepositions(subtree)\ntestnode_positions = map(keys(subtreepos), values(subtreepos)) do k,v\n    x, y = v\n    label = join(sort(getleafnames(k)), \";\")\n    if label ∈ leaves_of_test_nodes\n        (; x, y, label)\n    else\n        nothing\n    end\nend |&gt; x-&gt;filter(!isnothing, x)\n@df DataFrame(testnode_positions) scatter!(:x, :y, markersize=6, c=:yellow, markershape=:diamond)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# collected by manually searching through strain-level test results\nnotable_oggs = [\"COG1474\",\"COG2942\",\"COG3410\"]\nplot_conserved_oggs(\"B. thetaiotaomicron\", notable_oggs)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nC. comes\n\nspecies_title = \"Coprococcus comes\"\ntargetid = \"MSK.20.88\"\nstrvar_leaves = getleaves(strvartree)\nbasenode = strvar_leaves[findfirst(n-&gt;name(n) == targetid, strvar_leaves)]\nsubtreeroot = nthparent(basenode, 6)\nsubtree = readnw(nwstr(subtreeroot))\nladderize!(subtree)\n# tiplabels = join.(eachrow(strvarobs[indexin(getleafnames(subtree), strvarobs.Strain_ID), [:Strain_ID, :NCBI_Species]]), \" \")\n# idmapping = Dict(k=&gt;v for (k,v) in zip(getleafnames(subtree), tiplabels))\n# rename_treeleaves!(subtree, idmapping)\n\nplot(subtree,\n    c=:black,\n    lw=3, fs=5,\n    size=(600,600),\n    rightmargin=3Plots.cm,\n    leftmargin=10Plots.mm,\n    ylabel=species_title * \" (n = $(length(getleaves(subtree))))\",\n    framestyle=:grid,\n    ticks=false,\n)\n\n# find and plot phage related test nodes in subtree\nleaves_of_test_nodes = map(prewalk(subtreeroot)) do node; test_nodes=unique(strain_level_testresults.nodeids)\n    if (Int(id(node)) ∈ test_nodes) && minimum(length.(getleaves.(children(node)))) ==5\n        join(sort(getleafnames(node)), \";\")\n    else\n        nothing\n    end\nend |&gt; x-&gt;filter(!isnothing, x)\nsubtreepos = NewickTree.treepositions(subtree)\ntestnode_positions = map(keys(subtreepos), values(subtreepos)) do k,v\n    x, y = v\n    label = join(sort(getleafnames(k)), \";\")\n    if label ∈ leaves_of_test_nodes\n        (; x, y, label)\n    else\n        nothing\n    end\nend |&gt; x-&gt;filter(!isnothing, x)\n@df DataFrame(testnode_positions) scatter!(:x, :y, markersize=6, c=:yellow, markershape=:diamond)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# collected by manually searching through strain-level test results\nnotable_oggs = [\"COG0145\",\"COG1011\",\"COG1351\",\"COG4951\",\"2Z81G\",]\nplot_conserved_oggs(\"C. comes\", notable_oggs)"
  }
]